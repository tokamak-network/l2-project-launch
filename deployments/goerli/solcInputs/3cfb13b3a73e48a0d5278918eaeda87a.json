{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./StorageSlot.sol\";\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/common/AccessibleCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./AccessRoleCommon.sol\";\n\ncontract AccessibleCommon is AccessRoleCommon, AccessControl {\n    modifier onlyOwner() {\n        require(isAdmin(msg.sender), \"Accessible: Caller is not an admin\");\n        _;\n    }\n\n    /// @dev add admin\n    /// @param account  address to add\n    function addAdmin(address account) public virtual onlyOwner {\n        grantRole(ADMIN_ROLE, account);\n    }\n\n    /// @dev remove admin\n    /// @param account  address to remove\n    function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(ADMIN_ROLE, account);\n    }\n\n    /// @dev transfer admin\n    /// @param newAdmin new admin address\n    function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(ADMIN_ROLE, newAdmin);\n        renounceRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev whether admin\n    /// @param account  address to check\n    function isAdmin(address account) public view virtual returns (bool) {\n        return hasRole(ADMIN_ROLE, account);\n    }\n}\n"
    },
    "contracts/common/AccessiblePlusCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AccessibleCommon.sol\";\n\ncontract AccessiblePlusCommon is AccessibleCommon {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER\");\n\n    modifier onlyMinter() {\n        require(\n            isMinter(msg.sender),\n            \"AccessiblePlusCommon: Caller is not a minter\"\n        );\n        _;\n    }\n    modifier onlyBurner() {\n        require(\n            isBurner(msg.sender),\n            \"AccessiblePlusCommon: Caller is not a burner\"\n        );\n        _;\n    }\n\n    function isMinter(address account) public view virtual returns (bool) {\n        return hasRole(MINTER_ROLE, account);\n    }\n\n    function isBurner(address account) public view virtual returns (bool) {\n        return hasRole(BURNER_ROLE, account);\n    }\n\n    function addMinter(address account) public virtual onlyOwner {\n        grantRole(MINTER_ROLE, account);\n    }\n\n    function addBurner(address account) public virtual onlyOwner {\n        grantRole(BURNER_ROLE, account);\n    }\n\n    function removeMinter(address account) public virtual onlyOwner {\n        revokeRole(MINTER_ROLE, account);\n    }\n\n    function removeBurner(address account) public virtual onlyOwner {\n        revokeRole(BURNER_ROLE, account);\n    }\n}\n"
    },
    "contracts/common/AccessRoleCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AccessRoleCommon {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n    bytes32 public constant POLICY_ROLE = keccak256(\"POLICY_ROLE\");\n}\n"
    },
    "contracts/common/ProxyAccessCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./AccessRoleCommon.sol\";\n\ncontract ProxyAccessCommon is AccessRoleCommon, AccessControl {\n    modifier onlyOwner() {\n        require(isAdmin(msg.sender) || isProxyAdmin(msg.sender), \"Accessible: Caller is not an admin\");\n        _;\n    }\n\n    modifier onlyProxyOwner() {\n        require(isProxyAdmin(msg.sender), \"Accessible: Caller is not an proxy admin\");\n        _;\n    }\n\n    modifier onlyPolicyOwner() {\n        require(isPolicy(msg.sender), \"Accessible: Caller is not an policy admin\");\n        _;\n    }\n\n    function addProxyAdmin(address _owner)\n        external\n        onlyProxyOwner\n    {\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function removeProxyAdmin()\n        public virtual onlyProxyOwner\n    {\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function transferProxyAdmin(address newAdmin)\n        external virtual\n        onlyProxyOwner\n    {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n\n    /// @dev add admin\n    /// @param account  address to add\n    function addAdmin(address account) public virtual onlyProxyOwner {\n        grantRole(ADMIN_ROLE, account);\n    }\n\n    /// @dev remove admin\n    function removeAdmin() public virtual onlyOwner {\n        renounceRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev transfer admin\n    /// @param newAdmin new admin address\n    function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(ADMIN_ROLE, newAdmin);\n        renounceRole(ADMIN_ROLE, msg.sender);\n    }\n\n    function addPolicy(address _account) public virtual onlyProxyOwner {\n        grantRole(POLICY_ROLE, _account);\n    }\n\n    function removePolicy() public virtual onlyPolicyOwner {\n        renounceRole(POLICY_ROLE, msg.sender);\n    }\n\n    function deletePolicy(address _account) public virtual onlyProxyOwner {\n        revokeRole(POLICY_ROLE, _account);\n    }\n\n    /// @dev whether admin\n    /// @param account  address to check\n    function isAdmin(address account) public view virtual returns (bool) {\n        return hasRole(ADMIN_ROLE, account);\n    }\n\n    function isProxyAdmin(address account) public view virtual returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, account);\n    }\n\n    function isPolicy(address account) public view virtual returns (bool) {\n        return hasRole(POLICY_ROLE, account);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function mint(address account, uint256 amount) external returns (bool);\n\n    function burn(address account, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IIERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IIERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILockTOS.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"../libraries/LibLockTOS.sol\";\n\n\ninterface ILockTOS {\n\n    /// @dev Returns addresses of all holders of LockTOS\n    function allHolders() external returns (address[] memory);\n\n    /// @dev Returns addresses of active holders of LockTOS\n    function activeHolders() external returns (address[] memory);\n\n    /// @dev Returns all withdrawable locks\n    function withdrawableLocksOf(address user) external view returns (uint256[] memory);\n\n    /// @dev Returns all locks of `_addr`\n    function locksOf(address _addr) external view returns (uint256[] memory);\n\n    /// @dev Returns all locks of `_addr`\n    function activeLocksOf(address _addr) external view returns (uint256[] memory);\n\n    /// @dev Total locked amount of `_addr`\n    function totalLockedAmountOf(address _addr) external view returns (uint256);\n\n    /// @dev     jhswuqhdiuwjhdoiehdoijijf   bhabcgfzvg tqafstqfzys amount of `_addr`\n    function withdrawableAmountOf(address _addr) external view returns (uint256);\n\n    /// @dev Returns all locks of `_addr`\n    function locksInfo(uint256 _lockId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @dev Returns all history of `_addr`\n    function pointHistoryOf(uint256 _lockId)\n        external\n        view\n        returns (LibLockTOS.Point[] memory);\n\n    /// @dev Total vote weight\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Total vote weight at `_timestamp`\n    function totalSupplyAt(uint256 _timestamp) external view returns (uint256);\n\n    /// @dev Vote weight of lock at `_timestamp`\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Vote weight of lock\n    function balanceOfLock(uint256 _lockId) external view returns (uint256);\n\n    /// @dev Vote weight of a user at `_timestamp`\n    function balanceOfAt(address _addr, uint256 _timestamp)\n        external\n        view\n        returns (uint256 balance);\n\n    /// @dev Vote weight of a iser\n    function balanceOf(address _addr) external view returns (uint256 balance);\n\n    /// @dev Increase amount\n    function increaseAmount(uint256 _lockId, uint256 _value) external;\n\n    /// @dev Deposits value for '_addr'\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) external;\n\n    /// @dev Create lock using permit\n    function createLockWithPermit(\n        uint256 _value,\n        uint256 _unlockTime,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 lockId);\n\n    /// @dev Create lock\n    function createLock(uint256 _value, uint256 _unlockTime)\n        external\n        returns (uint256 lockId);\n\n    /// @dev Increase\n    function increaseUnlockTime(uint256 _lockId, uint256 unlockTime) external;\n\n    /// @dev Withdraw all TOS\n    function withdrawAll() external;\n\n    /// @dev Withdraw TOS\n    function withdraw(uint256 _lockId) external;\n\n    /// @dev needCheckpoint\n    function needCheckpoint() external view returns (bool need);\n\n    /// @dev Global checkpoint\n    function globalCheckpoint() external;\n\n    /// @dev set MaxTime\n    function setMaxTime(uint256 _maxTime) external;\n}\n"
    },
    "contracts/interfaces/ILockTOSv2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"../libraries/LibLockTOSv2.sol\";\n\n\ninterface ILockTOSv2 {\n\n    // /// @dev Returns addresses of all holders of LockTOS\n    // function allHolders() external returns (address[] memory);\n\n    // /// @dev Returns addresses of active holders of LockTOS\n    // function activeHolders() external returns (address[] memory);\n\n    /// @dev Returns all withdrawable locks\n    function withdrawableLocksOf(address user) external view returns (uint256[] memory);\n\n    /// @dev Returns all locks of `_addr`\n    function locksOf(address _addr) external view returns (uint256[] memory);\n\n    // /// @dev Returns all locks of `_addr`\n    // function activeLocksOf(address _addr) external view returns (uint256[] memory);\n\n    /// @dev Total locked amount of `_addr`\n    function totalLockedAmountOf(address _addr) external view returns (uint256);\n\n    /// @dev     jhswuqhdiuwjhdoiehdoijijf   bhabcgfzvg tqafstqfzys amount of `_addr`\n    function withdrawableAmountOf(address _addr) external view returns (uint256);\n\n    /// @dev Returns all locks of `_addr`\n    function locksInfo(uint256 _lockId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /// @dev Returns all history of `_addr`\n    function pointHistoryOf(uint256 _lockId)\n        external\n        view\n        returns (LibLockTOSv2.Point[] memory);\n\n    /// @dev Total vote weight\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Total vote weight at `_timestamp`\n    function totalSupplyAt(uint256 _timestamp) external view returns (uint256);\n\n    /// @dev Vote weight of lock at `_timestamp`\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Vote weight of lock\n    function balanceOfLock(uint256 _lockId) external view returns (uint256);\n\n    /// @dev Vote weight of a user at `_timestamp`\n    function balanceOfAt(address _addr, uint256 _timestamp)\n        external\n        view\n        returns (uint256 balance);\n\n    /// @dev Vote weight of a iser\n    // function balanceOf(address _addr) external view returns (uint256 balance);\n\n    /// @dev Increase amount\n    function increaseAmount(uint256 _lockId, uint256 _value) external;\n\n    /// @dev Deposits value for '_addr'\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) external;\n\n    /// @dev Create lock\n    function createLock(uint256 _value, uint256 _unlockTime)\n        external\n        returns (uint256 lockId);\n\n    /// @dev Increase\n    function increaseUnlockTime(uint256 _lockId, uint256 unlockTime) external;\n\n    /// @dev Withdraw all TOS\n    function withdrawAll() external;\n\n    /// @dev Withdraw TOS\n    function withdraw(uint256 _lockId) external;\n\n    /// @dev needCheckpoint\n    function needCheckpoint() external view returns (bool need);\n\n    /// @dev Global checkpoint\n    function globalCheckpoint() external;\n\n    /// @dev set MaxTime\n    function setMaxTime(uint256 _maxTime) external;\n}\n"
    },
    "contracts/interfaces/ILockTOSv2Event.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ninterface ILockTOSv2Event {\n\n event LockCreated(\n        address account,\n        uint256 lockId,\n        uint256 value,\n        uint256 unlockTime\n    );\n    event LockAmountIncreased(address account, uint256 lockId, uint256 value);\n    event LockUnlockTimeIncreased(\n        address account,\n        uint256 lockId,\n        uint256 unlockTime\n    );\n    event LockIncreased(address account, uint256 lockId, uint256 value, uint256 unlockTime);\n    event LockDeposited(address account, uint256 lockId, uint256 value);\n    event LockWithdrawn(address account, uint256 lockId, uint256 value);\n    event IncreasedUnlimitedLock(address caller, address account, uint256 amount);\n    event DecreasedUnlimitedLock(address caller, address account, uint256 amount);\n    event TransferUnlimitedLock(address from, address to, uint256 amount);\n\n}\n"
    },
    "contracts/interfaces/IProxyAction.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\n\n/// @title IProxyAction\ninterface IProxyAction {\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index\n    /// @param _alive _alive\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external;\n\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        external;\n\n\n    /// @dev set selectors of Implementation\n    /// @param _selectors being added selectors\n    /// @param _imp implementation address\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) external  ;\n\n\n\n    /// onlyOwner\n\n    /// @notice Set pause state\n    /// @param _pause true:pause or false:resume\n    function setProxyPause(bool _pause) external ;\n\n\n    /// anybody\n\n    /// @dev view implementation address of selector of function\n    /// @param _selector selector of function\n    /// @return impl address of the implementation\n    function getSelectorImplementation2(bytes4 _selector)\n        external\n        view\n        returns (address impl);\n\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return address of the implementation\n    function implementation2(uint256 _index) external view returns (address) ;\n}\n\n"
    },
    "contracts/interfaces/IProxyEvent.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\n\n/// @title IProxyEvent\ninterface IProxyEvent {\n\n    event Upgraded(address indexed implementation);\n\n    event SetAliveImplementation(address indexed impl, bool alive);\n    event SetSelectorImplementation(bytes4 indexed selector, address indexed impl);\n\n\n}\n"
    },
    "contracts/interfaces/ITOS.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ninterface ITOS {\n    /// @dev Issue a token.\n    /// @param to  who takes the issue\n    /// @param amount the amount to issue\n    function mint(address to, uint256 amount) external returns (bool);\n\n    // @dev burn a token.\n    /// @param from Whose tokens are burned\n    /// @param amount the amount to burn\n    function burn(address from, uint256 amount) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    /// @dev Authorizes the owner's token to be used by the spender as much as the value.\n    /// @dev The signature must have the owner's signature.\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param v the owner's signature - v\n    /// @param r the owner's signature - r\n    /// @param s the owner's signature - s\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// @dev verify the signature\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param _nounce the _nounce\n    /// @param sigR the owner's signature - r\n    /// @param sigS the owner's signature - s\n    /// @param sigV the owner's signature - v\n    function verify(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint256 _nounce,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) external view returns (bool);\n\n    /// @dev the hash of Permit\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param _nounce the _nounce\n    function hashPermit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint256 _nounce\n    ) external view returns (bytes32);\n}\n"
    },
    "contracts/L1/factory/L1ERC20A_TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* Contract Imports */\nimport { L1TokenFactory } from \"./L1TokenFactory.sol\";\nimport { ERC20A } from \"../tokens/ERC20A.sol\";\n\n/**\n * @title L1ERC20A_TokenFactory\n * @dev\n */\ncontract L1ERC20A_TokenFactory is L1TokenFactory {\n\n    event CreatedERC20A(address contractAddress, string name, string symbol, uint256 initialSupply, address to);\n\n    function create(\n        string calldata name,\n        string calldata symbol,\n        uint256 initialSupply,\n        address to\n    ) external override returns (address) {\n        require(to != address(0), \"to address is zero\");\n        require(initialSupply != 0, \"ERC20A is non mintable, so initialSupply must be greater than zero.\");\n\n        require(bytes(name).length > 0, \"name is empty\");\n        require(bytes(symbol).length > 0, \"symbol is empty\");\n\n        ERC20A token = new ERC20A(name, symbol, initialSupply, to);\n        require(address(token) != address(0), \"token zero\");\n\n        createdContracts[totalCreatedContracts] = ContractInfo(address(token), name, symbol);\n        totalCreatedContracts++;\n\n        emit CreatedERC20A(address(token), name, symbol, initialSupply, to);\n\n        return address(token);\n    }\n\n\n}"
    },
    "contracts/L1/factory/L1ERC20B_TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n/* Contract Imports */\nimport { L1TokenFactory } from \"./L1TokenFactory.sol\";\nimport { ERC20B } from \"../tokens/ERC20B.sol\";\n\n/**\n * @title L1ERC20B_TokenFactory\n * @dev\n */\ncontract L1ERC20B_TokenFactory is L1TokenFactory {\n\n    event CreatedERC20B(address contractAddress, string name, string symbol, uint256 initialSupply, address owner);\n\n    function create(\n        string calldata name,\n        string calldata symbol,\n        uint256 initialSupply,\n        address owner\n    ) external override returns (address) {\n        require(owner != address(0), \"owner address is zero\");\n\n        require(bytes(name).length > 0, \"name is empty\");\n        require(bytes(symbol).length > 0, \"symbol is empty\");\n\n        ERC20B token = new ERC20B(name, symbol, initialSupply, owner);\n        require(address(token) != address(0), \"token zero\");\n\n        createdContracts[totalCreatedContracts] = ContractInfo(address(token), name, symbol);\n        totalCreatedContracts++;\n\n        emit CreatedERC20B(address(token), name, symbol, initialSupply, owner);\n\n        return address(token);\n    }\n\n}"
    },
    "contracts/L1/factory/L1ERC20C_TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* Contract Imports */\nimport { L1TokenFactory } from \"./L1TokenFactory.sol\";\nimport { ERC20C } from \"../tokens/ERC20C.sol\";\n\n/**\n * @title L1ERC20C_TokenFactory\n * @dev\n */\ncontract L1ERC20C_TokenFactory is L1TokenFactory {\n\n    event CreatedERC20C(address contractAddress, string name, string symbol, uint256 initialSupply, address to);\n\n    function create(\n        string calldata name,\n        string calldata symbol,\n        uint256 initialSupply,\n        address owner\n    ) external override returns (address) {\n        require(owner != address(0), \"owner address is zero\");\n        require(initialSupply != 0, \"ERC20C is non mintable, so initialSupply must be greater than zero.\");\n\n        require(bytes(name).length > 0, \"name is empty\");\n        require(bytes(symbol).length > 0, \"symbol is empty\");\n\n        ERC20C token = new ERC20C(name, symbol, initialSupply, owner);\n        require(address(token) != address(0), \"token zero\");\n\n        createdContracts[totalCreatedContracts] = ContractInfo(address(token), name, symbol);\n        totalCreatedContracts++;\n\n        emit CreatedERC20C(address(token), name, symbol, initialSupply, owner);\n\n        return address(token);\n    }\n\n}"
    },
    "contracts/L1/factory/L1ERC20D_TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n/* Contract Imports */\nimport { L1TokenFactory } from \"./L1TokenFactory.sol\";\nimport { ERC20D } from \"../tokens/ERC20D.sol\";\n\n/**\n * @title L1ERC20D_TokenFactory\n * @dev\n */\ncontract L1ERC20D_TokenFactory is L1TokenFactory {\n\n    event CreatedERC20D(address contractAddress, string name, string symbol, uint256 initialSupply, address owner);\n\n    function create(\n        string calldata name,\n        string calldata symbol,\n        uint256 initialSupply,\n        address owner\n    ) external override returns (address) {\n        require(owner != address(0), \"owner address is zero\");\n\n        require(bytes(name).length > 0, \"name is empty\");\n        require(bytes(symbol).length > 0, \"symbol is empty\");\n\n        ERC20D token = new ERC20D(name, symbol, initialSupply, owner);\n        require(address(token) != address(0), \"token zero\");\n\n        createdContracts[totalCreatedContracts] = ContractInfo(address(token), name, symbol);\n        totalCreatedContracts++;\n\n        emit CreatedERC20D(address(token), name, symbol, initialSupply, owner);\n\n        return address(token);\n    }\n\n}"
    },
    "contracts/L1/factory/L1TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IERC20Factory.sol\";\n\n/**\n * @title L1TokenFactory\n * @dev\n */\nabstract contract L1TokenFactory is IERC20Factory {\n\n    struct ContractInfo {\n        address contractAddress;\n        string name;\n        string symbol;\n    }\n\n    /// @dev Total number of contracts created\n    uint256 public totalCreatedContracts ;\n\n    /// @dev Contract information by index\n    mapping(uint256 => ContractInfo) public createdContracts;\n\n    /// @dev constructor of ERC20AFactory\n    constructor() {\n        totalCreatedContracts = 0;\n    }\n\n    function create(\n        string calldata name,\n        string calldata symbol,\n        uint256 initialSupply,\n        address owner\n    ) external override virtual returns (address);\n\n    /// @inheritdoc IERC20Factory\n    function lastestCreated() external view override returns (address contractAddress, string memory name, string memory symbol){\n        if(totalCreatedContracts > 0){\n            return (createdContracts[totalCreatedContracts-1].contractAddress, createdContracts[totalCreatedContracts-1].name, createdContracts[totalCreatedContracts-1].symbol );\n        }else {\n            return (address(0), '', '');\n        }\n    }\n\n    /// @inheritdoc IERC20Factory\n    function getContracts(uint256 _index) external view override returns (address contractAddress, string memory name, string memory symbol){\n        if(_index < totalCreatedContracts){\n            return (createdContracts[_index].contractAddress, createdContracts[_index].name, createdContracts[_index].symbol);\n        }else {\n            return (address(0), '', '');\n        }\n    }\n\n}"
    },
    "contracts/L1/interfaces/IERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IERC20Factory {\n\n    /// @dev Create a ERC20Factory\n    /// @param name name\n    /// @param symbol symbol\n    /// @param initialSupply initialSupply\n    /// @param owner  owner address\n    /// @return contract address\n    function create(\n        string calldata name,\n        string calldata symbol,\n        uint256 initialSupply,\n        address owner\n    ) external returns (address) ;\n\n    /// @dev Last generated contract information\n    function lastestCreated() external view returns (address contractAddress, string memory name, string memory symbol);\n\n    /// @dev Contract information stored in the index\n    function getContracts(uint256 _index) external view returns (address contractAddress, string memory name, string memory symbol);\n\n\n}\n"
    },
    "contracts/L1/interfaces/IERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface  IERC20Receiver {\n\n  function onERC20Received(address sender, address recipient, uint256 amount, bytes memory _data) external returns(bytes4);\n}"
    },
    "contracts/L1/interfaces/OnApprove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface OnApprove {\n  function onApprove(address owner, address spender, uint256 amount, bytes calldata data) external returns (bool);\n}"
    },
    "contracts/L1/L1ProjectManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\nimport \"./L1ProjectManagerStorage.sol\";\n\nimport { IERC20Factory } from \"./interfaces/IERC20Factory.sol\";\nimport { LibProject } from \"../libraries/LibProject.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n// import \"hardhat/console.sol\";\n\ninterface L2ProjectManagerI {\n    function distributesL2Token(\n        address l1Token,\n        address l2Token,\n        uint256 projectId,\n        uint256 totalAmount,\n        LibProject.TokamakVaults memory tokamakVaults,\n        LibProject.InitalParameterSchedule[] memory customScheduleVaults,\n        LibProject.InitalParameterNonScheduleVault[] memory customNonScheduleVaults\n    ) external;\n}\n\ninterface L1CrossDomainMessengerI {\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) external;\n}\n\ninterface L1BridgeI {\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n}\n\ninterface IIERC20 {\n    function mint(address account, uint256 amount) external;\n}\n\n/**\n * @title L1ProjectManager\n * @dev\n */\ncontract L1ProjectManager is ProxyStorage, AccessibleCommon, L1ProjectManagerStorage {\n    using SafeERC20 for IERC20;\n\n    event CreatedProject(\n        address l1Token,\n        uint256 projectId,\n        address tokenOwner,\n        address projectOwner,\n        address addressManager,\n        uint256 initialTotalSupply,\n        string projectName, string tokenName, string tokenSymbol);\n\n    event SetL2Token(uint256 projectId, uint8 l2Type, address addressManager, address l2Token);\n    event SetL2Infos(uint8 l2Type, address l2TokenFactory, address l2ProjectManager, uint32 depositMinGasLimit, uint32 sendMsgMinGasLimit);\n    event LaunchedProject(\n        uint256 projectId,\n        address l1Token,\n        address l2Token,\n        uint256 totalAmount);\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor() {\n    }\n\n    /* ========== onlyOwner ========== */\n\n    function setL2Infos(\n        uint8 l2Type,\n        address _l2TokenFactory,\n        address _l2ProjectManager,\n        uint32 _depositMinGasLimit,\n        uint32 _sendMsgMinGasLimit\n    )\n        external\n        nonZeroAddress(_l2TokenFactory) nonZeroAddress(_l2ProjectManager)\n        nonZero(_depositMinGasLimit) nonZero(_sendMsgMinGasLimit)\n        onlyOwner\n    {\n        require(l2Type < uint8(LibProject.L2_TYPE.NONE), \"unsupported l2Type\");\n        require(\n            l2Info[l2Type].l2TokenFactory != _l2TokenFactory\n            || l2Info[l2Type].l2ProjectManager != _l2ProjectManager\n            || l2Info[l2Type].depositMinGasLimit != _depositMinGasLimit\n            || l2Info[l2Type].sendMsgMinGasLimit != _sendMsgMinGasLimit , \"same\");\n\n        LibProject.L2Info memory info = LibProject.L2Info({\n                l2TokenFactory: _l2TokenFactory,\n                l2ProjectManager: _l2ProjectManager,\n                depositMinGasLimit: _depositMinGasLimit,\n                sendMsgMinGasLimit: _sendMsgMinGasLimit\n        });\n\n        l2Info[l2Type] = info;\n\n        emit SetL2Infos(l2Type, _l2TokenFactory, _l2ProjectManager, _depositMinGasLimit, _sendMsgMinGasLimit);\n    }\n\n    function setL1TokenFactories(uint8[] memory tokenTypes, address[] memory _l1TokenFactorys)\n        external onlyOwner\n    {\n        require(tokenTypes.length != 0 && tokenTypes.length == _l1TokenFactorys.length, \"wrong length\");\n        uint256 len = tokenTypes.length;\n\n        for (uint256 i = 0; i < len; i++){\n            require(tokenTypes[i] < uint8(LibProject.TOKEN_TYPE.NONE), \"unsupported token type\");\n            require(l1TokenFactory[tokenTypes[i]] != _l1TokenFactorys[i], \"same address\");\n            l1TokenFactory[tokenTypes[i]] = _l1TokenFactorys[i];\n        }\n    }\n\n    /* ========== Only ProjectOwner ========== */\n\n    /// @dev 프로젝트 생성\n    function createProject(\n        address tokenOwner,\n        address projectOwner,\n        address addressManager,\n        uint256 initialTotalSupply,\n        uint8 tokenType,\n        string memory projectName,\n        string memory tokenName,\n        string memory tokenSymbol\n    )\n        external\n        returns (uint256)\n    {\n        require(tokenOwner != address(0) && projectOwner != address(0) && addressManager != address(0),\n            \"zero address\");\n        require(bytes(projectName).length != 0, \"projectName is null\");\n        require(bytes(tokenName).length != 0, \"tokenName is null\");\n        require(bytes(tokenSymbol).length != 0, \"tokenSymbol is null\");\n        require(tokenType < uint8(LibProject.TOKEN_TYPE.NONE)\n            && address(l1TokenFactory[tokenType]) != address(0), \"wrong tokenType or zero l1TokenFactory\");\n\n        address projectToken = IERC20Factory(l1TokenFactory[tokenType]).create(\n            tokenName, tokenSymbol, initialTotalSupply, address(this)\n        );\n\n        require(projectToken != address(0), \"zero projectToken\");\n        uint256 projectId = ++projectCount;\n        // address _tokenOwner = tokenOwner;\n\n        projects[projectId] = LibProject.ProjectInfo({\n            projectOwner: projectOwner,\n            tokenOwner : tokenOwner,\n            l1Token : projectToken,\n            l2Token : address(0),\n            addressManager : addressManager,\n            initialTotalSupply : initialTotalSupply,\n            tokenType : tokenType,\n            l2Type : uint8(0),\n            projectName : projectName\n        });\n\n        projectTokens[projectToken] = projectId;\n\n        emit CreatedProject(\n            projectToken, projectId, tokenOwner, projectOwner, addressManager, initialTotalSupply,\n            projectName,  tokenName, tokenSymbol );\n        return projectId;\n    }\n\n    function launchProject(\n        uint256 projectId,\n        address l2Token,\n        uint256 totalAmount,\n        LibProject.TokamakVaults memory tokamakVaults,\n        LibProject.InitalParameterSchedule[] memory customScheduleVaults,\n        LibProject.InitalParameterNonScheduleVault[] memory customNonScheduleVaults\n    )\n        external nonZeroAddress(l2Token) nonZero(totalAmount)\n    {\n\n        LibProject.ProjectInfo memory info = projects[projectId];\n        require(info.projectOwner != address(0) && msg.sender == info.projectOwner, \"caller is not projectOwner.\");\n        require(info.l2Token == address(0), \"already launched\");\n        require(projectTokens[info.l1Token] == projectId, \"wrong l1Token\");\n\n        address l1Messenger = LibProject.getL1CommunicationMessenger(info.addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n        bytes memory  callData = abi.encodeWithSelector(\n                    L2ProjectManagerI.distributesL2Token.selector,\n                    info.l1Token,\n                    l2Token,\n                    projectId,\n                    totalAmount,\n                    tokamakVaults,\n                    customScheduleVaults,\n                    customNonScheduleVaults\n                ) ;\n        uint256 totalAllocatedAmount = 0;\n\n        // 입력 데이타 검증\n        (bool boolValidateTokamakVaults, uint256 tokamakVaultsTotalAmount) = LibProject.validateTokamakVaults(tokamakVaults);\n        require(boolValidateTokamakVaults, \"TokamakVaults vaildate fail\");\n        totalAllocatedAmount += tokamakVaultsTotalAmount;\n\n        if(customScheduleVaults.length != 0){\n            (bool boolValidateCustom1, uint256 custom1TotalAmount) = LibProject.validateScheduleVault(customScheduleVaults);\n            require(boolValidateCustom1, \"customScheduleVaults vaildate fail\");\n            totalAllocatedAmount += custom1TotalAmount;\n        }\n\n        if(customScheduleVaults.length != 0){\n            (bool boolValidateCustom2, uint256 custom2TotalAmount) = LibProject.validateNonScheduleVault(customNonScheduleVaults);\n            require(boolValidateCustom2, \"customNonScheduleVaults vaildate fail\");\n            totalAllocatedAmount += custom2TotalAmount;\n        }\n        require(totalAllocatedAmount == totalAmount, \"totalAmount is different from vaults allocated amount\");\n\n        uint256 id = projectId;\n\n        // 1. L2토큰 정보를 저장한다.\n        projects[id].l2Token = l2Token;\n        info.l2Token = l2Token;\n        // LibProject.TokamakVaults memory tVaults = tokamakVaults;\n        // bytes memory  callData = abi.encodeWithSelector(\n        //             L2ProjectManagerI.distributesL2Token.selector,\n        //             info.l1Token,\n        //             info.l2Token,\n        //             id,\n        //             totalAllocatedAmount,\n        //             tokamakVaults,\n        //             customScheduleVaults,\n        //             customNonScheduleVaults\n        //         ) ;\n\n        uint256 balance = IERC20(projects[id].l1Token).balanceOf(address(this));\n\n        // 2. L1 토큰 발행하고,\n        if (balance <= info.initialTotalSupply && info.tokenType != 0) {\n            IIERC20(info.l1Token).mint(address(this), info.initialTotalSupply - balance);\n            balance = IERC20(projects[id].l1Token).balanceOf(address(this));\n        }\n\n        require(balance >= info.initialTotalSupply, \"balance is insufficient\");\n\n        LibProject.L2Info memory _l2Info = l2Info[info.l2Type];\n\n        // 3. L2로 디파짓 한다.\n        _depositL1TokenToL2(\n            address(this),\n            info.addressManager,\n            info.l1Token,\n            info.l2Token,\n            _l2Info.l2ProjectManager,\n            info.initialTotalSupply,\n            _l2Info.depositMinGasLimit,\n            abi.encode(id)\n        );\n        // bytes memory callData = abi.encodeWithSelector(L2ProjectManagerI.distributesL2Token.selector, functionParams);\n\n        // 4. 커스텀 배포정보를 L2에 보낸다.\n        L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                _l2Info.l2ProjectManager,\n                callData,\n                _l2Info.sendMsgMinGasLimit\n            );\n\n        emit LaunchedProject(id, info.l1Token, info.l2Token, info.initialTotalSupply);\n    }\n\n    /* ========== VIEW ========== */\n    function viewL2Info(uint8 _l2Type) external view returns (LibProject.L2Info memory) {\n        return l2Info[_l2Type];\n    }\n\n\n    /* === ======= internal ========== */\n    function _depositL1TokenToL2(\n        address sender,\n        address addressManager, address l1Token, address l2Token, address depositTo,\n        uint256 amount, uint32 _minGasLimit, bytes memory data)\n        internal\n    {\n        address l1Bridge = LibProject.getL1Bridge(addressManager);\n        require(l1Bridge != address(0), \"l1Bridge is ZeroAddress\");\n\n        uint256 allowance = IERC20(l1Token).allowance(address(this), l1Bridge);\n\n        if (allowance < amount) IERC20(l1Token).approve(l1Bridge, type(uint256).max);\n\n        L1BridgeI(l1Bridge).depositERC20To(\n            l1Token,\n            l2Token,\n            depositTo,\n            amount,\n            _minGasLimit,\n            data\n        );\n    }\n}"
    },
    "contracts/L1/L1ProjectManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/Proxy.sol\";\nimport \"./L1ProjectManagerStorage.sol\";\n\n\n/**\n * @title L1ProjectManagerProxy\n * @dev\n */\ncontract L1ProjectManagerProxy is Proxy, L1ProjectManagerStorage {\n\n}"
    },
    "contracts/L1/L1ProjectManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport { LibProject } from \"../libraries/LibProject.sol\";\n\n/**\n * @title L1ProjectManagerStorage\n * @dev\n */\ncontract L1ProjectManagerStorage {\n\n    bool internal free = true;\n\n    uint256 public projectCount;\n\n    // TOKEN_TYPE - l1TokenFactory\n    mapping(uint8 => address) public l1TokenFactory;\n\n    // projectIndex - ProjectInfo\n    mapping(uint256 => LibProject.ProjectInfo) public projects;\n\n    // l1TokenAddress - projectIndex\n    mapping(address => uint256) public projectTokens;\n\n    // l2type - l2TokenFactory\n    mapping(uint8 => LibProject.L2Info) public l2Info;\n\n\n    modifier onlyProjectOwner(uint256 projectid) {\n        require(projects[projectid].projectOwner != address(0) &&\n            msg.sender == projects[projectid].projectOwner, \"caller is not projectOwner.\");\n        _;\n    }\n\n    modifier nonZero(uint256 value) {\n        require(value != 0, \"Z1\");\n        _;\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"Z2\");\n        _;\n    }\n\n    modifier ifFree {\n        require(free, \"lock\");\n        free = false;\n        _;\n        free = true;\n    }\n\n}"
    },
    "contracts/L1/L1StosToL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { LibProject } from \"../libraries/LibProject.sol\";\nimport \"../libraries/LibLockTOS.sol\";\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./L1StosToL2Storage.sol\";\nimport \"hardhat/console.sol\";\n\ninterface ILockTos {\n    function locksInfo(uint256 _lockId)\n            external\n            view\n            returns (\n                uint256 start,\n                uint256 end,\n                uint256 amount\n            );\n\n    function locksOf(address _addr)\n        external\n        view\n        returns (uint256[] memory);\n\n    function pointHistoryOf(uint256 _lockId)\n        external\n        view\n        returns (LibLockTOS.Point[] memory);\n\n}\n\ninterface IL1StosInL2 {\n    function register(bytes memory data) external ;\n}\n\ninterface L1CrossDomainMessengerI {\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) external;\n}\n\n\ncontract L1StosToL2 is ProxyStorage2, L1StosToL2Storage {\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor (\n        address managerAddress,\n        address lockTosAddress,\n        address addressManagerAddress,\n        uint256 maxLockCountPerRegister_,\n        uint32 minGasLimitRegister_\n    ) {\n        _manager = managerAddress;\n        lockTos = lockTosAddress;\n        addressManager = addressManagerAddress;\n        maxLockCountPerRegister = maxLockCountPerRegister_;\n        minGasLimitRegister = minGasLimitRegister_;\n    }\n\n    function setL2Register(address l2Register_) external onlyManager {\n        require(l2Register != l2Register_, \"same\");\n        l2Register = l2Register_;\n    }\n\n    /* ========== Anybody can ========== */\n\n    function register(address account) public {\n        uint256[] memory lockIds = ILockTos(lockTos).locksOf(account);\n        // console.log(\"register %s\", account);\n        // console.log(\"lockIds.length %s\", lockIds.length);\n        require(lockIds.length != 0, \"no register data\");\n        require(lockIds.length <= maxLockCountPerRegister, \"exceeded the maximum number of register.\");\n        _register(account, lockIds);\n    }\n\n    function register(address account, uint256[] memory lockIds) public {\n        require(lockIds.length <= maxLockCountPerRegister, \"exceeded the maximum number of register.\");\n        require(lockIds.length != 0, \"no register data\");\n        uint256[] memory userLockIds = ILockTos(lockTos).locksOf(account);\n\n        for(uint256 i = 0; i < lockIds.length; i++){\n            bool unMatched = true;\n            for(uint256 j = 0; j < userLockIds.length; j++){\n                if(lockIds[i] == userLockIds[j]) {\n                    unMatched = false;\n                    if(j < userLockIds.length-1)\n                        userLockIds[j] = userLockIds[userLockIds.length-1];\n                    delete userLockIds[userLockIds.length-1];\n                    break;\n                }\n            }\n            require(!unMatched, \"owner is not account\");\n        }\n\n        _register(account, lockIds);\n    }\n\n    /* ========== VIEW ========== */\n\n    function needSyncList(address account) public view returns (uint256[] memory lockIds) {\n        uint256[] memory ids = ILockTos(lockTos).locksOf(account);\n\n        for(uint256 i = 0; i < ids.length; i++){\n            LibLockId.SyncInfo memory curSync = syncInfoOfLockId[ids[i]];\n            (, uint256 end, uint256 amount) = ILockTos(lockTos).locksInfo(ids[i]);\n            if(amount != 0 && block.timestamp < end) {\n                LibLockTOS.Point[] memory history = ILockTos(lockTos).pointHistoryOf(ids[i]);\n                if(history.length != 0){\n                    LibLockTOS.Point memory point = history[history.length-1];\n                    if(curSync.timestamp < point.timestamp) lockIds[lockIds.length-1] = ids[i];\n                }\n            }\n        }\n    }\n\n    function viewRegisterInfoOfLockId(uint256 lockId) external view returns(LibLockId.SyncInfo memory) {\n        return syncInfoOfLockId[lockId];\n    }\n\n    /* === ======= internal ========== */\n\n    function _register(address account, uint256[] memory lockIds) internal {\n\n        bytes memory syncPackets ;\n        uint256 syncIdsCount ;\n\n        // packet {address: count to sync: 1st sync packet: 2nd sync packet: .....}\n        // address : 20 bytes\n        // count to sync : 1 byte (max 256 sync packets) but it is less than maxLockCountPerSync\n        // sync packets : count to sync * 104 bytes ( count * 104 )\n        // one sync packets : 104 bytes:  (32 byte) uint256 lockId, (32+32+4+4) syncInfo -> total 104\n\n        for(uint256 i = 0; i < lockIds.length; i++){\n\n            LibLockId.SyncInfo memory curSync = syncInfoOfLockId[lockIds[i]];\n\n            (, uint256 end, uint256 amount) = ILockTos(lockTos).locksInfo(lockIds[i]);\n\n            if (amount != 0 && block.timestamp < end){\n                LibLockTOS.Point[] memory history = ILockTos(lockTos).pointHistoryOf(lockIds[i]);\n\n                if(history.length != 0){\n                    LibLockTOS.Point memory point = history[history.length-1];\n\n                    if(curSync.timestamp < point.timestamp) {\n                        LibLockId.SyncInfo memory newSync = LibLockId.SyncInfo(\n                            {\n                                slope: point.slope,\n                                bias: point.bias,\n                                timestamp: uint32(point.timestamp),\n                                syncTime: uint32(block.timestamp)\n                            }\n                        );\n\n                        syncInfoOfLockId[lockIds[i]] = newSync;\n                        syncIdsCount++;\n\n                        syncPackets = bytes.concat(syncPackets,\n                            abi.encodePacked(lockIds[i], newSync.slope, newSync.bias, newSync.timestamp, newSync.syncTime));\n\n                    }\n                }\n            }\n        }\n\n        require(syncPackets.length > 0, \"no register data\");\n        // console.log('_register syncPackets.length  %s', syncPackets.length);\n\n        _sendMessage(\n            l2Register,\n            abi.encodePacked(account, syncPackets),\n            // bytes.concat(abi.encodePacked(account), syncPackets),\n            minGasLimitRegister\n            );\n    }\n\n\n    function _sendMessage(address target, bytes memory data, uint32 minGasLimit) internal {\n        address l1Messenger = LibProject.getL1CommunicationMessenger(addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n\n        bytes memory callData = abi.encodeWithSelector(IL1StosInL2.register.selector, data);\n\n        // console.log('_sendMessage target %s', target, ' data.length %s', data.length);\n        // console.logBytes(data);\n        // console.log('_sendMessage l1Messenger %s', l1Messenger);\n\n        L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                target,\n                callData,\n                minGasLimit\n            );\n    }\n\n}"
    },
    "contracts/L1/L1StosToL2Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../proxy/Proxy2.sol\";\nimport \"./L1StosToL2Storage.sol\";\n\ncontract L1StosToL2Proxy is Proxy2, L1StosToL2Storage\n{\n    event ManagershipTransferred(address indexed previousManager, address indexed newManager);\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (\n        address managerAddress,\n        address lockTosAddress,\n        address addressManagerAddress,\n        uint256 maxLockCountPerRegister_,\n        uint32 minGasLimitRegister_\n    ) {\n        _manager = managerAddress;\n        lockTos = lockTosAddress;\n        addressManager = addressManagerAddress;\n        maxLockCountPerRegister = maxLockCountPerRegister_;\n        minGasLimitRegister = minGasLimitRegister_;\n    }\n\n    function setMaxLockCountPerRegister(uint256 maxLockCountPerRegister_) external onlyManager {\n        require(maxLockCountPerRegister != maxLockCountPerRegister_, \"same\");\n        maxLockCountPerRegister = maxLockCountPerRegister_;\n    }\n\n\n    function setLockTos(address lockTosAddress) external onlyManager {\n        require(lockTos != lockTosAddress, \"same\");\n        lockTos = lockTosAddress;\n    }\n\n    function setL2Register(address l2Register_) external onlyManager {\n        require(l2Register != l2Register_, \"same\");\n        l2Register = l2Register_;\n    }\n\n    function setAddressManager(address addressManagerAddress) external onlyManager {\n        require(addressManager != addressManagerAddress, \"same\");\n        addressManager = addressManagerAddress;\n    }\n\n    function renounceManagership() external onlyManager {\n        emit ManagershipTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    function transferManagership(address newManager) external onlyManager {\n        require(newManager != address(0), \"new manager is the zero address\");\n        emit ManagershipTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n\n}\n"
    },
    "contracts/L1/L1StosToL2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/LibLockId.sol\";\n\ncontract L1StosToL2Storage  {\n    uint256 public maxLockCountPerRegister;\n    address public _manager;\n    address public addressManager;\n    address public lockTos;\n    address public l2Register;\n    uint32 minGasLimitRegister;\n\n    // account-lockId-sync된 정보 (히스토리의 인덱스 번호, time)\n    mapping(uint256 => LibLockId.SyncInfo) public syncInfoOfLockId;\n    bool internal _lock;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier ifFree {\n        require(_lock != true, \"in use\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n}\n"
    },
    "contracts/L1/L1toL2Message.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { LibProject } from \"../libraries/LibProject.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport \"../libraries/BytesLib.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { OnApprove } from \"./interfaces/OnApprove.sol\";\n\n// import \"hardhat/console.sol\";\n\ninterface L1CrossDomainMessengerI {\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) external;\n}\n\ninterface L1BridgeI {\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n}\n\n/**\n * @title L1toL2Message\n * @dev\n */\ncontract L1toL2Message is ERC165Storage{\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    /* ========== DEPENDENCIES ========== */\n\n    struct CallMessage {\n        address target;\n        bytes message;\n        uint32 minGasLimit;\n    }\n\n    struct DepositMessage {\n        address l1Token;\n        address l2Token;\n        DepositTo[] depositTos;\n    }\n\n    struct DepositTo {\n        address to;\n        uint256 amount;\n        uint32 minGasLimit;\n    }\n\n    modifier nonZero(uint256 value) {\n        require(value != 0, \"Z1\");\n        _;\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"Z2\");\n        _;\n    }\n\n    constructor() {\n        _registerInterface(OnApprove(address(this)).onApprove.selector);\n    }\n\n    /*\n    function onApprove(\n        address sender,\n        address spender,\n        uint256 amount,\n        bytes calldata data\n    ) public returns (bool) {\n\n        // data :\n        // 20 bytes addressManager,\n        // 20 bytes l1Token,\n        // 20 bytes  l2Token,\n        // 20 bytes depositAndCallTarget,\n        // 4 bytes minGasLimitForDeposit\n        // 4 bytes minGasLimitForCall\n        // 나머지 bytes call\n\n        require(data.length > 88, 'wrong data');\n        // console.log(\"data.length %s\", data.length);\n\n        address addressManager = data.toAddress(0);\n        address depositAndCallTarget = data.toAddress(60);\n        uint256 amount1 = amount;\n\n        address l1Token = data.toAddress(20);\n        address l2Token = data.toAddress(40);\n        uint32  minGasLimitForDeposit = data.toUint32(80);\n        uint32  minGasLimitForCall = data.toUint32(84);\n        bytes memory callData = data.slice(88, (data.length-88));\n\n        // console.log(\"addressManager %s\", addressManager);\n        // console.log(\"l1Token %s\", l1Token);\n        // console.log(\"l2Token %s\", l2Token);\n        // console.log(\"depositAndCallTarget %s\", depositAndCallTarget);\n        // console.log(\"amount %s\", amount);\n        // console.log(\"minGasLimitForDeposit %s\", minGasLimitForDeposit);\n        // console.log(\"minGasLimitForCall %s\", minGasLimitForCall);\n        // console.logBytes(data.slice(88, data.length-1));\n\n        address l1Messenger = LibProject.getL1CommunicationMessenger(addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n\n        _depositL1TokenToL2(\n            sender,\n            addressManager,\n            l1Token,\n            l2Token,\n            depositAndCallTarget,\n            amount1,\n            minGasLimitForDeposit\n        );\n\n        L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                depositAndCallTarget,\n                callData,\n                minGasLimitForCall\n            );\n\n        return true;\n    }\n    */\n\n    function depositAndCall(\n        address addressManager, address l1Token, address l2Token, address depositAndCallTarget,\n        uint256 amount,\n        uint32 minGasLimitForDeposit,\n        uint32 minGasLimitForCall, bytes memory callData\n    )\n        external\n    {\n        address l1Messenger = LibProject.getL1CommunicationMessenger(addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n\n        _depositL1TokenToL2(msg.sender, addressManager, l1Token, l2Token, depositAndCallTarget, amount, minGasLimitForDeposit);\n\n        L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                depositAndCallTarget,\n                callData,\n                minGasLimitForCall\n            );\n    }\n\n    function depositsAndMessages(\n        address addressManager,\n        DepositMessage[] memory depositMassages,\n        CallMessage[] memory callMessages\n    )\n        external\n    {\n        _deposits(msg.sender, addressManager, depositMassages);\n        l2SendMessage(addressManager, callMessages);\n    }\n\n    function l2SendMessage(\n            address addressManager,\n            CallMessage[] memory callMessages\n        )\n        public\n    {\n        address l1Messenger = LibProject.getL1CommunicationMessenger(addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n        require(callMessages.length != 0, 'zero call message');\n\n        uint256 len = callMessages.length ;\n        for(uint256 i = 0; i < len ; i++){\n            require(callMessages[i].target != address(0)\n                && callMessages[i].message.length != 0\n                && callMessages[i].minGasLimit != 0, 'invalid message');\n        }\n\n        for(uint256 i = 0; i < len ; i++){\n            L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                callMessages[i].target,\n                callMessages[i].message,\n                callMessages[i].minGasLimit\n            );\n        }\n    }\n\n    function depositL1TokenToL2(\n        address addressManager, address l1Token, address l2Token, address depositTo,\n        uint256 amount, uint32 _minGasLimit )\n        public\n    {\n        _depositL1TokenToL2(msg.sender, addressManager, l1Token, l2Token, depositTo, amount, _minGasLimit);\n    }\n\n    function deposits(\n        address addressManager, DepositMessage[] memory depositMessages)\n        public nonZeroAddress(addressManager)\n    {\n        _deposits(msg.sender, addressManager, depositMessages);\n    }\n\n    function depositToMany(\n        address addressManager, address l1Token, address l2Token, DepositTo[] memory depositTos )\n        public\n    {\n        _depositToMany(msg.sender, addressManager,  l1Token,  l2Token, depositTos);\n    }\n\n\n    function _depositL1TokenToL2(\n        address sender,\n        address addressManager, address l1Token, address l2Token, address depositTo,\n        uint256 amount, uint32 _minGasLimit )\n        internal\n    {\n        address l1Bridge = LibProject.getL1Bridge(addressManager);\n        require(l1Bridge != address(0), \"l1Bridge is ZeroAddress\");\n\n        require(IERC20(l1Token).balanceOf(sender) >= amount, \"l1Token balance is insufficient\");\n        require(IERC20(l1Token).allowance(sender, address(this)) >= amount, \"l1Token allowance is insufficient\");\n\n        uint256 allowance = IERC20(l1Token).allowance(address(this), l1Bridge);\n\n        if (allowance < amount) {\n            IERC20(l1Token).approve(l1Bridge, type(uint256).max);\n        }\n\n        IERC20(l1Token).safeTransferFrom(sender, address(this), amount);\n\n        L1BridgeI(l1Bridge).depositERC20To(\n            l1Token,\n            l2Token,\n            depositTo,\n            amount,\n            _minGasLimit,\n            abi.encode(l1Token, l2Token, depositTo, amount)\n        );\n    }\n\n    function _deposits(\n        address sender, address addressManager, DepositMessage[] memory depositMessages)\n        internal\n    {\n        require(depositMessages.length != 0, 'zero depositMessages');\n\n        uint256 len = depositMessages.length;\n        for(uint256 i = 0; i < len ; i++){\n            require(\n                depositMessages[i].l1Token != address(0) &&\n                depositMessages[i].l2Token != address(0) &&\n                depositMessages[i].depositTos.length != 0, \"invalid depositMessages\");\n        }\n\n        for(uint256 i = 0; i < len ; i++){\n            _depositToMany(\n                sender,\n                addressManager,\n                depositMessages[i].l1Token,\n                depositMessages[i].l2Token,\n                depositMessages[i].depositTos );\n        }\n    }\n\n    function _depositToMany(\n        address sender, address addressManager, address l1Token, address l2Token, DepositTo[] memory depositTos )\n        internal\n    {\n        address l1Bridge = LibProject.getL1Bridge(addressManager);\n        require(l1Bridge != address(0), \"l1Bridge is ZeroAddress\");\n\n        require(depositTos.length != 0, \"zero depositTo\");\n\n        uint256 len = depositTos.length;\n        uint256 sumAmount = 0;\n        for(uint256 i = 0; i < len ; i++){\n            require(\n                depositTos[i].to != address(0) &&\n                depositTos[i].amount != 0 && depositTos[i].minGasLimit != 0, \"invalid depositTos\");\n            sumAmount += depositTos[i].amount;\n        }\n\n        require(IERC20(l1Token).balanceOf(sender) >= sumAmount, \"l1Token balance is insufficient\");\n        require(IERC20(l1Token).allowance(sender, address(this)) >= sumAmount, \"l1Token allowance is insufficient\");\n\n        uint256 allowance = IERC20(l1Token).allowance(address(this), l1Bridge);\n\n        if (allowance < sumAmount) {\n            IERC20(l1Token).approve(l1Bridge, type(uint256).max);\n        }\n\n        IERC20(l1Token).safeTransferFrom(sender, address(this), sumAmount);\n        for(uint256 i = 0; i < len ; i++){\n            L1BridgeI(l1Bridge).depositERC20To(\n                l1Token,\n                l2Token,\n                depositTos[i].to,\n                depositTos[i].amount,\n                depositTos[i].minGasLimit,\n                abi.encode(l1Token, l2Token, depositTos[i].to, depositTos[i].amount)\n            );\n        }\n    }\n\n}"
    },
    "contracts/L1/L1TotalStos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\nimport \"./L1TotalStosStorage.sol\";\n\n\n/**\n * @title L1TotalStos\n * @dev\n */\ncontract L1TotalStos is ProxyStorage, AccessibleCommon, L1TotalStosStorage {\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor() {\n    }\n\n    /* ========== onlyOwner ========== */\n\n\n    /* ========== Anybody can ========== */\n\n\n    /* ========== VIEW ========== */\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L1/L1TotalStosProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/Proxy.sol\";\nimport \"./L1TotalStosStorage.sol\";\n\n\n/**\n * @title L1TotalStosProxy\n * @dev\n */\ncontract L1TotalStosProxy is Proxy, L1TotalStosStorage {\n\n}"
    },
    "contracts/L1/L1TotalStosStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { LibStos } from \"../libraries/LibStos.sol\";\nimport { LibLockTOS } from \"../libraries/LibLockTOS.sol\";\n\n/**\n * @title L1TotalStosStorage\n * @dev\n */\ncontract L1TotalStosStorage {\n\n    uint256 public l2TotalCount;\n\n    // l2chainId - l2Info\n    mapping(uint256 => LibStos.L2Info) public l2Infos;\n\n    // user - l2chainId - StosInfo\n    mapping(address => mapping(uint256 => LibStos.StosInfo)) public userStos;\n\n\n    /// chainId - [Points]: 모든 추가/수정에 대해 포인트를 저장함.\n    mapping(uint256 => LibLockTOS.Point[]) public pointHistory;\n\n    // chainId - lockId - [Points] : 락아이디는 수정할때마다 point 가 늘어남.\n    mapping(uint256 => mapping(uint256 => LibLockTOS.Point[])) public lockPointHistory;\n\n\n    // 특정시간 의 slop 을 저장. 기존의 slop과 변경된 slop 반영 (point)\n    // chainId - time - slop\n    mapping(uint256 => mapping(uint256 =>int256)) public slopeChanges;\n\n\n    //-------------------\n\n    // 모든 락아이디 정보, chainId-LockIds-lockInfo\n    mapping(uint256 => mapping(uint256 => LibLockTOS.LockedBalance)) public allLocks;\n\n    // 사용자의 모든 락 아이디 , 사용자-chainId- LockIds - 락아이디 정보\n    // mapping(address => mapping(uint256 => LibLockTOS.LockedBalance)) public lockedBalances;\n\n    // 사용자의 모든 락 아이디 , 사용자-chainId-[ LockIds ]\n    mapping(address => mapping(uint256 => uint256[])) public userLocks;\n\n    // chainId - 락아이디 개수\n    mapping(uint256 => uint256) public lockIdCounter;\n}"
    },
    "contracts/L1/tokens/ERC165A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\n\ncontract ERC165A  {\n\n     /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('transfer(address,uint256)')) == 0xa9059cbb\n     *     bytes4(keccak256('allowance(address,address)')) == 0xdd62ed3e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256(\"safeTransfer(address,uint256)\")) == 0x423f6cef\n     *     bytes4(keccak256(\"safeTransfer(address,uint256,bytes)\")) == 0xeb795549\n     *     bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\")) == 0x42842e0e\n     *     bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")) == 0xb88d4fde\n     *\n     *     => 0x18160ddd ^ 0x70a08231 ^ 0xa9059cbb ^ 0xdd62ed3e ^ 0x095ea7b3 ^ 0x23b872dd ^ 0x423f6cef ^ 0xeb795549 ^ 0x42842e0e ^ 0xb88d4fde == 0x65787371\n     */\n    bytes4 public constant _INTERFACE_ID_ERC20 = 0x65787371;\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    mapping(bytes4 => bool) public _supportedInterfaces;\n\n    constructor() {\n        _registerInterface(_INTERFACE_ID_ERC20);\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n\n\n}"
    },
    "contracts/L1/tokens/ERC20A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./ERC165A.sol\";\nimport \"./ERC20ApproveAndCall.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract ERC20A is ERC20, ERC165A, ERC20ApproveAndCall {\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 initialSupply,\n        address to\n    ) ERC20(_name, _symbol) ERC165A() {\n\n        if (initialSupply != 0) _mint(to, initialSupply);\n\n        _registerInterface(ERC20_RECEIVED);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n    * @dev  Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount) public {\n        safeTransfer(recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount, bytes memory data) public {\n        transfer(recipient, amount);\n        require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount) public {\n        safeTransferFrom(sender, recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount, bytes memory data) public {\n        transferFrom(sender, recipient, amount);\n        require(_checkOnERC20Received(sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n\n    function approveAndCall(address spender, uint256 amount, bytes memory data) public returns (bool) {\n        require(approve(spender, amount));\n        _callOnApprove(msg.sender, spender, amount, data);\n        return true;\n    }\n\n}\n\n"
    },
    "contracts/L1/tokens/ERC20ApproveAndCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport { OnApprove } from \"../interfaces/OnApprove.sol\";\nimport { IERC20Receiver } from \"../interfaces/IERC20Receiver.sol\";\n\nabstract contract ERC20ApproveAndCall  {\n    using Address  for address;\n\n    /**\n    * @dev Magic value to be returned upon successful reception of an NFT\n    *  Equals to `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`,\n    *  which can be also obtained as `ERC20Receiver(0).onERC20Received.selector`\n    */\n    bytes4 constant ERC20_RECEIVED = 0x4fc35859;\n\n    function _callOnApprove(address owner, address spender, uint256 amount, bytes memory data) internal {\n        bytes4 onApproveSelector = OnApprove(spender).onApprove.selector;\n\n        require(ERC165Checker.supportsInterface(spender, onApproveSelector),\"approveAndCall: spender doesn't support onApprove\");\n\n        (bool ok, bytes memory res) = spender.call(\n            abi.encodeWithSelector(\n                onApproveSelector,\n                owner,\n                spender,\n                amount,\n                data\n            )\n        );\n\n        // check if low-level call reverted or not\n        require(ok, string(res));\n\n        assembly {\n            ok := mload(add(res, 0x20))\n        }\n\n        // check if OnApprove.onApprove returns true or false\n        require(ok, \"approveAndCall: failed to call onApprove\");\n    }\n\n     /**\n     * @dev Internal function to invoke `onERC20Received` on a target address.\n     * The call is not executed if the target address is not a contract.\n     */\n    function _checkOnERC20Received(address sender, address recipient, uint256 amount, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!recipient.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC20Receiver(recipient).onERC20Received(msg.sender, sender, amount, _data);\n\n        return (retval == ERC20_RECEIVED);\n    }\n\n}"
    },
    "contracts/L1/tokens/ERC20B.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./ERC165A.sol\";\nimport \"./ERC20ApproveAndCall.sol\";\n\n//import \"hardhat/console.sol\";\n\ncontract ERC20B is AccessControl, ERC20, ERC165A, ERC20ApproveAndCall {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 initialSupply,\n        address _owner\n    ) ERC20(_name, _symbol) ERC165A() {\n        if (initialSupply != 0) _mint(_owner, initialSupply);\n\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setupRole(MINTER_ROLE, _owner);\n\n        _registerInterface(ERC20_RECEIVED);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId] || super.supportsInterface(interfaceId);\n    }\n\n    function mint(address account, uint256 amount)\n        external\n        onlyRole(MINTER_ROLE)\n        returns (bool)\n    {\n        _mint(account,amount);\n        return true;\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n    * @dev  Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount) public {\n        safeTransfer(recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount, bytes memory data) public {\n        transfer(recipient, amount);\n        require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount) public {\n        safeTransferFrom(sender, recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount, bytes memory data) public {\n        transferFrom(sender, recipient, amount);\n        require(_checkOnERC20Received(sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n\n    function approveAndCall(address spender, uint256 amount, bytes memory data) public returns (bool) {\n        require(approve(spender, amount));\n        _callOnApprove(msg.sender, spender, amount, data);\n        return true;\n    }\n\n}\n\n"
    },
    "contracts/L1/tokens/ERC20C.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./ERC165A.sol\";\nimport \"./ERC20ApproveAndCall.sol\";\nimport \"./ERC20Snapshot.sol\";\n//import \"hardhat/console.sol\";\n\ncontract ERC20C is AccessControl, ERC20, ERC165A, ERC20ApproveAndCall, ERC20Snapshot {\n    bytes32 public constant SNAPSHOT_ROLE = keccak256(\"SNAPSHOT_ROLE\");\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 initialSupply,\n        address _owner\n    ) ERC20(_name, _symbol) ERC165A() {\n        if (initialSupply != 0) _mint(_owner, initialSupply);\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setupRole(SNAPSHOT_ROLE, _owner);\n        _registerInterface(ERC20_RECEIVED);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId] || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n    * @dev  Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount) public {\n        safeTransfer(recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount, bytes memory data) public {\n        transfer(recipient, amount);\n        require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount) public {\n        safeTransferFrom(sender, recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount, bytes memory data) public {\n        transferFrom(sender, recipient, amount);\n        require(_checkOnERC20Received(sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n\n    function approveAndCall(address spender, uint256 amount, bytes memory data) public returns (bool) {\n        require(approve(spender, amount));\n        _callOnApprove(msg.sender, spender, amount, data);\n        return true;\n    }\n\n    function snapshot() public onlyRole(SNAPSHOT_ROLE) returns (uint256) {\n        return _snapshot();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _balanceOfAt(account, snapshotId);\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _totalSupplyAt(snapshotId);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(getAccountBalanceSnapshots(account), balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(getTotalSupplySnapshots(), totalSupply());\n    }\n\n}\n\n"
    },
    "contracts/L1/tokens/ERC20D.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./ERC165A.sol\";\nimport \"./ERC20ApproveAndCall.sol\";\nimport \"./ERC20Snapshot.sol\";\n//import \"hardhat/console.sol\";\n\ncontract ERC20D is AccessControl, ERC20, ERC165A, ERC20ApproveAndCall, ERC20Snapshot {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant SNAPSHOT_ROLE = keccak256(\"SNAPSHOT_ROLE\");\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 initialSupply,\n        address _owner\n    ) ERC20(_name, _symbol) ERC165A() {\n        if (initialSupply != 0) _mint(_owner, initialSupply);\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setupRole(MINTER_ROLE, _owner);\n        _setupRole(SNAPSHOT_ROLE, _owner);\n        _registerInterface(ERC20_RECEIVED);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId] || super.supportsInterface(interfaceId);\n    }\n\n    function mint(address account, uint256 amount)\n        external\n        onlyRole(MINTER_ROLE)\n        returns (bool)\n    {\n        _mint(account,amount);\n        return true;\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n    * @dev  Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount) public {\n        safeTransfer(recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    */\n    function safeTransfer(address recipient, uint256 amount, bytes memory data) public {\n        transfer(recipient, amount);\n        require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount) public {\n        safeTransferFrom(sender, recipient, amount, \"\");\n    }\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.\n    * `amount` is then deducted from the caller's allowance.\n    */\n    function safeTransferFrom(address sender, address recipient, uint256 amount, bytes memory data) public {\n        transferFrom(sender, recipient, amount);\n        require(_checkOnERC20Received(sender, recipient, amount, data), \"ERC20: transfer to non ERC20Receiver implementer\");\n    }\n\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n\n    function approveAndCall(address spender, uint256 amount, bytes memory data) public returns (bool) {\n        require(approve(spender, amount));\n        _callOnApprove(msg.sender, spender, amount, data);\n        return true;\n    }\n\n    function snapshot() public onlyRole(SNAPSHOT_ROLE) returns (uint256) {\n        return _snapshot();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _balanceOfAt(account, snapshotId);\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _totalSupplyAt(snapshotId);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(getAccountBalanceSnapshots(account), balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(getTotalSupplySnapshots(), totalSupply());\n    }\n}\n\n"
    },
    "contracts/L1/tokens/ERC20Snapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\n\nabstract contract ERC20Snapshot  {\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter  private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    function currentSnapshotId() public view returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n     /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n\n    function _balanceOfAt(address account, uint256 snapshotId) internal view virtual returns (bool, uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return (snapshotted, value);\n        //return snapshotted ? value : balanceOf(account);\n    }\n\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n\n    function _totalSupplyAt(uint256 snapshotId) internal view virtual returns (bool, uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n        return (snapshotted, value);\n        //return snapshotted ? value : totalSupply();\n    }\n\n    /*\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n    */\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) internal view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n    /*\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n    */\n\n    function getAccountBalanceSnapshots(address account) internal view returns (Snapshots storage)  {\n        return _accountBalanceSnapshots[account];\n    }\n\n    function getTotalSupplySnapshots() internal view returns (Snapshots storage)  {\n        return _totalSupplySnapshots;\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) internal {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) internal view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n\n}"
    },
    "contracts/L2/factory/Create2Deployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Create2Deployer {\n  event Deployed(address addr, uint256 salt);\n\n  function deploy(bytes memory code, uint256 salt) external {\n    address addr;\n    assembly {\n      addr := create2(0, add(code, 0x20), mload(code), salt)\n      if iszero(extcodesize(addr)) {\n        revert(0, 0)\n      }\n    }\n    emit Deployed(addr, salt);\n  }\n}"
    },
    "contracts/L2/factory/L2TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* Contract Imports */\nimport { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\n\nimport { L2StandardERC20 } from \"../../standards/L2StandardERC20.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport 'hardhat/console.sol';\n\ninterface IL2Projectmanager {\n\n    function createL2Project(\n        address projectOwner,\n        address l1Token,\n        address l2Token,\n        string calldata projectName\n    )  external;\n}\n\n/**\n * @title L2TokenFactory\n * @dev Factory contract for creating standard L2 token representations of L1 ERC20s\n * compatible with and working on the standard bridge.\n */\ncontract L2TokenFactory is AccessibleCommon {\n\n    address public l2ProjectManager;\n\n    event StandardL2TokenCreated(address indexed l1Token, address indexed l2Token);\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"Z2\");\n        _;\n    }\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n     constructor() {\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /* ========== onlyOwner ========== */\n    function setL2ProjectManager(address _l2ProjectManager)\n        external nonZeroAddress(_l2ProjectManager) onlyOwner\n    {\n        require(l2ProjectManager != _l2ProjectManager, \"same\");\n        l2ProjectManager = _l2ProjectManager;\n    }\n\n    /* ========== Anyone can execute ========== */\n\n    /**\n     * @dev Creates an instance of the standard ERC20 token on L2.\n     * @param projectOwner Address of the project owner.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    function createL2Token(\n        address projectOwner,\n        address _l1Token,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata projectName\n    ) external {\n        require(_l1Token != address(0), \"Must provide L1 token address\");\n        require(projectOwner != address(0), \"zero projectOwner\");\n        require(bytes(_name).length != 0, \"name is null\");\n        require(bytes(_symbol).length != 0, \"symbol is null\");\n\n        L2StandardERC20 l2Token = new L2StandardERC20(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            _l1Token,\n            _name,\n            _symbol\n        );\n\n        require(address(l2Token) != address(0), \"zero l2Token\");\n        IL2Projectmanager(l2ProjectManager).createL2Project(\n            projectOwner, _l1Token, address(l2Token), projectName\n        );\n\n        emit StandardL2TokenCreated(_l1Token, address(l2Token));\n    }\n\n    /* ========== VIEW ========== */\n\n    /* === ======= internal ========== */\n\n\n}\n"
    },
    "contracts/L2/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/// @title ERC721 with permit\n/// @notice Extension to ERC721 that includes a permit function for signature based approvals\ninterface IERC721Permit is IERC721 {\n    /// @notice The permit typehash used in the permit signature\n    /// @return The typehash for the permit\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    /// @notice The domain separator used in the permit signature\n    /// @return The domain seperator used in encoding of permit signature\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Approve of a specific token ID for spending by spender via signature\n    /// @param spender The account that is being approved\n    /// @param tokenId The ID of the token that is being approved for spending\n    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
    },
    "contracts/L2/interfaces/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport './IPoolInitializer.sol';\nimport './IERC721Permit.sol';\nimport './IPeripheryPayments.sol';\nimport './IPeripheryImmutableState.sol';\nimport '../libraries/PoolAddress.sol';\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is\n    IPoolInitializer,\n    IPeripheryPayments,\n    IPeripheryImmutableState,\n    IERC721Metadata,\n    IERC721Enumerable,\n    IERC721Permit\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n}\n"
    },
    "contracts/L2/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "contracts/L2/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "contracts/L2/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"
    },
    "contracts/L2/L1StosInL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport \"../libraries/BytesLib.sol\";\n\nimport \"../libraries//LibLockId.sol\";\nimport \"hardhat/console.sol\";\n\ninterface ILockIdNftForRegister {\n    function register(\n        address account,\n        LibLockId.SyncPacket[] memory packets\n    ) external;\n}\n\ninterface IL2CrossDomainMessenger {\n    function xDomainMessageSender() external view returns (address);\n}\n\ncontract L1StosInL2  {\n    using BytesLib for bytes;\n\n    address public _manager;\n    address public lockIdNftForRegister;\n    address public l2CrossDomainMessenger;\n    address public l1Register;\n\n    event ManagershipTransferred(address indexed previousManager, address indexed newManager);\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier onlyMessengerAndL1Register() {\n\n        require(\n            l2CrossDomainMessenger == msg.sender &&\n            IL2CrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender() == l1Register,\n            \"not onlyMessengerAndL1Register\");\n        _;\n    }\n\n    modifier nonZero(uint256 _val) {\n        require(_val != 0, \"zero value\");\n        _;\n    }\n\n    constructor (\n        address managerAddress,\n        address l2messanger_\n    ) {\n        _manager = managerAddress;\n        l2CrossDomainMessenger =l2messanger_;\n    }\n\n    function setL1Register(address l1Register_) external onlyManager {\n        require(l1Register != l1Register_, \"same\");\n        l1Register = l1Register_;\n    }\n\n    function setLockIdNft(address lockIdNft_) external onlyManager {\n        require(lockIdNftForRegister != lockIdNft_, \"same\");\n        lockIdNftForRegister = lockIdNft_;\n    }\n\n    function renounceManagership() external onlyManager {\n        emit ManagershipTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    function transferManagership(address newManager) external onlyManager {\n        require(newManager != address(0), \"new manager is the zero address\");\n        emit ManagershipTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n\n    /*** Public ***/\n    // function register(bytes memory data) public {\n    //     console.log('IL1StosInL2 register in' );\n    //     console.logBytes(data);\n    //     console.log('IL1StosInL2 l2CrossDomainMessenger %s', l2CrossDomainMessenger);\n    //     console.log('IL1StosInL2 msg.sender %s', msg.sender );\n    //     address xDomainMessageSender = IL2CrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender();\n\n    //     console.log('IL1StosInL2 xDomainMessageSender %s', xDomainMessageSender );\n    //     console.log('IL1StosInL2 l1Register %s', l1Register );\n\n\n    // }\n\n    function register(bytes memory data) public onlyMessengerAndL1Register {\n\n        // packet {address | 1st sync packet  2nd sync packet  .....}\n        // address : 20 bytes\n        // one sync packets : 104 bytes:  (32 byte) uint256 lockId, (32+32+4+4) syncInfo -> total 104\n        require(data.length > 123, \"wrong bytes length\");\n        address user = data.toAddress(0);\n\n        LibLockId.SyncPacket[] memory packets = decodeSyncPackets(data.slice(20,(data.length-20)));\n\n        require(packets.length != 0, \"no sync data\");\n        ILockIdNftForRegister(lockIdNftForRegister).register(user, packets);\n    }\n\n    function multiRegister(bytes[] memory datas) external onlyMessengerAndL1Register {\n        require(datas.length != 0, \"no data\");\n        for(uint256 i = 0; i < datas.length; i++) {\n            register(datas[i]);\n        }\n    }\n\n\n    function decodeSyncPackets(bytes memory data) public pure returns (LibLockId.SyncPacket[] memory packets) {\n        uint256 packSize = 104;\n        uint256 len = data.length / packSize;\n        packets = new LibLockId.SyncPacket[](len);\n        for(uint256 i = 0; i < len ; i++){\n            bytes memory packet = data.slice(i, packSize);\n            packets[i] = LibLockId.SyncPacket({\n                lockId: packet.toUint256(0),\n                packet: LibLockId.SyncInfo({\n                    slope: packet.toInt256(32),\n                    bias: packet.toInt256(64),\n                    timestamp: packet.toUint32(96),\n                    syncTime: packet.toUint32(100)\n                })\n            });\n        }\n    }\n\n}\n"
    },
    "contracts/L2/L2PaymasterDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport \"../libraries/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\n\ninterface IPaymaster {\n    function addDepositFor(address token, address account, uint256 amount) external;\n}\n\ncontract L2PaymasterDeposit {\n    using SafeERC20 for IERC20;\n\n    address public paymaster;\n    event AddedDepositFor(address indexed l1Token, address indexed account, uint256 amount);\n    event InsufficentBalance(address indexed l1Token, address indexed account, uint256 amount);\n\n    constructor(address _paymaster) {\n       paymaster = _paymaster;\n    }\n\n    function addDepositFor(\n        address token,\n        address account,\n        uint256 amount)\n        external\n    {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance < amount) {\n            emit InsufficentBalance(token, account, amount);\n        } else {\n            uint256 allowance = IERC20(token).allowance(address(this), paymaster);\n            if (allowance < amount) {\n                IERC20(token).approve(paymaster, type(uint256).max);\n            }\n\n            IPaymaster(paymaster).addDepositFor(\n                token, account, amount\n            );\n            emit AddedDepositFor(token, account, amount);\n        }\n    }\n\n}"
    },
    "contracts/L2/L2ProjectManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nimport \"../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\nimport \"./L2ProjectManagerStorage.sol\";\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport \"../libraries/LibProject.sol\";\nimport \"../libraries/SafeERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface IL2CrossDomainMessenger {\n    function xDomainMessageSender() external view returns (address);\n}\n\ninterface IL2CustomVaultBase {\n    function setVaultAdmin(\n        address l2Token,\n        address _newAdmin\n    ) external;\n\n    function isVaultAdmin(address l2Token, address account) external view returns (bool);\n}\n\ninterface IL2PublicSaleVault {\n    function vaultInitialize(\n        address l2Token,\n        LibProject.InitalParameterPublicSaleVault memory vaultParams,\n        LibProject.InitalParameterPublicSaleClaim memory claimParams\n    ) external;\n}\n\ninterface IL2InitialLiquidityVault {\n    function initialize(\n        address l2Token,\n        LibProject.InitalParameterInitialLiquidityVault memory params\n    ) external;\n}\n\ninterface IL2LiquidityRewardVault {\n    function initialize(\n        address l2Token,\n        LibProject.InitalParameterLiquidityRewardVault memory params\n    ) external;\n}\n\ninterface IL2ScheduleVault {\n    function initialize(\n        address l2Token,\n        string memory vaultName,\n        LibProject.InitalParameterScheduleVault memory params\n    ) external;\n}\n\ninterface IL2NonScheduleVault {\n    function initialize(\n        address l2Token,\n        string memory vaultName,\n        uint256 totalAllocatedAmount\n    ) external;\n}\n/**\n * @title L2ProjectManager\n * @dev\n */\ncontract L2ProjectManager is ProxyStorage, AccessibleCommon, L2ProjectManagerStorage {\n    using SafeERC20 for IERC20;\n\n    modifier onlyL2TokenFactory() {\n        require(l2TokenFactory != address(0) && msg.sender == l2TokenFactory, \"caller is not l2TokenFactory\");\n        _;\n    }\n\n    modifier onlyMessengerAndL1ProjectManager() {\n        console.log('onlyMessengerAndL1ProjectManager msg.sender %s', msg.sender);\n        console.log('onlyMessengerAndL1ProjectManager l2CrossDomainMessenger %s', l2CrossDomainMessenger);\n        console.log('onlyMessengerAndL1ProjectManager l1ProjectManager %s', l1ProjectManager);\n        console.log('onlyMessengerAndL1ProjectManager xDomainMessageSender %s', IL2CrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender());\n\n        require(msg.sender == l2CrossDomainMessenger &&\n        IL2CrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender() == l1ProjectManager,\n        \"not onlyMessengerAndL1ProjectManager\");\n        _;\n    }\n\n    modifier nonZero(uint256 value) {\n        require(value != 0, \"Z1\");\n        _;\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"Z2\");\n        _;\n    }\n\n    modifier ifFree {\n        require(free, \"lock\");\n        free = false;\n        _;\n        free = true;\n    }\n\n    event CreatedL2Project(address indexed l1Token, address indexed l2Token, address projectOwner, string projectName);\n    event DistributedL2Token(\n        address l1Token,\n        address l2Token,\n        uint256 projectId,\n        uint256 totalAmount\n        );\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor() {\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /* ========== onlyOwner ========== */\n\n    /// @dev l1ProjectManager 주소 설정\n    function setL1ProjectManager(address _l1ProjectManager)\n        external nonZeroAddress(_l1ProjectManager) onlyOwner\n    {\n        require(l1ProjectManager != _l1ProjectManager, \"same\");\n        l1ProjectManager = _l1ProjectManager;\n    }\n\n    /// @dev l2TokenFactory 주소 설정\n    function setL2TokenFactory(address _l2TokenFactory)\n        external nonZeroAddress(_l2TokenFactory) onlyOwner\n    {\n        require(l2TokenFactory != _l2TokenFactory, \"same\");\n        l2TokenFactory = _l2TokenFactory;\n    }\n\n    /// @dev l2CrossDomainMessenger 주소 설정\n    function setL2CrossDomainMessenger(address _l2CrossDomainMessenger)\n        external nonZeroAddress(_l2CrossDomainMessenger) onlyOwner\n    {\n        require(l2CrossDomainMessenger != _l2CrossDomainMessenger, \"same\");\n        l2CrossDomainMessenger = _l2CrossDomainMessenger;\n    }\n\n    function setTokamakVaults(\n        address publicSale,\n        address initialLiquidity,\n        address liquidityReward,\n        address tonAirdrop,\n        address tosAirdrop,\n        address _scheduleVault,\n        address _nonScheduleVault\n        )\n        external onlyOwner\n        // nonZeroAddress(publicSale)\n        nonZeroAddress(initialLiquidity)\n        // nonZeroAddress(liquidityReward)\n        // nonZeroAddress(tosAirdrop)\n        // nonZeroAddress(tonAirdrop)\n        nonZeroAddress(_scheduleVault)\n        nonZeroAddress(_nonScheduleVault)\n    {\n        require(scheduleVault == address(0), \"already set\");\n        // require(\n        //     publicSaleVault != publicSale ||\n        //     initialLiquidityVault != initialLiquidity ||\n        //     liquidityRewardVault != liquidityReward ||\n        //     tonAirdropVault != tonAirdrop ||\n        //     tosAirdropVault != tosAirdrop\n        //     , \"same\");\n\n        publicSaleVault = publicSale;\n        initialLiquidityVault = initialLiquidity;\n        liquidityReward = liquidityReward;\n        tonAirdropVault = tonAirdrop;\n        tosAirdropVault = tosAirdrop;\n        scheduleVault = _scheduleVault;\n        nonScheduleVault = _nonScheduleVault;\n    }\n\n    /* ========== only L2TokenFactory ========== */\n\n    /// @dev 프로젝트 추가\n    function createL2Project(\n        address projectOwner,\n        address l1Token,\n        address l2Token,\n        string calldata projectName\n    )\n        external onlyL2TokenFactory\n    {\n        require(bytes(projectName).length != 0, \"projectName is null\");\n        require(projects[l2Token].l1Token == address(0), \"already added\");\n        projects[l2Token] = LibProject.L2ProjectInfo({\n            projectId: 0,\n            projectOwner: projectOwner,\n            l1Token : l1Token,\n            l2Token : l2Token,\n            projectName : projectName\n        });\n        tokenMaps[l1Token] = l2Token;\n        emit CreatedL2Project(l1Token, l2Token, projectOwner, projectName);\n    }\n\n    /* ========== only L2CrossDomainMessengerAndL1ProjectManager ========== */\n\n    function _approveVaults(address l2Token, address vault, uint256 amount) internal {\n        if (\n            vault != address(0) &&\n            amount != 0 &&\n            amount < IERC20(l2Token).allowance(address(this), vault)) IERC20(l2Token).approve(vault, amount);\n    }\n\n    function distributesL2Token(\n        address l1Token,\n        address l2Token,\n        uint256 projectId,\n        uint256 totalAmount,\n        LibProject.TokamakVaults memory tokamakVaults,\n        LibProject.InitalParameterSchedule[] memory customScheduleVaults,\n        LibProject.InitalParameterNonScheduleVault[] memory customNonScheduleVaults\n    )\n        external onlyMessengerAndL1ProjectManager\n        nonZeroAddress(l1Token)\n        nonZeroAddress(l2Token)\n        nonZero(projectId) nonZero(totalAmount)\n    {\n        console.log(\"L2ProjectManager distributesL2Token in\");\n        console.log(\"L2ProjectManager l1Token %\", l1Token);\n        console.log(\"L2ProjectManager l2Token %\", l2Token);\n        console.log(\"L2ProjectManager projectId %\", projectId);\n        console.log(\"L2ProjectManager totalAmount %\", totalAmount);\n\n        LibProject.L2ProjectInfo memory info = projects[l2Token];\n        console.log(\"L2ProjectManager info.l1Token %\", info.l1Token);\n        console.log(\"L2ProjectManager info.l2Token %\", info.l2Token);\n\n        require(info.l1Token == l1Token, \"not matched l1Token\");\n        require(info.l2Token == l2Token, \"not matched l2Token\");\n\n        uint256 publicTotal = tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount\n            + tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount;\n        console.log(\"L2ProjectManager publicTotal %\", publicTotal);\n\n        uint256 total = publicTotal +\n            tokamakVaults.initialVaultParams.totalAllocatedAmount +\n            tokamakVaults.rewardParams.params.totalAllocatedAmount +\n            tokamakVaults.tosAirdropParams.totalAllocatedAmount +\n            tokamakVaults.tonAirdropParams.totalAllocatedAmount ;\n        console.log(\"L2ProjectManager total %\", total);\n\n        uint256 totalCustomSchedule = 0;\n        uint256 totalNonCustomSchedule = 0;\n\n        for (uint256 i = 0; i < customScheduleVaults.length; i++)\n            totalCustomSchedule += customScheduleVaults[i].params.totalAllocatedAmount;\n\n        for (uint256 j = 0; j < customNonScheduleVaults.length; j++)\n            totalNonCustomSchedule += customNonScheduleVaults[j].totalAllocatedAmount;\n        console.log(\"L2ProjectManager totalCustomSchedule %\", totalCustomSchedule);\n        console.log(\"L2ProjectManager totalNonCustomSchedule %\", totalNonCustomSchedule);\n\n        total += (totalCustomSchedule + totalNonCustomSchedule);\n        console.log(\"L2ProjectManager total %\", total);\n\n        require(total == totalAmount, \"not matched totalAmount\");\n\n        projects[info.l2Token].projectId = projectId;\n        _approveVaults(l2Token, publicSaleVault, publicTotal);\n        _approveVaults(l2Token, initialLiquidityVault, tokamakVaults.initialVaultParams.totalAllocatedAmount);\n        _approveVaults(l2Token, liquidityRewardVault, tokamakVaults.rewardParams.params.totalAllocatedAmount);\n        _approveVaults(l2Token, tonAirdropVault, tokamakVaults.tonAirdropParams.totalAllocatedAmount);\n        _approveVaults(l2Token, tosAirdropVault, tokamakVaults.tosAirdropParams.totalAllocatedAmount);\n\n        if (publicTotal != 0) {\n            IL2CustomVaultBase(publicSaleVault).setVaultAdmin(info.l2Token, info.projectOwner);\n            IL2PublicSaleVault(publicSaleVault).vaultInitialize(\n                info.l2Token,\n                tokamakVaults.publicSaleParams.vaultParams,\n                tokamakVaults.publicSaleParams.claimParams\n            );\n        }\n        LibProject.InitalParameterInitialLiquidityVault memory initialVaultParams = tokamakVaults.initialVaultParams;\n        console.log(\"initialVaultParams totalAllocatedAmount %s\", initialVaultParams.totalAllocatedAmount);\n\n        if (tokamakVaults.initialVaultParams.totalAllocatedAmount != 0) {\n            console.log(\"initialVaultParams.totalAllocatedAmount != 0\" );\n\n            bool isAdmin = IL2CustomVaultBase(initialLiquidityVault).isVaultAdmin(info.l2Token, info.projectOwner);\n            console.logBool(isAdmin);\n\n            if(isAdmin == false) IL2CustomVaultBase(initialLiquidityVault).setVaultAdmin(info.l2Token, info.projectOwner);\n            bool isAdmin1 = IL2CustomVaultBase(initialLiquidityVault).isVaultAdmin(info.l2Token, info.projectOwner);\n            console.logBool(isAdmin1);\n\n\n            IL2InitialLiquidityVault(initialLiquidityVault).initialize(\n                info.l2Token,\n                initialVaultParams);\n        }\n\n        if (tokamakVaults.rewardParams.params.totalAllocatedAmount != 0) {\n            // // liquidity reward\n            // IL2CustomVaultBase(initialLiquidityVault).setVaultAdmin(l2Token, projects[l2Token].projectOwner);\n            // IL2LiquidityRewardVault(liquidityRewardVault).initialize(\n            //     l2Token,\n            //     tokamakVaults.rewardParams);\n        }\n\n        if (tokamakVaults.tosAirdropParams.totalAllocatedAmount != 0) {\n            //\n        }\n\n        if (tokamakVaults.tonAirdropParams.totalAllocatedAmount != 0) {\n            //\n        }\n        console.log(\"totalCustomSchedule %s\", totalCustomSchedule);\n\n        if (totalCustomSchedule != 0) {\n            if(!IL2CustomVaultBase(scheduleVault).isVaultAdmin(info.l2Token, info.projectOwner))\n                IL2CustomVaultBase(scheduleVault).setVaultAdmin(info.l2Token, info.projectOwner);\n\n            for (uint256 i = 0; i < customScheduleVaults.length; i++){\n                LibProject.InitalParameterSchedule memory params = customScheduleVaults[i];\n                IL2ScheduleVault(scheduleVault).initialize(\n                    info.l2Token,\n                    params.vaultName,\n                    params.params);\n            }\n\n        }\n        console.log(\"totalNonCustomSchedule %s\", totalNonCustomSchedule);\n\n        if (totalNonCustomSchedule != 0) {\n            if(!IL2CustomVaultBase(nonScheduleVault).isVaultAdmin(info.l2Token, info.projectOwner))\n                IL2CustomVaultBase(nonScheduleVault).setVaultAdmin(info.l2Token, info.projectOwner);\n\n            for (uint256 i = 0; i < customNonScheduleVaults.length; i++){\n                LibProject.InitalParameterNonScheduleVault memory params = customNonScheduleVaults[i];\n                IL2NonScheduleVault(nonScheduleVault).initialize(\n                    info.l2Token,\n                    params.vaultName,\n                    params.totalAllocatedAmount );\n            }\n        }\n\n        emit DistributedL2Token(info.l1Token, info.l2Token, info.projectId, total);\n    }\n\n    /* ========== Anyone can execute ========== */\n\n    /* ========== VIEW ========== */\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L2/L2ProjectManagerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../proxy/Proxy.sol\";\nimport \"./L2ProjectManagerStorage.sol\";\n\n/**\n * @title L2ProjectManagerProxy\n * @dev\n */\ncontract L2ProjectManagerProxy is Proxy, L2ProjectManagerStorage {\n\n}"
    },
    "contracts/L2/L2ProjectManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport { LibProject } from \"../libraries/LibProject.sol\";\n\n/**\n * @title L2ProjectManagerStorage\n * @dev\n */\ncontract L2ProjectManagerStorage {\n\n    bool internal free = true;\n    address public l1ProjectManager;\n    address public l2TokenFactory;\n    address public l2CrossDomainMessenger;\n\n    // 토큰별로 대표되는 볼트\n    address public publicSaleVault;\n    address public initialLiquidityVault;\n    address public liquidityRewardVault;\n    address public tonAirdropVault;\n    address public tosAirdropVault;\n\n    address public scheduleVault; // customScheduleVault\n    address public nonScheduleVault;    // customNonScheduleVault\n\n    // l2token - L2ProjectInfo\n    mapping(address => LibProject.L2ProjectInfo) public projects;\n\n    // l1token - l2token\n    mapping(address => address) public tokenMaps;\n\n}\n"
    },
    "contracts/L2/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // Handle division by zero\n        require(denominator > 0);\n\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            // require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        // 2022.0314.modified\n        //uint256 twos = -denominator & denominator;\n        //uint256 twos = denominator & (~denominator + 1);\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n\n        unchecked {\n            prod0 |= prod1 * twos;\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n\n            uint256 inv = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n        }\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "contracts/L2/libraries/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\nimport '../libraries/FullMath.sol';\nimport '../libraries/TickMath.sol';\n\ninterface IIIUniswapV3Pool {\n\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n\n}\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n\n    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {\n        require(period != 0, 'BP');\n\n        uint32[] memory secondAgos = new uint32[](2);\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = IIIUniswapV3Pool(pool).observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        timeWeightedAverageTick = int24(tickCumulativesDelta / int56( int32(period) ));\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56( int32(period) ) != 0)) timeWeightedAverageTick--;\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n}\n"
    },
    "contracts/L2/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xa598dd2fba360510c5a8f02f44423a4468e902df5857dbce3ca162a43a3a31ff;\n    // DARIUS - POOL_INIT_CODE_HASH = 0xa598dd2fba360510c5a8f02f44423a4468e902df5857dbce3ca162a43a3a31ff;\n    // mainnet(default) - POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address( uint160(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            ))\n        );\n    }\n}\n"
    },
    "contracts/L2/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(MAX_TICK)), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "contracts/L2/vaults/L2CustomVaultBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ProxyStorage } from \"../../proxy/ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\nimport { L2CustomVaultBaseStorage } from \"./L2CustomVaultBaseStorage.sol\";\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/SafeERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title L2CustomVaultBase\n * @dev\n */\ncontract L2CustomVaultBase is ProxyStorage, AccessibleCommon, L2CustomVaultBaseStorage {\n     using SafeERC20 for IERC20;\n\n    /* ========== DEPENDENCIES ========== */\n\n    // event AllocatedTokenAndAdminInVault(address l2Token, address newAdmin, uint256 amount);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /* ========== onlyOwner ========== */\n\n    function setL2ProjectManager(address _l2ProjectManager)\n        external nonZeroAddress(_l2ProjectManager) onlyOwner\n    {\n        require(l2ProjectManager != _l2ProjectManager, \"same\");\n        l2ProjectManager = _l2ProjectManager;\n    }\n\n    function setInitializer(address _initializer)\n        external nonZeroAddress(_initializer) onlyOwner\n    {\n        require(initializer != _initializer, \"same\");\n        initializer = _initializer;\n\n         emit SetInitializer(_initializer);\n    }\n\n    /* ========== only L2ProjectManager ========== */\n\n    function setVaultAdmin(\n        address l2Token,\n        address _newAdmin\n    )\n        external nonZeroAddress(l2Token) nonZeroAddress(_newAdmin) onlyL2ProjectManager\n    {\n        require(vaultAdminOfToken[l2Token] != _newAdmin, \"same\");\n        vaultAdminOfToken[l2Token] = _newAdmin;\n        emit SetVaultAdmin(l2Token, _newAdmin);\n    }\n\n    // function allocateTokenAndAdmin(address l2Token, address _newAdmin, uint256 amount)\n    //     external  onlyL2ProjectManager\n    //     nonZeroAddress(l2Token)  nonZeroAddress(_newAdmin) nonZero(amount)\n    // {\n    //     require(vaultAdminOfToken[l2Token] != _newAdmin, \"same admin\");\n    //     require(amount <= IERC20(l2Token).balanceOf(l2ProjectManager), \"balance is insufficient.\");\n\n    //     vaultAdminOfToken[l2Token] = _newAdmin;\n    //     IERC20(l2Token).safeTransferFrom(l2ProjectManager, address(this), amount);\n    //     emit AllocatedTokenAndAdminInVault(l2Token, _newAdmin, amount);\n    // }\n\n    /* ========== only VaultAdmin Of Token ========== */\n\n    /* ========== Anyone can vault admin of token ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    function isVaultAdmin(address l2Token, address account) public view returns (bool) {\n        return (account != address(0) && vaultAdminOfToken[l2Token] == account);\n    }\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L2/vaults/L2CustomVaultBaseProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { Proxy } from \"../../proxy/Proxy.sol\";\nimport { L2CustomVaultBaseStorage } from \"./L2CustomVaultBaseStorage.sol\";\n\n/**\n * @title L2CustomVaultBase\n * @dev\n */\ncontract L2CustomVaultBaseProxy is Proxy, L2CustomVaultBaseStorage {\n\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /* ========== onlyOwner ========== */\n\n    /* ========== only L2ProjectManager ========== */\n\n\n    /* ========== only VaultAdmin Of Token ========== */\n\n    /* ========== Anyone can vault admin of token ========== */\n\n    /* ========== VIEW ========== */\n\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L2/vaults/L2CustomVaultBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"hardhat/console.sol\";\n/**\n * @title L2CustomVaultBaseStorage\n * @dev\n */\ncontract L2CustomVaultBaseStorage {\n\n    bool internal free = true;\n    address public l2ProjectManager;\n    address public initializer;\n\n    // l2token - tokenOwner\n    mapping(address => address) public vaultAdminOfToken;\n\n    event SetVaultAdmin(address l2Token, address newAdmin);\n    event SetInitializer(address newInitializer);\n\n    modifier onlyL2ProjectManager() {\n        console.log('onlyL2ProjectManager %s %s', msg.sender, l2ProjectManager);\n        require(l2ProjectManager != address(0) && msg.sender == l2ProjectManager, \"caller is not l2ProjectManager\");\n        _;\n    }\n\n    modifier onlyVaultAdminOfToken(address l2token) {\n        require(vaultAdminOfToken[l2token] != address(0) && msg.sender == vaultAdminOfToken[l2token], \"caller is not a vaultAdmin Of l2Token\");\n        _;\n    }\n\n    modifier onlyInitializerOrVaultAdmin(address l2token) {\n        require(vaultAdminOfToken[l2token] != address(0) &&\n            ( msg.sender == initializer || msg.sender == vaultAdminOfToken[l2token]),\n            \"caller is not a vaultAdmin Of l2Token\");\n        _;\n    }\n\n    modifier onlyL2ProjectManagerOrVaultAdmin(address l2token) {\n        console.log(\"onlyL2ProjectManagerOrVaultAdmin l2token %s\", l2token);\n        console.log(\"onlyL2ProjectManagerOrVaultAdmin msg.sender %s\", msg.sender);\n        console.log(\"onlyL2ProjectManagerOrVaultAdmin l2ProjectManager %s\", l2ProjectManager);\n        console.log(\"onlyL2ProjectManagerOrVaultAdmin vaultAdminOfToken[l2token] %s\", vaultAdminOfToken[l2token]);\n\n        require(msg.sender == l2ProjectManager ||\n            (vaultAdminOfToken[l2token] != address(0) || msg.sender == vaultAdminOfToken[l2token]),\n            \"caller is not a vaultAdmin or ProjectManager\");\n        _;\n    }\n\n    modifier nonZero(uint256 value) {\n        require(value != 0, \"Z1\");\n        _;\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"Z2\");\n        _;\n    }\n\n    modifier ifFree {\n        require(free, \"lock\");\n        free = false;\n        _;\n        free = true;\n    }\n\n\n}"
    },
    "contracts/L2/vaults/L2InitialLiquidityVault.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\n// import { ProxyStorage } from \"../../proxy/ProxyStorage.sol\";\n// import { AccessibleCommon } from \"../../common/AccessibleCommon.sol\";\n// import { L2CustomVaultBaseStorage } from \"./L2CustomVaultBaseStorage.sol\";\n\nimport \"./L2CustomVaultBase.sol\";\nimport \"./L2InitialLiquidityVaultStorage.sol\";\n\nimport \"../interfaces/INonfungiblePositionManager.sol\";\n\nimport '../../libraries/LibProject.sol';\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/SafeERC20.sol\";\n\nimport \"../libraries/TickMath.sol\";\nimport \"../libraries/OracleLibrary.sol\";\nimport '../libraries/FullMath.sol';\n\ninterface IIUniswapV3Factory {\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n}\n\ninterface IIUniswapV3Pool {\n\n    function initialize(uint160 sqrtPriceX96) external;\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n\n}\n\ncontract L2InitialLiquidityVault is L2CustomVaultBase, L2InitialLiquidityVaultStorage\n{\n    using SafeERC20 for IERC20;\n    /* ========== DEPENDENCIES ========== */\n\n    modifier afterSetUniswap() {\n        require(\n            uniswapV3Factory != address(0)\n            && nonfungiblePositionManager != address(0)\n            && tos != address(0)\n            ,\n            \"Vault: before setUniswap\");\n        _;\n    }\n\n    modifier readyToCreatePool(address l2Token) {\n        require(poolInfo[l2Token].boolReadyToCreatePool, \"Vault: not ready to CreatePool\");\n        _;\n    }\n\n    modifier beforeSetReadyToCreatePool(address l2Token) {\n        require(!poolInfo[l2Token].boolReadyToCreatePool, \"Vault: already ready to CreatePool\");\n        _;\n    }\n\n    event SetUniswapInfo(address _factory, address _npm, address _ton, address _tos);\n    event SetStartTime(address l2Token, uint32 startTime);\n    event SetPoolInitialized(address l2Token, address pool, uint160 inSqrtPriceX96);\n    event SetCreatedPool(address l2Token, address pool);\n    event InitializedInitialLiquidityVault(\n        address l2Token,\n        uint256 totalAllocatedAmount,\n        uint256 initialTosPrice,\n        uint256 initialTokenPrice,\n        uint32 startTime,\n        uint160 initSqrtPriceX96,\n        uint24 fee\n    );\n\n    event IncreasedLiquidityInVault(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    event InitialMintedInVault(\n        address l2Token,\n        address pool,\n        uint256 tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /* ========== onlyOwner ========== */\n    function setUniswapInfo(address _poolfactory, address _npm, address _ton, address _tos)\n        external\n        onlyOwner nonZeroAddress(_poolfactory) nonZeroAddress(_npm) nonZeroAddress(_ton) nonZeroAddress(_tos)\n    {\n        require(_poolfactory != uniswapV3Factory ||  _npm != nonfungiblePositionManager ||\n             ton != _ton || tos != _tos, \"same\");\n\n        uniswapV3Factory = _poolfactory;\n        nonfungiblePositionManager = _npm;\n        ton = _ton;\n        tos = _tos;\n\n        emit SetUniswapInfo(_poolfactory, _npm, _ton, _tos);\n    }\n\n    function setAcceptTickChangeInterval(int24 _interval) external onlyOwner\n    {\n        require(_interval > 0, \"zero\");\n        require(acceptTickChangeInterval != _interval, \"same\");\n        acceptTickChangeInterval = _interval;\n    }\n\n    function setAcceptSlippagePrice(int24 _value) external onlyOwner\n    {\n        require(_value > 0, \"zero\");\n        require(acceptSlippagePrice != _value, \"same\");\n        acceptSlippagePrice = _value;\n    }\n\n    function setTWAP_PERIOD(uint32 value) external onlyOwner\n    {\n        require(value > 0, \"zero\");\n        require(TWAP_PERIOD != value, \"same\");\n        TWAP_PERIOD = value;\n    }\n\n\n    /* ========== only L2ProjectManager ========== */\n    function initialize(\n        address l2Token,\n        LibProject.InitalParameterInitialLiquidityVault memory params\n    )\n        external onlyL2ProjectManagerOrVaultAdmin(l2Token) afterSetUniswap\n    {\n        console.log('initialize in l2Token %s', l2Token);\n\n        require(poolInfo[l2Token].totalAllocatedAmount == 0, \"already initialized\");\n        require(params.totalAllocatedAmount != 0 && params.tosPrice != 0 && params.tokenPrice != 0 && params.initSqrtPrice != 0 && params.fee != 0,\n            \"zero totalAllocatedAmount or tosPrice or tokenPrice or initSqrtPriceX96 or startTime\");\n        require(params.startTime > uint32(block.timestamp), \"StartTime has passed\");\n\n        console.log('initialize iparams.totalAllocatedAmount %s', params.totalAllocatedAmount);\n        IERC20(l2Token).safeTransferFrom(l2ProjectManager, address(this), params.totalAllocatedAmount);\n        console.log('initialize safeTransferFrom ');\n\n        LibInitialLiquidityVault.PoolInfo storage info = poolInfo[l2Token];\n        info.totalAllocatedAmount = params.totalAllocatedAmount;\n        info.initialTosPrice = params.tosPrice;\n        info.initialTokenPrice = params.tokenPrice;\n        info.initSqrtPriceX96 = uint160(params.initSqrtPrice);\n        info.startTime = params.startTime;\n        info.fee = params.fee;\n\n        emit InitializedInitialLiquidityVault(\n            l2Token, params.totalAllocatedAmount, params.tosPrice, params.tokenPrice, params.startTime, uint160(params.initSqrtPrice), params.fee);\n    }\n\n    /* ========== only VaultAdmin Of Token ========== */\n    function setStartTime(address l2Token, uint32 _startTime)\n        public onlyVaultAdminOfToken(l2Token)\n    {\n        LibInitialLiquidityVault.PoolInfo storage info = poolInfo[l2Token];\n        require(block.timestamp < info.startTime, \"StartTime has passed\");\n        require(info.startTime != _startTime, \"same StartTime\");\n        info.startTime = _startTime;\n        emit SetStartTime(l2Token, _startTime);\n    }\n\n    /* ========== Anyone can  ========== */\n\n    function setCreatePool(address l2Token) external beforeSetReadyToCreatePool(l2Token) ifFree\n    {\n        LibInitialLiquidityVault.PoolInfo storage info = poolInfo[l2Token];\n        require(info.startTime > 0 && info.startTime < uint32(block.timestamp), \"StartTime has not passed.\");\n        require(info.pool == address(0), \"already created\");\n        require(info.initSqrtPriceX96 > 0, \"zero initSqrtPriceX96\");\n        address pool = IIUniswapV3Factory(uniswapV3Factory).getPool(tos, l2Token, info.fee);\n\n        if(pool == address(0)){\n            address _pool = IIUniswapV3Factory(uniswapV3Factory).createPool(tos, l2Token, info.fee);\n            require(_pool != address(0), \"createPool fail\");\n            pool = _pool;\n        }\n\n        info.pool = pool;\n        info.boolReadyToCreatePool = true;\n\n        (uint160 sqrtPriceX96,,,,,,) =  IIUniswapV3Pool(pool).slot0();\n        if(sqrtPriceX96 == 0){\n            IIUniswapV3Pool(pool).initialize(info.initSqrtPriceX96);\n            emit SetPoolInitialized(l2Token, pool, info.initSqrtPriceX96);\n        }\n        emit SetCreatedPool(l2Token, pool);\n\n        (uint160 _sqrtPriceX96,,,,,,) =  IIUniswapV3Pool(pool).slot0();\n        require(_sqrtPriceX96 != 0, 'zero _sqrtPriceX96');\n\n    }\n\n    function mint(address l2Token, uint256 tosAmount)\n        external readyToCreatePool(l2Token) nonZero(tosAmount) ifFree\n    {\n        uint256 tosBalance =  IERC20(tos).balanceOf(address(this));\n        uint256 tokenBalance =  IERC20(l2Token).balanceOf(address(this));\n        require(tosBalance > 1 ether && tokenBalance > 1 ether, \"balance is insufficient\");\n        require(tosAmount <= tosBalance, \"toBalance is insufficient\");\n\n        if (acceptTickChangeInterval == 0) acceptTickChangeInterval = 8;\n        if (acceptSlippagePrice == 0) acceptSlippagePrice = 10; // based 100\n        if (TWAP_PERIOD == 0) TWAP_PERIOD = 120;\n\n        LibInitialLiquidityVault.PoolInfo memory info = poolInfo[l2Token];\n        (uint160 sqrtPriceX96, int24 tick,,,,,) =  IIUniswapV3Pool(info.pool).slot0();\n        require(sqrtPriceX96 > 0, \"pool is not initialized\");\n\n        //if (lpToken > 0)\n        {\n            int24 timeWeightedAverageTick = OracleLibrary.consult(info.pool, TWAP_PERIOD);\n            require(\n                acceptMinTick(timeWeightedAverageTick, getTickSpacing(info.fee)) <= tick\n                && tick < acceptMaxTick(timeWeightedAverageTick, getTickSpacing(info.fee)),\n                \"It's not allowed changed tick range.\"\n            );\n        }\n\n        uint256 amount0Desired = 0;\n        uint256 amount1Desired = 0;\n        address token0 = IIUniswapV3Pool(info.pool).token0();\n\n        if(token0 != tos){\n            amount0Desired = getQuoteAtTick(\n                tick,\n                uint128(tosAmount),\n                tos,\n                l2Token\n                );\n            amount1Desired = tosAmount;\n            require(amount0Desired <= tokenBalance, \"tokenBalance is insufficient\");\n            checkBalance(l2Token, amount1Desired, amount0Desired);\n        } else {\n            amount0Desired = tosAmount;\n            amount1Desired = getQuoteAtTick(\n                tick,\n                uint128(tosAmount),\n                tos,\n                l2Token\n                );\n\n            require(amount1Desired <= tokenBalance, \"tokenBalance is insufficient\");\n            checkBalance(l2Token, amount0Desired, amount1Desired);\n        }\n\n        uint256 amount0Min = amount0Desired * (100 - uint256(int256(acceptSlippagePrice))) / 100;\n        uint256 amount1Min = amount1Desired * (100 - uint256(int256(acceptSlippagePrice))) / 100;\n\n        if(poolInfo[l2Token].lpToken == 0)  initialMint(l2Token, amount0Desired, amount1Desired, amount0Min, amount1Min);\n        else increaseLiquidity(l2Token, amount0Desired, amount1Desired, amount0Min, amount1Min);\n    }\n\n\n    /* ========== VIEW ========== */\n\n    function getTickSpacing(uint24 _fee) public pure returns (int24 tickSpacings)\n    {\n        if(_fee == 100) tickSpacings = 2;\n        else if(_fee == 500) tickSpacings = 10;\n        else if(_fee == 3000) tickSpacings = 60;\n        else if(_fee == 10000) tickSpacings = 200;\n    }\n\n    function acceptMinTick(int24 _tick, int24 _tickSpacings) public view returns (int24)\n    {\n        int24 _minTick = getMiniTick(_tickSpacings);\n        int24 _acceptMinTick = _tick - (_tickSpacings * int24(uint24(acceptTickChangeInterval)));\n\n        if(_minTick < _acceptMinTick) return _acceptMinTick;\n        else return _minTick;\n    }\n\n    function acceptMaxTick(int24 _tick, int24 _tickSpacings) public view returns (int24)\n    {\n        int24 _maxTick = getMaxTick(_tickSpacings);\n        int24 _acceptMinTick = _tick + (_tickSpacings * int24(uint24(acceptTickChangeInterval)));\n\n        if(_maxTick < _acceptMinTick) return _maxTick;\n        else return _acceptMinTick;\n    }\n\n    function getMiniTick(int24 tickSpacings) public pure returns (int24){\n           return (TickMath.MIN_TICK / tickSpacings) * tickSpacings ;\n    }\n\n    function getMaxTick(int24 tickSpacings) public pure  returns (int24){\n           return (TickMath.MAX_TICK / tickSpacings) * tickSpacings ;\n    }\n\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 amountIn,\n        address baseToken,\n        address quoteToken\n    ) public pure returns (uint256 amountOut) {\n        return OracleLibrary.getQuoteAtTick(tick, amountIn, baseToken, quoteToken);\n    }\n\n    /* === ======= internal ========== */\n\n    function increaseLiquidity(address l2Token, uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) internal\n    {\n        LibInitialLiquidityVault.PoolInfo storage info = poolInfo[l2Token];\n        require(info.lpToken > 0, \"It is not minted yet\");\n\n        (uint128 liquidity, uint256 amount0, uint256 amount1) = INonfungiblePositionManager(nonfungiblePositionManager).increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams(\n                info.lpToken, amount0Desired, amount1Desired, amount0Min, amount1Min, block.timestamp));\n\n        emit IncreasedLiquidityInVault(info.lpToken, liquidity, amount0, amount1);\n    }\n\n\n    function initialMint(address l2Token, uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) internal\n    {\n        LibInitialLiquidityVault.PoolInfo storage info = poolInfo[l2Token];\n\n        require(info.lpToken == 0, \"already minted\");\n        int24 tickLower = (TickMath.MIN_TICK / getTickSpacing(info.fee)) * getTickSpacing(info.fee) ;\n        int24 tickUpper = (TickMath.MAX_TICK / getTickSpacing(info.fee)) * getTickSpacing(info.fee) ;\n\n        (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        ) = INonfungiblePositionManager(nonfungiblePositionManager).mint(INonfungiblePositionManager.MintParams(\n                IIUniswapV3Pool(info.pool).token0(),\n                IIUniswapV3Pool(info.pool).token1(),\n                info.fee, tickLower, tickUpper,\n                amount0Desired, amount1Desired, amount0Min, amount1Min,\n                address(this), block.timestamp\n            )\n        );\n\n        require(tokenId > 0, \"zero tokenId\");\n\n        info.lpToken = tokenId;\n\n        emit InitialMintedInVault(l2Token, info.pool, tokenId, liquidity, amount0, amount1);\n    }\n\n\n    function checkBalance(address l2Token, uint256 tosBalance, uint256 tokenBalance) internal  {\n        require(IERC20(tos).balanceOf(address(this)) >= tosBalance, \"tos is insufficient.\");\n        require(IERC20(l2Token).balanceOf(address(this)) >= tokenBalance, \"token is insufficient.\");\n         if(tosBalance > IERC20(tos).allowance(address(this), nonfungiblePositionManager) ) {\n                require(IERC20(tos).approve(nonfungiblePositionManager, IERC20(tos).totalSupply()),\"TOS approve fail\");\n        }\n\n        if(tokenBalance > IERC20(l2Token).allowance(address(this), nonfungiblePositionManager) ) {\n            require(IERC20(l2Token).approve(nonfungiblePositionManager, IERC20(l2Token).totalSupply()),\"token approve fail\");\n        }\n    }\n\n    function viewVaultInfo(address l2Token) external view returns(LibInitialLiquidityVault.PoolInfo memory){\n\n        return poolInfo[l2Token];\n\n    }\n\n}\n"
    },
    "contracts/L2/vaults/L2InitialLiquidityVaultProxy.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"../../proxy/Proxy.sol\";\nimport { L2CustomVaultBaseStorage } from \"./L2CustomVaultBaseStorage.sol\";\nimport \"./L2InitialLiquidityVaultStorage.sol\";\n\ncontract L2InitialLiquidityVaultProxy is Proxy, L2CustomVaultBaseStorage, L2InitialLiquidityVaultStorage\n{\n\n}\n"
    },
    "contracts/L2/vaults/L2InitialLiquidityVaultStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { LibInitialLiquidityVault } from \"../../libraries/LibInitialLiquidityVault.sol\";\n\ncontract L2InitialLiquidityVaultStorage {\n    uint256 constant INITIAL_PRICE_DIV = 1e18;\n\n    address public ton;  //  ton token\n    address public tos;  //  tos token\n\n    address public uniswapV3Factory;\n    address public nonfungiblePositionManager;\n    uint32 public TWAP_PERIOD;\n    // int24 public tickIntervalMinimum;\n    int24 public acceptTickChangeInterval;\n    int24 public acceptSlippagePrice;\n    int24 public tickSpacings ;\n\n    // l2token - PoolInfo\n    mapping(address => LibInitialLiquidityVault.PoolInfo) public poolInfo;\n\n}\n"
    },
    "contracts/L2/vaults/L2NonScheduleVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./L2CustomVaultBase.sol\";\nimport \"./L2NonScheduleVaultStorage.sol\";\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/SafeERC20.sol\";\n\n/**\n * @title L2NonScheduleVault\n * @dev Vault that claims when the Vault admin wants it\n */\ncontract L2NonScheduleVault is L2CustomVaultBase, L2NonScheduleVaultStorage {\n    using SafeERC20 for IERC20;\n\n    event InitializedL2NonScheduleVault(\n            address l2Token,\n            string name,\n            uint256 totalAllocatedAmount\n        );\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /* ========== onlyOwner ========== */\n\n    /* ========== only L2ProjectManager ========== */\n    function initialize(\n        address l2Token,\n        string memory vaultName,\n        uint256 totalAllocatedAmount\n    )\n        external onlyInitializerOrVaultAdmin(l2Token)\n    {\n        bytes32 nameKey = keccak256(bytes(vaultName));\n        require(totalAllocatedAmount != 0 , \"wrong value\");\n\n        IERC20(l2Token).safeTransferFrom(l2ProjectManager, address(this), totalAllocatedAmount);\n\n        LibNonScheduleVault.VaultInfo storage info = vaultInfo[l2Token][nameKey];\n        info.totalAllocatedAmount = totalAllocatedAmount;\n\n        emit InitializedL2NonScheduleVault(l2Token, vaultName, totalAllocatedAmount);\n    }\n\n    /* ========== Anyone can vault admin of token ========== */\n    function claim(address l2Token, string memory vaultName, uint256 amount)\n        external onlyVaultAdminOfToken(l2Token)  nonZeroAddress(l2Token)  nonZero(amount)\n    {\n        bytes32 nameKey = keccak256(bytes(vaultName));\n        LibNonScheduleVault.VaultInfo memory info = vaultInfo[l2Token][nameKey];\n        require(amount <= (info.totalAllocatedAmount - info.totalClaimedAmount)\n            && amount <= IERC20(l2Token).balanceOf(address(this)), \"insufficient.\");\n        vaultInfo[l2Token][nameKey].totalClaimedAmount += amount;\n        IERC20(l2Token).safeTransfer(msg.sender, amount);\n        // emit Claimed(l2Token, msg.sender, amount);\n    }\n\n    /* ========== VIEW ========== */\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L2/vaults/L2NonScheduleVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { LibNonScheduleVault } from \"../../libraries/LibNonScheduleVault.sol\";\n/**\n * @title L2NonScheduleVaultStorage\n * @dev\n */\ncontract L2NonScheduleVaultStorage {\n\n    // l2token - keccak256 (vault name) - LibNonScheduleVault.VaultInfo\n    mapping(address => mapping(bytes32 => LibNonScheduleVault.VaultInfo)) public vaultInfo;\n\n\n}"
    },
    "contracts/L2/vaults/L2ScheduleVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./L2CustomVaultBase.sol\";\nimport \"./L2ScheduleVaultStorage.sol\";\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/SafeERC20.sol\";\nimport \"../../libraries/LibProject.sol\";\n\n/**\n * @title L2ScheduleVault\n * @dev Vaults that Vault Admins claim according to a schedule\n */\ncontract L2ScheduleVault is L2CustomVaultBase, L2ScheduleVaultStorage {\n    using SafeERC20 for IERC20;\n\n    event InitializedL2ScheduleVault(\n            address l2Token,\n            string name,\n            uint256 totalAllocatedAmount,\n            uint256 totalClaimCount,\n            uint256 firstClaimAmount,\n            uint32 firstClaimTime,\n            uint32 secondClaimTime,\n            uint32 roundInterval\n        );\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /* ========== onlyOwner ========== */\n\n\n    /* ========== only L2ProjectManager ========== */\n\n    function initialize(\n        address l2Token,\n        string memory vaultName,\n        LibProject.InitalParameterScheduleVault memory params\n    )\n        external onlyInitializerOrVaultAdmin(l2Token)\n    {\n        bytes32 nameKey = keccak256(bytes(vaultName));\n        require(vaultInfo[l2Token][nameKey].firstClaimTime == 0, \"already initialized\");\n        require(params.firstClaimTime > block.number, \"first claim time passed\");\n        require(params.totalAllocatedAmount != 0 && params.totalClaimCount != 0 && params.roundIntervalTime != 0, \"wrong value\");\n        if (params.totalClaimCount > 1) require(params.secondClaimTime > params.firstClaimTime, \"wrong the second claim time\");\n        require(params.totalAllocatedAmount > params.firstClaimAmount, \"wrong the first claim amount\");\n\n        IERC20(l2Token).safeTransferFrom(l2ProjectManager, address(this), params.totalAllocatedAmount);\n\n        LibScheduleVault.VaultInfo storage info = vaultInfo[l2Token][nameKey];\n        info.totalAllocatedAmount = params.totalAllocatedAmount;\n        info.totalClaimCount = params.totalClaimCount;\n        info.totalClaimedAmount = 0;\n        info.firstClaimAmount = params.firstClaimAmount;\n        info.firstClaimTime = params.firstClaimTime;\n        info.secondClaimTime = params.secondClaimTime;\n        info.roundInterval = params.roundIntervalTime;\n        info.latestClaimedRound = 0;\n\n        emit InitializedL2ScheduleVault(l2Token, vaultName, params.totalAllocatedAmount, params.totalClaimCount, params.firstClaimAmount, params.firstClaimTime, params.secondClaimTime, params.roundIntervalTime);\n    }\n\n    /* ========== Anyone can vault admin of token ========== */\n\n    function claim(address l2Token, string calldata vaultName)\n        external nonZeroAddress(l2Token) onlyVaultAdminOfToken(l2Token)\n    {\n        uint256 amount = availableClaimAmount(l2Token, vaultName);\n        require(amount <= IERC20(l2Token).balanceOf(address(this)), 'balance is insufficient');\n        IERC20(l2Token).safeTransfer(msg.sender, amount);\n\n        // emit Claimed(l2Token, msg.sender, amount);\n    }\n\n\n    /* ========== VIEW ========== */\n\n\n    function getCurrentRound(address l2Token, string calldata vaultName) public view returns (uint256 round){\n        bytes32 nameKey = keccak256(bytes(vaultName));\n        LibScheduleVault.VaultInfo memory info = vaultInfo[l2Token][nameKey];\n        if(info.firstClaimTime != 0 && info.firstClaimTime <= block.timestamp && block.timestamp < info.secondClaimTime) {\n            round = 1;\n        } else if(info.secondClaimTime <= block.timestamp) {\n            round = (block.timestamp - uint256(info.secondClaimTime)) / uint256(info.roundInterval) + 2;\n        }\n        if (round > info.totalClaimCount) round = info.totalClaimCount;\n    }\n\n    function availableClaimAmount(address l2Token, string calldata vaultName) public view returns (uint256 amount){\n        bytes32 nameKey = keccak256(bytes(vaultName));\n        LibScheduleVault.VaultInfo memory info = vaultInfo[l2Token][nameKey];\n        uint256 curRound = getCurrentRound(l2Token, vaultName);\n\n        if(info.latestClaimedRound < curRound) {\n            if (curRound == 1) {\n                amount = info.firstClaimAmount - info.totalClaimedAmount;\n            } else if (curRound < info.totalClaimCount) {\n                amount = (info.firstClaimAmount + ((info.totalAllocatedAmount - info.firstClaimAmount)/(info.totalClaimCount-1) * (curRound -1))) - info.totalClaimedAmount;\n            } else {\n                amount = info.totalAllocatedAmount - info.totalClaimedAmount;\n            }\n        }\n    }\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L2/vaults/L2ScheduleVaultProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./L2CustomVaultBaseProxy.sol\";\nimport \"./L2ScheduleVaultStorage.sol\";\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/SafeERC20.sol\";\n\n/**\n * @title L2ScheduleVaultProxy\n * @dev Vaults that Vault Admins claim according to a schedule\n */\ncontract L2ScheduleVaultProxy is L2CustomVaultBaseProxy, L2ScheduleVaultStorage {\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /* ========== onlyOwner ========== */\n\n\n    /* ========== only L2ProjectManager ========== */\n\n\n    /* ========== only VaultAdmin Of Token ========== */\n\n    /* ========== Anyone can vault admin of token ========== */\n\n\n    /* ========== VIEW ========== */\n\n\n\n    /* === ======= internal ========== */\n\n}"
    },
    "contracts/L2/vaults/L2ScheduleVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { LibScheduleVault } from \"../../libraries/LibScheduleVault.sol\";\n/**\n * @title L2ScheduleVaultStorage\n * @dev Vaults that Vault Admins claim according to a schedule\n */\ncontract L2ScheduleVaultStorage {\n\n    // l2token - keccak256 (vault name) - VaultInfo\n    mapping(address => mapping(bytes32 => LibScheduleVault.VaultInfo)) public vaultInfo;\n\n\n}"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.8.0;\n// pragma solidity >=0.5.0 <0.8.0;\n\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, 'toUint8_overflow');\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBool(bytes memory _bytes, uint256 _start) internal pure returns (bool) {\n        require(_start + 1 >= _start, 'toBool_overflow');\n        require(_bytes.length >= _start + 1, 'toBool_overflow');\n        bool tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_start + 2 >= _start, 'toUint16_overflow');\n        require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_start + 4 >= _start, 'toUint32_overflow');\n        require(_bytes.length >= _start + 4, 'toUint32_outOfBounds');\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_start + 32 >= _start, 'toUint256_overflow');\n        require(_bytes.length >= _start + 32, 'toUint256_outOfBounds');\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toInt256(bytes memory _bytes, uint256 _start) internal pure returns (int256) {\n        require(_start + 32 >= _start, 'toUint256_overflow');\n        require(_bytes.length >= _start + 32, 'toUint256_outOfBounds');\n        int256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/libraries/constants/Lib_DefaultValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Lib_DefaultValues\n */\nlibrary Lib_DefaultValues {\n    // The default x-domain message sender being set to a non-zero value makes\n    // deployment a bit more expensive, but in exchange the refund on every call to\n    // `relayMessage` by the L1 and L2 messengers will be higher.\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "contracts/libraries/LibInitialLiquidityVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibInitialLiquidityVault\n */\nlibrary LibInitialLiquidityVault {\n\n    struct PoolInfo {\n        address pool;\n        uint256 totalAllocatedAmount;\n        uint256 initialTosPrice;\n        uint256 initialTokenPrice;\n        uint256 lpToken;\n        uint32 startTime;\n        uint160 initSqrtPriceX96;\n        uint24  fee;\n        bool boolReadyToCreatePool;\n    }\n}"
    },
    "contracts/libraries/LibLockId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibLockId\n */\nlibrary LibLockId {\n\n    // LockId의 포인트 정보\n    struct Point {\n        int256 slope;\n        int256 bias;\n        uint256 timestamp; // 등록(시작)시점\n    }\n\n    // LockId의 잔고\n    struct LockedInfo {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 withdrawlTime;\n    }\n\n    // SyncInfo\n    struct SyncInfo {\n        int256 slope;\n        int256 bias;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n\n    struct SyncPacket {\n        uint256 lockId;\n        SyncInfo packet;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/libraries/LibLockId2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibLockIdTransferable\n */\nlibrary LibLockIdTransferable {\n\n    // LockId의 포인트 정보\n    struct Point {\n        int256 slope;\n        int256 bias;\n        uint256 timestamp; // 등록(시작)시점\n    }\n\n    // LockId의 잔고\n    struct LockedInfo {\n        uint256 start;\n        uint256 end;\n        uint256 unlockWeeks;\n        uint256 withdrawalTime;\n        uint256 amount;\n    }\n\n    struct SlopeChange {\n        int256 bias;\n        int256 slope;\n        uint256 changeTime;\n    }\n\n    // SyncInfo\n    struct SyncInfo {\n        int256 slope;\n        int256 bias;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n\n    struct SyncPacket {\n        uint256 lockId;\n        SyncInfo packet;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/libraries/LibLockIdTransferable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibLockIdTransferable\n */\nlibrary LibLockIdTransferable {\n\n    // LockId의 포인트 정보\n    struct Point {\n        int256 slope;\n        int256 bias;\n        uint256 timestamp; // 등록(시작)시점\n    }\n\n    // LockId의 잔고\n    struct LockedInfo {\n        uint256 start;\n        uint256 end;\n        uint256 unlockWeeks;\n        uint256 withdrawalTime;\n        uint256 amount;\n    }\n\n    struct SlopeChange {\n        int256 bias;\n        int256 slope;\n        uint256 changeTime;\n    }\n\n    // SyncInfo\n    struct SyncInfo {\n        int256 slope;\n        int256 bias;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n\n    struct SyncPacket {\n        uint256 lockId;\n        SyncInfo packet;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/libraries/LibLockTOS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibLockTOS {\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 timestamp;\n    }\n\n    struct LockedBalance {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        bool withdrawn;\n    }\n\n    struct SlopeChange {\n        int256 bias;\n        int256 slope;\n        uint256 changeTime;\n    }\n\n    struct LockedBalanceInfo {\n        uint256 id;\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 balance;\n    }\n}\n"
    },
    "contracts/libraries/LibLockTOSv2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibLockTOSv2 {\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 timestamp;\n    }\n\n    struct LockedBalance {\n        address owner;\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 withdrawalTime;\n    }\n\n    struct SlopeChange {\n        int256 bias;\n        int256 slope;\n        uint256 changeTime;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n}\n"
    },
    "contracts/libraries/LibNonScheduleVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibNonScheduleVault\n */\nlibrary LibNonScheduleVault {\n\n    struct VaultInfo {\n        uint256 totalAllocatedAmount;   // Token allocation amount\n        uint256 totalClaimedAmount;     // Total amount claimed\n    }\n}"
    },
    "contracts/libraries/LibProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface AddressManagerI {\n    function getAddress(string memory _name) external view returns (address);\n}\n\n/**\n * @title LibProject\n */\nlibrary LibProject {\n\n    enum TOKEN_TYPE {\n        ERC20_A,\n        ERC20_B,\n        ERC20_C,\n        ERC20_D,\n        NONE\n    }\n\n    enum L2_TYPE {\n        TOKAMAL_OPTIMISM,\n        TOKAMAL_ZKEVM,\n        NONE\n    }\n\n    struct ProjectInfo {\n        address projectOwner;\n        address tokenOwner;\n        address l1Token;\n        address l2Token;\n        address addressManager;\n        uint256 initialTotalSupply;\n        uint8 tokenType;\n        uint8 l2Type;\n        string projectName;\n    }\n\n    struct L2Info {\n        address l2TokenFactory;\n        address l2ProjectManager;\n        uint32 depositMinGasLimit;\n        uint32 sendMsgMinGasLimit;\n    }\n\n    struct L2ProjectInfo {\n        uint256 projectId;\n        address projectOwner;\n        address l1Token;\n        address l2Token;\n        string projectName;\n    }\n\n    struct TokamakVaults {\n        InitalParameterPublicSale publicSaleParams;\n        InitalParameterInitialLiquidityVault initialVaultParams;\n        InitalParameterLiquidityRewardVault rewardParams;\n        InitalParameterScheduleVault tosAirdropParams;\n        InitalParameterScheduleVault tonAirdropParams;\n    }\n\n    struct InitalParameterPublicSale {\n        InitalParameterPublicSaleVault vaultParams;\n        InitalParameterPublicSaleClaim claimParams;\n    }\n\n    struct InitalParameterPublicSaleVault {\n        uint256 stosTier1;\n        uint256 stosTier2;\n        uint256 stosTier3;\n        uint256 stosTier4;\n        uint256 tier1Percents;\n        uint256 tier2Percents;\n        uint256 tier3Percents;\n        uint256 tier4Percents;\n        uint256 total1roundSaleAmount;\n        uint256 total2roundSaleAmount;\n        uint256 saleTokenPrice;\n        uint256 payTokenPrice;\n        uint256 hardcapAmount;\n        uint256 changeTOSPercent;\n        uint256 startWhiteTime;\n        uint256 endWhiteTime;\n        uint256 start1roundTime;\n        uint256 end1roundTime;\n        uint256 snapshotTime;\n        uint256 start2roundTime;\n        uint256 end2roundTime;\n        uint256 claimCounts;\n    }\n\n    struct InitalParameterPublicSaleClaim {\n        uint256[] claimTimes;\n        uint256[] claimPercents;\n    }\n\n    struct InitalParameterInitialLiquidityVault {\n        uint256 totalAllocatedAmount;\n        uint256 tosPrice;\n        uint256 tokenPrice;\n        uint256 initSqrtPrice;\n        uint32 startTime;\n        uint16 fee;\n    }\n\n    struct InitalParameterLiquidityRewardVault {\n        address poolAddress;\n        InitalParameterScheduleVault params;\n    }\n\n    struct InitalParameterSchedule {\n        string vaultName;\n        InitalParameterScheduleVault params;\n    }\n\n    struct InitalParameterScheduleVault {\n        uint256 totalAllocatedAmount;\n        uint256 totalClaimCount;\n        uint256 firstClaimAmount;\n        uint32 firstClaimTime;\n        uint32 secondClaimTime;\n        uint32 roundIntervalTime;\n    }\n\n    struct InitalParameterNonScheduleVault {\n        string vaultName;\n        uint256 totalAllocatedAmount;\n    }\n\n    function getL1CommunicationMessenger(address addressManager) external view returns(address _address) {\n        if (addressManager == address(0)) return address(0);\n        try\n            AddressManagerI(addressManager).getAddress('Proxy__OVM_L1CrossDomainMessenger') returns (address a) {\n                _address = a;\n        } catch (bytes memory ) {\n            _address = address(0);\n        }\n    }\n\n    function getL1Bridge(address addressManager) external view returns(address _address) {\n        if (addressManager == address(0)) return address(0);\n        try\n            AddressManagerI(addressManager).getAddress('Proxy__OVM_L1StandardBridge') returns (address a) {\n                _address = a;\n        } catch (bytes memory ) {\n            _address = address(0);\n        }\n    }\n\n    function validateTokamakVaults(TokamakVaults memory tokamakVaults)\n    public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        // if ((tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount\n        //     +tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount) == 0 ||\n        //     tokamakVaults.initialVaultParams.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.rewardParams.params.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.tosAirdropParams.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.tonAirdropParams.totalAllocatedAmount == 0\n        // ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.initialVaultParams.tosPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.tokenPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.initSqrtPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.startTime == 0 ||\n        //     tokamakVaults.initialVaultParams.fee == 0) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.rewardParams.poolAddress == address(0) ||\n        //     tokamakVaults.rewardParams.params.totalClaimCount == 0 ||\n        //     tokamakVaults.rewardParams.params.firstClaimAmount == 0 ||\n        //     tokamakVaults.rewardParams.params.firstClaimTime == 0 ||\n        //     tokamakVaults.rewardParams.params.secondClaimTime == 0 ||\n        //     tokamakVaults.rewardParams.params.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.tosAirdropParams.totalClaimCount == 0 ||\n        //     tokamakVaults.tosAirdropParams.firstClaimAmount == 0 ||\n        //     tokamakVaults.tosAirdropParams.firstClaimTime == 0 ||\n        //     tokamakVaults.tosAirdropParams.secondClaimTime == 0 ||\n        //     tokamakVaults.tosAirdropParams.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.tonAirdropParams.totalClaimCount == 0 ||\n        //     tokamakVaults.tonAirdropParams.firstClaimAmount == 0 ||\n        //     tokamakVaults.tonAirdropParams.firstClaimTime == 0 ||\n        //     tokamakVaults.tonAirdropParams.secondClaimTime == 0 ||\n        //     tokamakVaults.tonAirdropParams.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n\n        totalAmount = tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount +\n                    tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount +\n                    tokamakVaults.initialVaultParams.totalAllocatedAmount +\n                    tokamakVaults.rewardParams.params.totalAllocatedAmount +\n                    tokamakVaults.tosAirdropParams.totalAllocatedAmount +\n                    tokamakVaults.tonAirdropParams.totalAllocatedAmount ;\n\n        if (totalAmount == 0) return (boolValidate, totalAmount);\n\n        boolValidate = true;\n    }\n\n    function validateScheduleVault(\n        InitalParameterSchedule[] memory customs\n    ) public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        if (customs.length != 0) {\n            for(uint256 i = 0; i < customs.length; i++){\n                if (customs[i].params.totalAllocatedAmount == 0 ||\n                    customs[i].params.totalClaimCount == 0 ||\n                    customs[i].params.firstClaimAmount == 0 ||\n                    customs[i].params.firstClaimTime == 0 ||\n                    customs[i].params.secondClaimTime == 0 ||\n                    customs[i].params.roundIntervalTime == 0\n                    ) return (boolValidate, totalAmount);\n\n                totalAmount += customs[i].params.totalAllocatedAmount;\n            }\n            boolValidate = true;\n        }\n    }\n\n    function validateNonScheduleVault(\n        InitalParameterNonScheduleVault[] memory customs\n    ) public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        if (customs.length != 0) {\n            for(uint256 i =0 ; i < customs.length; i++){\n                if (customs[i].totalAllocatedAmount == 0) return (boolValidate, totalAmount);\n                totalAmount += customs[i].totalAllocatedAmount;\n            }\n            boolValidate = true;\n        }\n    }\n\n}\n"
    },
    "contracts/libraries/LibRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibRegister\n */\nlibrary LibRegister {\n\n    struct  TonBalance {\n        uint256 balance;\n        uint256 refactoredCount;\n        uint256 remain;\n    }\n\n    struct  TonBalanceOfLayer {\n        address coinage;\n        TonBalance staked;\n    }\n\n\n    // SyncInfo\n    struct TonSyncInfo {\n        TonBalanceOfLayer layer;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n}"
    },
    "contracts/libraries/LibScheduleVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibScheduleVault\n */\nlibrary LibScheduleVault {\n\n    struct VaultInfo {\n        uint256 totalAllocatedAmount;   // Token allocation amount\n        uint256 totalClaimCount;        // total number of claims\n        uint256 totalClaimedAmount;     // Total amount claimed\n        uint256 firstClaimAmount;       // first claim amount\n        uint32 firstClaimTime;          // first claim time\n        uint32 secondClaimTime;         // second claim time\n        uint32 roundInterval;    // round interval (seconds)\n        uint32 latestClaimedRound;      // the latest claimed round\n    }\n}"
    },
    "contracts/libraries/LibStos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibStos\n */\nlibrary LibStos {\n\n    // account - l2Index\n    struct StosInfo {\n        uint32 syncTime;\n        uint256 amount;\n    }\n\n    // l2Index\n    struct L2Info {\n        address l1Messanger;\n        address l2TotalStos;\n        string name;\n    }\n\n}"
    },
    "contracts/libraries/LibUniversalStos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibUniversalStos\n */\nlibrary LibUniversalStos {\n\n    struct LayerInfo {\n        address messanger;\n        string name;\n    }\n\n}"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/proxy/Proxy.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"./ProxyStorage.sol\";\nimport { AccessibleCommon } from \"../common/AccessibleCommon.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IProxyEvent.sol\";\nimport \"../interfaces/IProxyAction.sol\";\n// import \"hardhat/console.sol\";\n\ncontract Proxy is ProxyStorage, AccessibleCommon, IProxyEvent, IProxyAction\n{\n\n    /* ========== DEPENDENCIES ========== */\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor () {\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n\n    /* ========== onlyOwner ========== */\n\n    /// @inheritdoc IProxyAction\n    function setProxyPause(bool _pause) external onlyOwner {\n        pauseProxy = _pause;\n    }\n\n    /// @notice Set implementation contract\n    /// @param impl New implementation contract address\n    function upgradeTo(address impl) external onlyOwner {\n        require(impl != address(0), \"input is zero\");\n        require(\n            _implementation2(0) != impl,\n            \"same addr\"\n        );\n        _setImplementation2(impl, 0, true);\n        emit Upgraded(impl);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external override onlyOwner {\n        _setImplementation2(newImplementation, _index, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        public override onlyOwner\n    {\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) public override onlyOwner {\n        require(\n            _selectors.length > 0,\n            \"Proxy: _selectors's size is zero\"\n        );\n        require(aliveImplementation[_imp], \"Proxy: _imp is not alive\");\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            require(\n                selectorImplementation[_selectors[i]] != _imp,\n                \"LiquidityVaultProxy: same imp\"\n            );\n            selectorImplementation[_selectors[i]] = _imp;\n            emit SetSelectorImplementation(_selectors[i], _imp);\n        }\n    }\n\n    /* ========== Anyone can   ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    /// @dev returns the implementation\n    function implementation() external view returns (address) {\n        return _implementation2(0);\n    }\n\n    /// @inheritdoc IProxyAction\n    function implementation2(uint256 _index) external override view returns (address) {\n        return _implementation2(_index);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function getSelectorImplementation2(bytes4 _selector)\n        public override\n        view\n        returns (address impl)\n    {\n        if (selectorImplementation[_selector] == address(0))\n            return proxyImplementation[0];\n        else if (aliveImplementation[selectorImplementation[_selector]]){\n            return selectorImplementation[_selector];\n        }\n        else return proxyImplementation[0];\n    }\n\n\n    /// @dev receive ether\n    receive() external payable {\n        revert(\"cannot receive Ether\");\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    fallback() external payable {\n        _fallback();\n    }\n\n    /* === ======= internal ========== */\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return impl address of the implementation\n    function _implementation2(uint256 _index)\n        internal\n        view\n        returns (address impl)\n    {\n        return proxyImplementation[_index];\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    function _fallback() internal {\n        address _impl = getSelectorImplementation2(msg.sig);\n\n        require(\n            _impl != address(0) && !pauseProxy,\n            \"Proxy: impl OR proxy is false\"\n        );\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index of proxy\n    /// @param _alive alive status\n    function _setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Proxy: not contract address\"\n        );\n        if (_alive) proxyImplementation[_index] = newImplementation;\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function _setAliveImplementation2(address newImplementation, bool _alive)\n        internal\n    {\n        aliveImplementation[newImplementation] = _alive;\n        emit SetAliveImplementation(newImplementation, _alive);\n    }\n\n}"
    },
    "contracts/proxy/Proxy2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"./ProxyStorage2.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IProxyEvent.sol\";\nimport \"../interfaces/IProxyAction.sol\";\n// import \"hardhat/console.sol\";\n\ncontract Proxy2 is ProxyStorage2, IProxyEvent, IProxyAction\n{\n\n    /* ========== DEPENDENCIES ========== */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"not owner\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /* ========== onlyOwner ========== */\n\n    function renounceOwnership() external onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /// @inheritdoc IProxyAction\n    function setProxyPause(bool _pause) external onlyOwner {\n        pauseProxy = _pause;\n    }\n\n    /// @notice Set implementation contract\n    /// @param impl New implementation contract address\n    function upgradeTo(address impl) external onlyOwner {\n        require(impl != address(0), \"input is zero\");\n        require(\n            _implementation2(0) != impl,\n            \"same addr\"\n        );\n        _setImplementation2(impl, 0, true);\n        emit Upgraded(impl);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        public\n        payable\n        virtual\n        onlyOwner\n        returns (bytes memory)\n    {\n        // _setImplementation(_implementation);\n        _setImplementation2(_implementation, 0, true);\n\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /// @inheritdoc IProxyAction\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external override onlyOwner {\n        _setImplementation2(newImplementation, _index, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        public override onlyOwner\n    {\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) public override onlyOwner {\n        require(\n            _selectors.length > 0,\n            \"Proxy: _selectors's size is zero\"\n        );\n        require(aliveImplementation[_imp], \"Proxy: _imp is not alive\");\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            require(\n                selectorImplementation[_selectors[i]] != _imp,\n                \"LiquidityVaultProxy: same imp\"\n            );\n            selectorImplementation[_selectors[i]] = _imp;\n            emit SetSelectorImplementation(_selectors[i], _imp);\n        }\n    }\n\n    /* ========== Anyone can   ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    /// @dev returns the implementation\n    function implementation() external view returns (address) {\n        return _implementation2(0);\n    }\n\n    /// @inheritdoc IProxyAction\n    function implementation2(uint256 _index) external override view returns (address) {\n        return _implementation2(_index);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function getSelectorImplementation2(bytes4 _selector)\n        public override\n        view\n        returns (address impl)\n    {\n        if (selectorImplementation[_selector] == address(0))\n            return proxyImplementation[0];\n        else if (aliveImplementation[selectorImplementation[_selector]]){\n            return selectorImplementation[_selector];\n        }\n        else return proxyImplementation[0];\n    }\n\n\n    /// @dev receive ether\n    receive() external payable {\n        revert(\"cannot receive Ether\");\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    fallback() external payable {\n        _fallback();\n    }\n\n    /* === ======= internal ========== */\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return impl address of the implementation\n    function _implementation2(uint256 _index)\n        internal\n        view\n        returns (address impl)\n    {\n        return proxyImplementation[_index];\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    function _fallback() internal {\n        address _impl = getSelectorImplementation2(msg.sig);\n\n        require(\n            _impl != address(0) && !pauseProxy,\n            \"Proxy: impl OR proxy is false\"\n        );\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index of proxy\n    /// @param _alive alive status\n    function _setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Proxy: not contract address\"\n        );\n        if (_alive) proxyImplementation[_index] = newImplementation;\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function _setAliveImplementation2(address newImplementation, bool _alive)\n        internal\n    {\n        aliveImplementation[newImplementation] = _alive;\n        emit SetAliveImplementation(newImplementation, _alive);\n    }\n\n}"
    },
    "contracts/proxy/ProxyStorage.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ncontract ProxyStorage  {\n\n    bool public pauseProxy;\n\n    mapping(uint256 => address) public proxyImplementation;\n    mapping(address => bool) public aliveImplementation;\n    mapping(bytes4 => address) public selectorImplementation;\n\n}"
    },
    "contracts/proxy/ProxyStorage2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ncontract ProxyStorage2  {\n\n    address public _owner;\n    bool public pauseProxy;\n\n    mapping(uint256 => address) public proxyImplementation;\n    mapping(address => bool) public aliveImplementation;\n    mapping(bytes4 => address) public selectorImplementation;\n\n\n}"
    },
    "contracts/standards/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.4;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "contracts/standards/IL2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IL2StandardERC20 is IERC20, IERC165 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n"
    },
    "contracts/standards/L2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IL2StandardERC20.sol\";\n\ncontract L2StandardERC20 is IL2StandardERC20, ERC20 {\n    address public override l1Token;\n    address public l2Bridge;\n\n    /**\n     * @param _l2Bridge Address of the L2 standard bridge.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    constructor(\n        address _l2Bridge,\n        address _l1Token,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        l1Token = _l1Token;\n        l2Bridge = _l2Bridge;\n    }\n\n    modifier onlyL2Bridge() {\n        require(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure override returns (bool) {\n        bytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\n        bytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^\n            IL2StandardERC20.mint.selector ^\n            IL2StandardERC20.burn.selector;\n        return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual override onlyL2Bridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual override onlyL2Bridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n}\n"
    },
    "contracts/stos/ERC165P.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IIERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165P is IIERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) internal _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}"
    },
    "contracts/stos/LockIdNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./LockIdNFTStorage.sol\";\nimport \"./LockIdStorage.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LockIdNFT is ProxyStorage2, LockIdNFTStorage, LockIdStorage, IERC721, IERC721Metadata, IERC721Enumerable {\n    // using SafeMath for uint256;\n    using Address for address;\n    using Strings for uint256;\n\n    event LockCreated(address account, uint256 lockId, uint256 amount, uint256 unlockTime);\n    event LockDeposited(address account, uint256 lockId, uint256 value);\n    event IncreasedLock(address account, uint256 lockId, uint256 value, uint256 unlockTime);\n\n    modifier nonZero(uint256 _val) {\n        require(_val != 0, \"zero value\");\n        _;\n    }\n\n    constructor (\n        string memory name_, string memory symbol_, address managerAddress,\n        uint256 epochUnit_,\n        uint256 maxTime_,\n        address tosAddress\n        ) {\n\n        _manager = managerAddress;\n        _name = name_;\n        _symbol = symbol_;\n        epochUnit = epochUnit_;\n        maxTime = maxTime_;\n        tos = tosAddress;\n    }\n\n    /*** External onlyManager ***/\n\n    function setBaseURI(string memory baseURI_) public onlyManager ifFree virtual {\n       _setBaseURI(baseURI_);\n    }\n\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public onlyManager ifFree virtual {\n       _setTokenURI(tokenId, _tokenURI);\n    }\n\n    function setTokenURI(uint256[] memory tokenIds, string[] memory _tokenURIs) public onlyManager ifFree virtual {\n        require(tokenIds.length != 0 && tokenIds.length == _tokenURIs.length, \"wrong length\");\n        for(uint256 i = 0; i < tokenIds.length; i++){\n            _setTokenURI(tokenIds[i], _tokenURIs[i]);\n        }\n    }\n\n    /*** External ***/\n\n    function createLock(uint256 _amount, uint256 _unlockWeeks)\n        public nonZero(_amount) nonZero(_unlockWeeks)\n        returns (uint256 lockId)\n    {\n        uint256 unlockTime = (block.timestamp + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n        require(unlockTime - block.timestamp <= maxTime, \"Max unlock time is exceeded\" );\n\n        lockId = ++maxTokenId;\n        _safeMint(msg.sender, lockId);\n        _deposit(msg.sender, lockId, _amount, unlockTime);\n\n        emit LockCreated(msg.sender, lockId, _amount, unlockTime);\n    }\n\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) public nonZero(_value) {\n        require(_exists(_lockId), \"nonexistent token\");\n        require(_tokenOwner[_lockId] == _addr && _addr != address(0), \"not owner\");\n\n        LibLockId.LockedInfo memory lock = lockIdInfos[_lockId];\n        require(lock.withdrawlTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        _deposit(_addr, _lockId, _value, 0);\n        emit LockDeposited(msg.sender, _lockId, _value);\n    }\n\n    function increaseLock(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockWeeks\n    ) public {\n        require(_value != 0 || _unlockWeeks != 0, \"zero value\");\n        require(_exists(_lockId), \"nonexistent token\");\n        require(_tokenOwner[_lockId] == _addr && _addr != address(0), \"not owner\");\n\n        LibLockId.LockedInfo memory lock = lockIdInfos[_lockId];\n        require(lock.start > 0, \"not exist\");\n        require(lock.withdrawlTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n        uint256 unlockTime = 0;\n        if (_unlockWeeks > 0) {\n            unlockTime = (lock.end + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n            require(unlockTime - block.timestamp < maxTime, \"Max unlock time is exceeded\");\n        }\n        _deposit(_addr, _lockId, _value, unlockTime);\n        emit IncreasedLock(msg.sender, _lockId, _value, unlockTime);\n    }\n\n    /*** Public ***/\n    function approve(address to, uint256 tokenId) public virtual override {\n\n    }\n\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n\n    }\n\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n\n    }\n\n    /*** View ***/\n\n    /**\n     * @dev Overrides supportsInterface\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165P) returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    // for opensea manager\n    // function owner() public view virtual returns (address) {\n    //     return _manager;\n    // }\n\n    // function isOwner(address addr) public view virtual returns (bool) {\n    //     if(_manager == addr) return true;\n    //     else return false;\n    // }\n\n    function manager() public view virtual returns (address) {\n        return _manager;\n    }\n\n    function isManager(address addr) public view virtual returns (bool) {\n\n        if(_manager == addr) return true;\n        else return false;\n    }\n\n    function balanceOf(address owner_) public view override returns (uint256) {\n        require(owner_ != address(0), \"LockIdNFT: balance query for the zero address\");\n\n        return _ownedTokensCount[owner_];\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        address owner_ = _tokenOwner[tokenId];\n        require(owner_ != address(0), \"LockIdNFT: owner query for nonexistent token\");\n\n        return owner_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"LockIdNFT: nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    function tokenOfOwnerByIndex(address owner_, uint256 index) public view override returns (uint256) {\n        require(index < balanceOf(owner_), \"LockIdNFT: owner index out of bounds\");\n        return _ownedTokens[owner_][index];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        require(index < totalSupply(), \"LockIdNFT: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function allTokens() public view returns (uint256[] memory) {\n        return _allTokens;\n    }\n\n    function tokensOfOwner(address owner_) public view returns (uint256[] memory) {\n        return _ownedTokens[owner_];\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"LockIdNFT: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner_, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner_][operator];\n    }\n\n    /*** internal ***/\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner_ = _tokenOwner[tokenId];\n        return owner_ != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"LockIdNFT: operator query for nonexistent token\");\n        address owner_ = ownerOf(tokenId);\n        return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        require(tokenId != 0, \"not allowed tokenId\");\n        _mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"LockIdNFT: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"LockIdNFT: mint to the zero address\");\n        require(!_exists(tokenId), \"LockIdNFT: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        _tokenOwner[tokenId] = to;\n        unchecked {\n            _ownedTokensCount[to] += 1;\n        }\n\n        emit Transfer(address(0), to, tokenId);\n         _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length-1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        //_ownedTokens[from].length--;\n        _ownedTokens[from].pop();\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length-1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        //_allTokens.length--;\n        _allTokens.pop();\n        _allTokensIndex[tokenId] = 0;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            msg.sender,\n            from,\n            tokenId,\n            _data\n        ), \"LockIdNFT: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n\n     /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {\n\n    }\n\n     /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {\n\n    }\n\n\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"TitanNFT: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /// @dev Deposit\n    function _deposit(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockTime\n    ) internal ifFree {\n\n        /////////////////////////////////////////////////\n        // update base LockedInfo 락 기본 정보\n        LibLockId.LockedInfo memory preInfo = lockIdInfos[_lockId];\n        LibLockId.LockedInfo memory afterInfo = LibLockId.LockedInfo({\n                start: preInfo.start,\n                end: preInfo.end,\n                amount: preInfo.amount + _value,\n                withdrawlTime: 0\n            });\n\n        if (_unlockTime > 0)  afterInfo.end = _unlockTime;\n        if (afterInfo.start == 0)  afterInfo.start = block.timestamp;\n\n        /////////////////////////////////////////////////\n        // 기본정보 반영\n        lockIdInfos[_lockId] = afterInfo;\n\n        /////////////////////////////////////////////////\n        // add point of LockId , 가장 최근의 포인트 (모두 누적 반영)\n        uint256 lenOfId = pointHistoryByLockId[_lockId].length;\n        LibLockId.Point memory pointByIdOld ;\n        LibLockId.Point memory pointByIdNew = LibLockId.Point({\n            slope: int256(afterInfo.amount * MULTIPLIER / maxTime),\n            bias: 0,\n            timestamp : block.timestamp\n        });\n        pointByIdNew.bias = pointByIdNew.slope * int256(afterInfo.end - block.timestamp);\n\n        if(lenOfId > 0) pointByIdOld = pointHistoryByLockId[_lockId][lenOfId-1];\n        else {\n            pointByIdOld = LibLockId.Point({\n                slope: 0,\n                bias: 0,\n                timestamp : block.timestamp\n            });\n        }\n\n        /////////////////////////////////////////////////\n        // 변경된 값\n        LibLockId.Point memory pointByIdChange = LibLockId.Point({\n            slope: pointByIdNew.slope - pointByIdOld.slope,\n            bias: pointByIdNew.bias - pointByIdOld.bias,\n            timestamp : block.timestamp\n        });\n\n        /////////////////////////////////////////////////\n        // 락아이디 반영\n        pointHistoryByLockId[_lockId].push(pointByIdNew);\n\n        /////////////////////////////////////////////////\n        // point history based time\n        // deposit하면 다가오는 목요일 시간에 누적되어야 한다..총 금액이 다음 타임인덱스에 반영된다고 보아야 한다.\n        uint256 nextTimeIndexOfTotalPoint =  nextTimeIndex(block.timestamp);\n\n        uint256 len = pointHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n        LibLockId.Point memory pointLast ; // 가장 최근의 point\n\n        if (len == 0 ) {\n            // 가장 최근 인덱스\n            pointLast = pointOfLastTimeIndex();\n        } else {\n            pointLast = pointHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n        }\n\n        LibLockId.Point memory pointNew = LibLockId.Point({\n            slope: pointLast.slope + pointByIdChange.slope,\n            bias: pointLast.bias + pointByIdChange.bias,\n            timestamp : block.timestamp\n        });\n\n        /////////////////////////////////////////////////\n        // 총계 집계를 위한 락아이디 반영\n        pointHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n\n        if(!indexCheckOfTimeset[nextTimeIndexOfTotalPoint]) {\n            indexCheckOfTimeset[nextTimeIndexOfTotalPoint] = true;\n            indexOfTimeset.push(nextTimeIndexOfTotalPoint);\n        }\n\n        // Transfer TOS\n        // if(_value != 0)\n        //     require(\n        //         IERC20(tos).transferFrom(msg.sender, address(this), _value),\n        //         \"LockIdNFT: fail transferFrom\"\n        //     );\n    }\n\n    function nextTimeIndex(uint256 _stime) public view returns(uint256) {\n        return (_stime +  epochUnit / epochUnit * epochUnit);\n    }\n\n    function lastIndexOfTimeset() public view returns(uint256 index) {\n        index = (indexOfTimeset.length != 0 ? indexOfTimeset[indexOfTimeset.length - 1]:0);\n    }\n\n    /// 가장 최근의 포인트\n    function pointOfLastTimeIndex() public view returns(LibLockId.Point memory) {\n        return lastPointOfTimeIndex(lastIndexOfTimeset());\n    }\n\n    /// 해당 타임의 가장 최신 포인트\n    function lastPointOfTimeIndex(uint256 _index) public view returns(LibLockId.Point memory) {\n        if (_index != 0) {\n            LibLockId.Point[] memory points = pointHistoryByWeek[_index];\n\n            if (points.length != 0) {\n                return LibLockId.Point({\n                    slope: points[points.length-1].slope,\n                    bias: points[points.length-1].bias,\n                    timestamp: points[points.length-1].timestamp\n                });\n            } else {\n                return LibLockId.Point({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0\n                });\n            }\n        } else return LibLockId.Point({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0\n                });\n    }\n\n    // 특정 락아아디의 전체 포인트 리스트\n    function pointHistoryOfId(uint256 _lockId)\n        public\n        view\n        returns (LibLockId.Point[] memory)\n    {\n        return pointHistoryByLockId[_lockId];\n    }\n\n\n    /// 특정 타임인덱스의 전체 포인트 리스트\n    function pointHistoryOfTimeIndex(uint256 _timeIndex)\n        public\n        view\n        returns (LibLockId.Point[] memory)\n    {\n        return pointHistoryByWeek[_timeIndex];\n    }\n\n    /// 특정 계정이 소유한 stos를 가져옴.\n    function balanceOfLock(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance += balanceOfLock(locks[i]);\n        }\n    }\n\n    function balanceOfLockAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance += balanceOfLockAt(locks[i], _timestamp);\n        }\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLock(uint256 _lockId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        uint256 len = pointHistoryByLockId[_lockId].length;\n        amount = (len == 0? 0: balanceOfPoint(pointHistoryByLockId[_lockId][len - 1], block.timestamp));\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        (bool success, LibLockId.Point memory point) = _findClosestPoint(pointHistoryByLockId[_lockId], _timestamp);\n        amount = (!success? 0: balanceOfPoint(point, _timestamp));\n    }\n\n    /// 현재 시간의 총 stos\n    function totalSupplyLocks()\n        public\n        view\n        returns (uint256 amount)\n    {\n       amount = balanceOfPoint(pointOfLastTimeIndex(), block.timestamp);\n    }\n\n    function totalSupplyLocksAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 해당 타임에 맞는 타임인덱스\n        (bool success, uint256 timeindex) = _findClosestTimeindex(_timestamp);\n        if(!success) return 0;\n        (bool success1, LibLockId.Point memory point) = _findClosestPoint(pointHistoryByWeek[timeindex], _timestamp);\n        if(!success1) return 0;\n        amount = balanceOfPoint(point, _timestamp);\n    }\n\n    function balanceOfPoint(LibLockId.Point memory point, uint256 timestamp)\n        public\n        pure\n        returns (uint256)\n    {\n        if(timestamp < point.timestamp) return 0;\n        int256 currentBias = point.slope * int256(timestamp - point.timestamp);\n        return\n            uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n    }\n\n    function allIndexOfTimes() public view returns(uint256[] memory){\n        return indexOfTimeset;\n    }\n\n    function _findClosestPoint(\n        LibLockId.Point[] storage _history,\n        uint256 _timestamp\n    ) internal view returns(bool success, LibLockId.Point memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    function _findClosestTimeindex(\n        uint256 _timestamp\n    ) internal view returns(bool success, uint256 timeindex) {\n        uint256 totalLen = indexOfTimeset.length;\n        uint256 timeIndexKey =  (_timestamp + epochUnit) * epochUnit / epochUnit ;\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (indexOfTimeset[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (indexOfTimeset[left] <= timeIndexKey) {\n            return (true, indexOfTimeset[left]);\n        }\n        return (false, 0);\n    }\n}\n"
    },
    "contracts/stos/LockIdNftForRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./LockIdRegisterStorage1.sol\";\nimport \"./LockIdRegisterStorage2.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LockIdNftForRegister is\n    ProxyStorage2,\n    LockIdRegisterStorage1,\n    LockIdRegisterStorage2,\n    IERC721, IERC721Metadata, IERC721Enumerable\n{\n    // using SafeMath for uint256;\n    using Address for address;\n    using Strings for uint256;\n\n    modifier nonZero(uint256 _val) {\n        require(_val != 0, \"zero value\");\n        _;\n    }\n\n    constructor (\n        string memory name_, string memory symbol_, address managerAddress,\n        uint256 epochUnit_,\n        uint256 maxTime_\n        ) {\n\n        _manager = managerAddress;\n        _name = name_;\n        _symbol = symbol_;\n        epochUnit = epochUnit_;\n        maxTime = maxTime_;\n    }\n\n    /*** External onlyManager ***/\n\n    /*** External ***/\n    function register(\n        address account,\n        LibLockId.SyncPacket[] memory packets\n        )\n        public onlyManager\n    {\n        require(packets.length !=0, 'no data');\n        for(uint256 i = 0; i < packets.length; i++){\n            if(!_exists(packets[i].lockId)) {\n                _safeMint(account, packets[i].lockId);\n            }\n            _deposit(account, packets[i].lockId, packets[i].packet);\n        }\n    }\n\n    /*** Public ***/\n    function approve(address to, uint256 tokenId) public virtual override {\n\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n\n    }\n\n    /*** View ***/\n\n    // /**\n    //  * @dev Overrides supportsInterface\n    //  */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165P) returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    function manager() public view virtual returns (address) {\n        return _manager;\n    }\n\n    function isManager(address addr) public view virtual returns (bool) {\n\n        if(_manager == addr) return true;\n        else return false;\n    }\n\n    function balanceOf(address owner_) public view override returns (uint256) {\n        require(owner_ != address(0), \"LockIdNFT: balance query for the zero address\");\n\n        return _ownedTokensCount[owner_];\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        address owner_ = _tokenOwner[tokenId];\n        require(owner_ != address(0), \"LockIdNFT: owner query for nonexistent token\");\n\n        return owner_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        return '';\n    }\n\n    function tokenOfOwnerByIndex(address owner_, uint256 index) public view override returns (uint256) {\n        require(index < balanceOf(owner_), \"LockIdNFT: owner index out of bounds\");\n        return _ownedTokens[owner_][index];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        require(index < totalSupply(), \"LockIdNFT: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function allTokens() public view returns (uint256[] memory) {\n        return _allTokens;\n    }\n\n    function tokensOfOwner(address owner_) public view returns (uint256[] memory) {\n        return _ownedTokens[owner_];\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n    }\n\n    function isApprovedForAll(address owner_, address operator) public view virtual override returns (bool) {\n    }\n\n    /*** internal ***/\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner_ = _tokenOwner[tokenId];\n        return owner_ != address(0);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        require(tokenId != 0, \"not allowed tokenId\");\n        _mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"LockIdNFT: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"LockIdNFT: mint to the zero address\");\n        require(!_exists(tokenId), \"LockIdNFT: token already minted\");\n\n        // _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        _tokenOwner[tokenId] = to;\n        unchecked {\n            _ownedTokensCount[to] += 1;\n        }\n\n        emit Transfer(address(0), to, tokenId);\n        //  _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length-1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        //_ownedTokens[from].length--;\n        _ownedTokens[from].pop();\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length-1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        //_allTokens.length--;\n        _allTokens.pop();\n        _allTokensIndex[tokenId] = 0;\n    }\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            msg.sender,\n            from,\n            tokenId,\n            _data\n        ), \"LockIdNFT: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n\n    /// @dev Deposit\n    function _deposit(\n        address _addr,\n        uint256 _lockId,\n        LibLockId.SyncInfo memory syncInfo\n    ) internal ifFree {\n\n        /////////////////////////////////////////////////\n        // add point of LockId , 가장 최근의 포인트 (모두 누적 반영)\n        uint256 lenOfId = pointHistoryByLockId[_lockId].length;\n        LibLockId.SyncInfo memory pointByIdOld ;\n        LibLockId.SyncInfo memory pointByIdNew = LibLockId.SyncInfo({\n            slope: syncInfo.slope,\n            bias: syncInfo.bias,\n            timestamp : syncInfo.timestamp,\n            syncTime : uint32(block.timestamp)\n        });\n\n        if(lenOfId > 0) pointByIdOld = pointHistoryByLockId[_lockId][lenOfId-1];\n        else {\n            pointByIdOld = LibLockId.SyncInfo({\n                slope: 0,\n                bias: 0,\n                timestamp : 0,\n                syncTime : 0\n            });\n        }\n\n        /////////////////////////////////////////////////\n        // 변경된 값\n        LibLockId.SyncInfo memory pointByIdChange = LibLockId.SyncInfo({\n            slope: pointByIdNew.slope - pointByIdOld.slope,\n            bias: pointByIdNew.bias - pointByIdOld.bias,\n            timestamp : syncInfo.timestamp,\n            syncTime : uint32(block.timestamp)\n        });\n\n        /////////////////////////////////////////////////\n        // 락아이디 반영\n        pointHistoryByLockId[_lockId].push(pointByIdNew);\n\n        /////////////////////////////////////////////////\n        // point history based time\n        // deposit하면 다가오는 목요일 시간에 누적되어야 한다..총 금액이 다음 타임인덱스에 반영된다고 보아야 한다.\n        uint256 nextTimeIndexOfTotalPoint =  nextTimeIndex(block.timestamp);\n\n        uint256 len = pointHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n        LibLockId.SyncInfo memory pointLast ; // 가장 최근의 point\n\n        if (len == 0 ) {\n            // 가장 최근 인덱스\n            pointLast = pointOfLastTimeIndex();\n        } else {\n            pointLast = pointHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n        }\n\n        LibLockId.SyncInfo memory pointNew = LibLockId.SyncInfo({\n            slope: pointLast.slope + pointByIdChange.slope,\n            bias: pointLast.bias + pointByIdChange.bias,\n            timestamp : syncInfo.timestamp,\n            syncTime : uint32(block.timestamp)\n        });\n\n        /////////////////////////////////////////////////\n        // 총계 집계를 위한 락아이디 반영\n        pointHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n\n        if(!indexCheckOfTimeset[nextTimeIndexOfTotalPoint]) {\n            indexCheckOfTimeset[nextTimeIndexOfTotalPoint] = true;\n            indexOfTimeset.push(nextTimeIndexOfTotalPoint);\n        }\n    }\n\n    function nextTimeIndex(uint256 _stime) public view returns(uint256) {\n        return (_stime +  epochUnit / epochUnit * epochUnit);\n    }\n\n    function lastIndexOfTimeset() public view returns(uint256 index) {\n        index = (indexOfTimeset.length != 0 ? indexOfTimeset[indexOfTimeset.length - 1]:0);\n    }\n\n    /// 가장 최근의 포인트\n    function pointOfLastTimeIndex() public view returns(LibLockId.SyncInfo memory) {\n        return lastPointOfTimeIndex(lastIndexOfTimeset());\n    }\n\n    /// 해당 타임의 가장 최신 포인트\n    function lastPointOfTimeIndex(uint256 _index) public view returns(LibLockId.SyncInfo memory) {\n        if (_index != 0) {\n            LibLockId.SyncInfo[] memory points = pointHistoryByWeek[_index];\n\n            if (points.length != 0) {\n                return LibLockId.SyncInfo({\n                    slope: points[points.length-1].slope,\n                    bias: points[points.length-1].bias,\n                    timestamp: points[points.length-1].timestamp,\n                    syncTime : points[points.length-1].syncTime\n                });\n            } else {\n                return LibLockId.SyncInfo({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0,\n                    syncTime : 0\n                });\n            }\n        } else return LibLockId.SyncInfo({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0,\n                    syncTime : 0\n                });\n    }\n\n    // 특정 락아아디의 전체 포인트 리스트\n    function pointHistoryOfId(uint256 _lockId)\n        public\n        view\n        returns (LibLockId.SyncInfo[] memory)\n    {\n        return pointHistoryByLockId[_lockId];\n    }\n\n\n    /// 특정 타임인덱스의 전체 포인트 리스트\n    function pointHistoryOfTimeIndex(uint256 _timeIndex)\n        public\n        view\n        returns (LibLockId.SyncInfo[] memory)\n    {\n        return pointHistoryByWeek[_timeIndex];\n    }\n\n    /// 특정 계정이 소유한 stos를 가져옴.\n    function balanceOfLock(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance += balanceOfLock(locks[i]);\n        }\n    }\n\n    function balanceOfLockAt(address _addr, uint32 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance += balanceOfLockAt(locks[i], _timestamp);\n        }\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLock(uint256 _lockId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        uint256 len = pointHistoryByLockId[_lockId].length;\n        amount = (len == 0? 0: balanceOfPoint(pointHistoryByLockId[_lockId][len - 1], block.timestamp));\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLockAt(uint256 _lockId, uint32 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        (bool success, LibLockId.SyncInfo memory point) = _findClosestPoint(\n            pointHistoryByLockId[_lockId], _timestamp);\n        amount = (!success? 0: balanceOfPoint(point, _timestamp));\n    }\n\n    /// 현재 시간의 총 stos\n    function totalSupplyLocks()\n        public\n        view\n        returns (uint256 amount)\n    {\n       amount = balanceOfPoint(pointOfLastTimeIndex(), block.timestamp);\n    }\n\n    function totalSupplyLocksAt(uint32 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 해당 타임에 맞는 타임인덱스\n        (bool success, uint256 timeindex) = _findClosestTimeindex(_timestamp);\n        if(!success) return 0;\n        (bool success1, LibLockId.SyncInfo memory point) = _findClosestPoint(\n            pointHistoryByWeek[timeindex], _timestamp);\n        if(!success1) return 0;\n        amount = balanceOfPoint(point, _timestamp);\n    }\n\n    function balanceOfPoint(LibLockId.SyncInfo memory point, uint256 timestamp)\n        public\n        pure\n        returns (uint256)\n    {\n        if(timestamp < point.syncTime) return 0;\n        int256 currentBias = point.slope * int256(timestamp - point.timestamp);\n        return\n            uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n    }\n\n    function allIndexOfTimes() public view returns(uint256[] memory){\n        return indexOfTimeset;\n    }\n\n    function _findClosestPoint(\n        LibLockId.SyncInfo[] storage _history,\n        uint32 _timestamp\n    ) internal view returns(bool success, LibLockId.SyncInfo memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].syncTime <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].syncTime <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    function _findClosestTimeindex(\n        uint256 _timestamp\n    ) internal view returns(bool success, uint256 timeindex) {\n        uint256 totalLen = indexOfTimeset.length;\n        uint256 timeIndexKey =  (_timestamp + epochUnit) * epochUnit / epochUnit ;\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (indexOfTimeset[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (indexOfTimeset[left] <= timeIndexKey) {\n            return (true, indexOfTimeset[left]);\n        }\n        return (false, 0);\n    }\n}\n"
    },
    "contracts/stos/LockIdNftForStake.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\n\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./LockIdNFTStorage.sol\";\nimport \"./LockIdStorage.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LockIdNftForStake is ProxyStorage2, LockIdNFTStorage, LockIdStorage, IERC721, IERC721Metadata, IERC721Enumerable {\n    // using SafeMath for uint256;\n    using Address for address;\n    using Strings for uint256;\n\n    event LockCreated(address account, uint256 lockId, uint256 amount, uint256 unlockTime);\n    event LockDeposited(address account, uint256 lockId, uint256 value);\n    event IncreasedLock(address account, uint256 lockId, uint256 value, uint256 unlockTime);\n\n    modifier nonZero(uint256 _val) {\n        require(_val != 0, \"zero value\");\n        _;\n    }\n\n    constructor (\n        string memory name_, string memory symbol_,\n        address managerAddress,\n        address stakerAddress,\n        uint256 epochUnit_,\n        uint256 maxTime_,\n        address tosAddress\n        ) {\n\n        _manager = managerAddress;\n        staker = stakerAddress;\n        _name = name_;\n        _symbol = symbol_;\n        epochUnit = epochUnit_;\n        maxTime = maxTime_;\n        tos = tosAddress;\n    }\n\n    /*** External onlyManager ***/\n    function setStaker(address staker_) public onlyManager ifFree virtual {\n       staker = staker_;\n    }\n\n    /*** External ***/\n\n    function createLock(uint256 _amount, uint256 _unlockWeeks)\n        public nonZero(_amount) nonZero(_unlockWeeks) onlyStaker\n        returns (uint256 lockId)\n    {\n        uint256 unlockTime = (block.timestamp + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n        require(unlockTime - block.timestamp <= maxTime, \"Max unlock time is exceeded\" );\n\n        lockId = ++maxTokenId;\n        _safeMint(msg.sender, lockId);\n        _deposit(msg.sender, lockId, _amount, unlockTime);\n\n        emit LockCreated(msg.sender, lockId, _amount, unlockTime);\n    }\n\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) public nonZero(_value) onlyStaker {\n        require(_exists(_lockId), \"nonexistent token\");\n        require(_tokenOwner[_lockId] == _addr && _addr != address(0), \"not owner\");\n\n        LibLockId.LockedInfo memory lock = lockIdInfos[_lockId];\n        require(lock.withdrawlTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        _deposit(_addr, _lockId, _value, 0);\n        emit LockDeposited(msg.sender, _lockId, _value);\n    }\n\n    function increaseLock(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockWeeks\n    ) public onlyStaker {\n        require(_value != 0 || _unlockWeeks != 0, \"zero value\");\n        require(_exists(_lockId), \"nonexistent token\");\n        require(_tokenOwner[_lockId] == _addr && _addr != address(0), \"not owner\");\n\n        LibLockId.LockedInfo memory lock = lockIdInfos[_lockId];\n        require(lock.start > 0, \"not exist\");\n        require(lock.withdrawlTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        uint256 unlockTime = 0;\n        if (_unlockWeeks > 0) {\n            unlockTime = (lock.end + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n            require(unlockTime - block.timestamp < maxTime, \"Max unlock time is exceeded\");\n        }\n        _deposit(_addr, _lockId, _value, unlockTime);\n        emit IncreasedLock(msg.sender, _lockId, _value, unlockTime);\n    }\n\n    /*** Public ***/\n\n    // 모든 아이디는 staker를 자동 승인\n    function approve(address to, uint256 tokenId) public virtual override onlyStaker {\n\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    // 모든 계정은 staker를 자동 승인\n    function setApprovalForAll(address user, bool approved) public virtual override onlyStaker {\n        // _operatorApprovals[user][_manager] = approved;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override onlyStaker {\n        // require(_isApprovedOrOwner(msg.sender, tokenId), \"TitanNFT: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override onlyStaker {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override onlyStaker {\n        // require(_isApprovedOrOwner(msg.sender, tokenId), \"TitanNFT: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /*** View ***/\n\n    /**\n     * @dev Overrides supportsInterface\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165P) returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    // for opensea manager\n    // function owner() public view virtual returns (address) {\n    //     return _manager;\n    // }\n\n    // function isOwner(address addr) public view virtual returns (bool) {\n    //     if(_manager == addr) return true;\n    //     else return false;\n    // }\n\n    function manager() public view virtual returns (address) {\n        return _manager;\n    }\n\n    function isManager(address addr) public view virtual returns (bool) {\n\n        if(_manager == addr) return true;\n        else return false;\n    }\n\n    function balanceOf(address owner_) public view override returns (uint256) {\n        require(owner_ != address(0), \"LockIdNFT: balance query for the zero address\");\n\n        return _ownedTokensCount[owner_];\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        address owner_ = _tokenOwner[tokenId];\n        require(owner_ != address(0), \"LockIdNFT: owner query for nonexistent token\");\n\n        return owner_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"LockIdNFT: nonexistent token\");\n        // https://titan-nft.tokamak.network/titangoerli-metadata/tokenId\n        LibLockId.LockedInfo memory info = lockIdInfos[tokenId];\n\n       bytes memory json = abi.encodePacked(\n            '{',\n                '\"owner\": \"', ownerOf(tokenId), '\", ',\n                '\"unlockTime\": ', info.end.toString(), ', ',\n                '\"principal\": ', info.amount.toString(), ', ',\n                '\"stos\": ', balanceOfLock(tokenId).toString(), ', ',\n                '\"image\": \"data:image/svg+xml;base64,', generateSvgToBase64(tokenId), '\"',\n                // titan url\n            '}'\n        );\n\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(json)\n            )\n        );\n    }\n\n    function generateSvgToBase64(uint256 tokenId) public pure returns (string memory) {\n\n        return Base64.encode(abi.encodePacked(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\">',\n            '<style>.base { fill: white; font-family: serif; font-size: 14px; }</style>',\n            '<rect width=\"100%\" height=\"500%\" fill=\"grey\" />',\n            '<text x=\"50%\" y=\"50%\" class=\"base\" dominant-baseline=\"middle\" text-anchor=\"middle\"> #',\n            tokenId.toString(), ' </text></svg>'\n        ));\n    }\n\n    function tokenOfOwnerByIndex(address owner_, uint256 index) public view override returns (uint256) {\n        require(index < balanceOf(owner_), \"LockIdNFT: owner index out of bounds\");\n        return _ownedTokens[owner_][index];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        require(index < totalSupply(), \"LockIdNFT: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function allTokens() public view returns (uint256[] memory) {\n        return _allTokens;\n    }\n\n    function tokensOfOwner(address owner_) public view returns (uint256[] memory) {\n        return _ownedTokens[owner_];\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"LockIdNFT: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner_, address operator) public view virtual override returns (bool) {\n        // return _operatorApprovals[owner_][operator];\n    }\n\n    /*** internal ***/\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner_ = _tokenOwner[tokenId];\n        return owner_ != address(0);\n    }\n\n    // function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n    //     require(_exists(tokenId), \"LockIdNFT: operator query for nonexistent token\");\n    //     address owner_ = ownerOf(tokenId);\n    //     return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));\n    // }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        require(tokenId != 0, \"not allowed tokenId\");\n        _mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"LockIdNFT: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"LockIdNFT: mint to the zero address\");\n        require(!_exists(tokenId), \"LockIdNFT: token already minted\");\n\n        // _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        _tokenOwner[tokenId] = to;\n        unchecked {\n            _ownedTokensCount[to] += 1;\n        }\n\n        emit Transfer(address(0), to, tokenId);\n        //  _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length-1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        //_ownedTokens[from].length--;\n        _ownedTokens[from].pop();\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length-1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        //_allTokens.length--;\n        _allTokens.pop();\n        _allTokensIndex[tokenId] = 0;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            msg.sender,\n            from,\n            tokenId,\n            _data\n        ), \"LockIdNFT: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n\n     /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    // function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {\n\n    // }\n\n     /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    // function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {\n\n    // }\n\n    /// @dev Deposit\n    function _deposit(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockTime\n    ) internal ifFree {\n\n        /////////////////////////////////////////////////\n        // update base LockedInfo 락 기본 정보\n        LibLockId.LockedInfo memory preInfo = lockIdInfos[_lockId];\n        LibLockId.LockedInfo memory afterInfo = LibLockId.LockedInfo({\n                start: preInfo.start,\n                end: preInfo.end,\n                amount: preInfo.amount + _value,\n                withdrawlTime: 0\n            });\n\n        if (_unlockTime > 0)  afterInfo.end = _unlockTime;\n        if (afterInfo.start == 0)  afterInfo.start = block.timestamp;\n\n        /////////////////////////////////////////////////\n        // 기본정보 반영\n        lockIdInfos[_lockId] = afterInfo;\n\n        /////////////////////////////////////////////////\n        // add point of LockId , 가장 최근의 포인트 (모두 누적 반영)\n        uint256 lenOfId = pointHistoryByLockId[_lockId].length;\n        LibLockId.Point memory pointByIdOld ;\n        LibLockId.Point memory pointByIdNew = LibLockId.Point({\n            slope: int256(afterInfo.amount * MULTIPLIER / maxTime),\n            bias: 0,\n            timestamp : block.timestamp\n        });\n        pointByIdNew.bias = pointByIdNew.slope * int256(afterInfo.end - block.timestamp);\n\n        if(lenOfId > 0) pointByIdOld = pointHistoryByLockId[_lockId][lenOfId-1];\n        else {\n            pointByIdOld = LibLockId.Point({\n                slope: 0,\n                bias: 0,\n                timestamp : block.timestamp\n            });\n        }\n\n        /////////////////////////////////////////////////\n        // 변경된 값\n        LibLockId.Point memory pointByIdChange = LibLockId.Point({\n            slope: pointByIdNew.slope - pointByIdOld.slope,\n            bias: pointByIdNew.bias - pointByIdOld.bias,\n            timestamp : block.timestamp\n        });\n\n        /////////////////////////////////////////////////\n        // 락아이디 반영\n        pointHistoryByLockId[_lockId].push(pointByIdNew);\n\n        /////////////////////////////////////////////////\n        // point history based time\n        // deposit하면 다가오는 목요일 시간에 누적되어야 한다..총 금액이 다음 타임인덱스에 반영된다고 보아야 한다.\n        uint256 nextTimeIndexOfTotalPoint =  nextTimeIndex(block.timestamp);\n\n        uint256 len = pointHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n        LibLockId.Point memory pointLast ; // 가장 최근의 point\n\n        if (len == 0 ) {\n            // 가장 최근 인덱스\n            pointLast = pointOfLastTimeIndex();\n        } else {\n            pointLast = pointHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n        }\n\n        LibLockId.Point memory pointNew = LibLockId.Point({\n            slope: pointLast.slope + pointByIdChange.slope,\n            bias: pointLast.bias + pointByIdChange.bias,\n            timestamp : block.timestamp\n        });\n\n        /////////////////////////////////////////////////\n        // 총계 집계를 위한 락아이디 반영\n        pointHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n\n        if(!indexCheckOfTimeset[nextTimeIndexOfTotalPoint]) {\n            indexCheckOfTimeset[nextTimeIndexOfTotalPoint] = true;\n            indexOfTimeset.push(nextTimeIndexOfTotalPoint);\n        }\n\n        // Transfer TOS\n        // if(_value != 0)\n        //     require(\n        //         IERC20(tos).transferFrom(msg.sender, address(this), _value),\n        //         \"LockIdNFT: fail transferFrom\"\n        //     );\n    }\n\n    function nextTimeIndex(uint256 _stime) public view returns(uint256) {\n        return (_stime +  epochUnit / epochUnit * epochUnit);\n    }\n\n    function lastIndexOfTimeset() public view returns(uint256 index) {\n        index = (indexOfTimeset.length != 0 ? indexOfTimeset[indexOfTimeset.length - 1]:0);\n    }\n\n    /// 가장 최근의 포인트\n    function pointOfLastTimeIndex() public view returns(LibLockId.Point memory) {\n        return lastPointOfTimeIndex(lastIndexOfTimeset());\n    }\n\n    /// 해당 타임의 가장 최신 포인트\n    function lastPointOfTimeIndex(uint256 _index) public view returns(LibLockId.Point memory) {\n        if (_index != 0) {\n            LibLockId.Point[] memory points = pointHistoryByWeek[_index];\n\n            if (points.length != 0) {\n                return LibLockId.Point({\n                    slope: points[points.length-1].slope,\n                    bias: points[points.length-1].bias,\n                    timestamp: points[points.length-1].timestamp\n                });\n            } else {\n                return LibLockId.Point({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0\n                });\n            }\n        } else return LibLockId.Point({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0\n                });\n    }\n\n    // 특정 락아아디의 전체 포인트 리스트\n    function pointHistoryOfId(uint256 _lockId)\n        public\n        view\n        returns (LibLockId.Point[] memory)\n    {\n        return pointHistoryByLockId[_lockId];\n    }\n\n\n    /// 특정 타임인덱스의 전체 포인트 리스트\n    function pointHistoryOfTimeIndex(uint256 _timeIndex)\n        public\n        view\n        returns (LibLockId.Point[] memory)\n    {\n        return pointHistoryByWeek[_timeIndex];\n    }\n\n    /// 특정 계정이 소유한 stos를 가져옴.\n    function balanceOfLock(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance += balanceOfLock(locks[i]);\n        }\n    }\n\n    function balanceOfLockAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance += balanceOfLockAt(locks[i], _timestamp);\n        }\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLock(uint256 _lockId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        uint256 len = pointHistoryByLockId[_lockId].length;\n        amount = (len == 0? 0: balanceOfPoint(pointHistoryByLockId[_lockId][len - 1], block.timestamp));\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        (bool success, LibLockId.Point memory point) = _findClosestPoint(pointHistoryByLockId[_lockId], _timestamp);\n        amount = (!success? 0: balanceOfPoint(point, _timestamp));\n    }\n\n    /// 현재 시간의 총 stos\n    function totalSupplyLocks()\n        public\n        view\n        returns (uint256 amount)\n    {\n       amount = balanceOfPoint(pointOfLastTimeIndex(), block.timestamp);\n    }\n\n    function totalSupplyLocksAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 해당 타임에 맞는 타임인덱스\n        (bool success, uint256 timeindex) = _findClosestTimeindex(_timestamp);\n        if(!success) return 0;\n        (bool success1, LibLockId.Point memory point) = _findClosestPoint(pointHistoryByWeek[timeindex], _timestamp);\n        if(!success1) return 0;\n        amount = balanceOfPoint(point, _timestamp);\n    }\n\n    function balanceOfPoint(LibLockId.Point memory point, uint256 timestamp)\n        public\n        pure\n        returns (uint256)\n    {\n        if(timestamp < point.timestamp) return 0;\n        int256 currentBias = point.slope * int256(timestamp - point.timestamp);\n        return\n            uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n    }\n\n    function allIndexOfTimes() public view returns(uint256[] memory){\n        return indexOfTimeset;\n    }\n\n    function _findClosestPoint(\n        LibLockId.Point[] storage _history,\n        uint256 _timestamp\n    ) internal view returns(bool success, LibLockId.Point memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    function _findClosestTimeindex(\n        uint256 _timestamp\n    ) internal view returns(bool success, uint256 timeindex) {\n        uint256 totalLen = indexOfTimeset.length;\n        uint256 timeIndexKey =  (_timestamp + epochUnit) * epochUnit / epochUnit ;\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (indexOfTimeset[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (indexOfTimeset[left] <= timeIndexKey) {\n            return (true, indexOfTimeset[left]);\n        }\n        return (false, 0);\n    }\n\n    // function _approve(address to, uint256 tokenId) private {\n    //     _tokenApprovals[tokenId] = to;\n    //     emit Approval(ownerOf(tokenId), to, tokenId); // internal owner\n    // }\n\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"TitanNFT: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        // require(ownerOf(tokenId) == from, \"ProjectToken: transfer of token that is not own\");\n        require(to != address(0), \"ProjectToken: transfer to the zero address\");\n\n        // _beforeTokenTransfer(from, to, tokenId);\n\n        // _clearApproval(tokenId);\n\n        _ownedTokensCount[from]--;\n        _ownedTokensCount[to]++;\n\n        _tokenOwner[tokenId] = to;\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n}\n"
    },
    "contracts/stos/LockIdNFTProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../proxy/Proxy2.sol\";\nimport \"./LockIdNFTStorage.sol\";\nimport \"./LockIdStorage.sol\";\n\ncontract LockIdNFTProxy is Proxy2, LockIdNFTStorage, LockIdStorage\n{\n    event ManagershipTransferred(address indexed previousManager, address indexed newManager);\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (\n        string memory name_, string memory symbol_, address managerAddress\n        ) {\n\n        _manager = managerAddress;\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        // _registerInterface(_INTERFACE_ID_ERC721);\n        // _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        // _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    function renounceManagership() external onlyManager {\n        emit ManagershipTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    function transferManagership(address newManager) external onlyManager {\n        require(newManager != address(0), \"new manager is the zero address\");\n        emit ManagershipTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n\n}\n"
    },
    "contracts/stos/LockIdNFTStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./ERC165P.sol\";\n// import \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract LockIdNFTStorage is ERC165P {\n    // using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 public constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // universal stos contract\n    address public _manager;\n\n    // staker contract\n    address public staker;\n\n    // Token name\n    string public _name;\n\n    // Token symbol\n    string public _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) public _tokenURIs;\n\n    // attributes\n    mapping (uint256 => uint8) public _tokenAttributes;\n\n    // Base URI\n    string public _baseURI;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) public _tokenOwner; // _owners\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) public _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) public _ownedTokensCount; // _balances\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) public _operatorApprovals;\n\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) public _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) public _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] public _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) public _allTokensIndex;\n\n    bool internal _lock;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier onlyStaker() {\n        require(staker == msg.sender, \"not staker\");\n        _;\n    }\n\n    modifier ifFree {\n        require(_lock != true, \"in use\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n\n}\n"
    },
    "contracts/stos/LockIdNftTransferable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./LockIdNFTStorage.sol\";\nimport \"./LockIdStorage1.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LockIdNftTransferable is ProxyStorage2, LockIdNFTStorage, LockIdStorage1, IERC721, IERC721Metadata, IERC721Enumerable {\n    // using SafeMath for uint256;\n    using Address for address;\n    using Strings for uint256;\n\n    event LockCreated(address account, uint256 lockId, uint256 amount, uint256 unlockTime);\n    event LockDeposited(address account, uint256 lockId, uint256 value);\n    event IncreasedLock(address account, uint256 lockId, uint256 value, uint256 unlockTime);\n    event IncreasedUnlimitedLock(address account, uint256 amount);\n    event DecreasedUnlimitedLock(address account, uint256 amount);\n    event TransferUnlimitedLock(address from, address to, uint256 amount);\n    event TransferLock(address from, address to, uint256 oldLockId, uint256 tokenId, uint256 amount, uint256 end);\n\n    modifier nonZero(uint256 _val) {\n        require(_val != 0, \"zero value\");\n        _;\n    }\n\n    constructor (\n        string memory name_,\n        string memory symbol_,\n        address managerAddress,\n        uint256 epochUnit_,\n        uint256 maxTime_,\n        address tosAddress\n        ) {\n\n        _manager = managerAddress;\n        _name = name_;\n        _symbol = symbol_;\n        epochUnit = epochUnit_;\n        maxTime = maxTime_;\n        tos = tosAddress;\n    }\n\n    /*** External onlyManager ***/\n\n    // function setBaseURI(string memory baseURI_) public onlyManager ifFree virtual {\n    //    _setBaseURI(baseURI_);\n    // }\n\n    // function setTokenURI(uint256 tokenId, string memory _tokenURI) public onlyManager ifFree virtual {\n    //    _setTokenURI(tokenId, _tokenURI);\n    // }\n\n    // function setTokenURI(uint256[] memory tokenIds, string[] memory _tokenURIs) public onlyManager ifFree virtual {\n    //     require(tokenIds.length != 0 && tokenIds.length == _tokenURIs.length, \"wrong length\");\n    //     for(uint256 i = 0; i < tokenIds.length; i++){\n    //         _setTokenURI(tokenIds[i], _tokenURIs[i]);\n    //     }\n    // }\n\n    /*** External ***/\n\n    // function createLock(uint256 _amount, uint256 _unlockWeeks)\n    //     public nonZero(_amount) nonZero(_unlockWeeks)\n    //     returns (uint256 lockId)\n    // {\n    //     uint256 unlockTime = (block.timestamp + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n    //     require(unlockTime - block.timestamp <= maxTime, \"Max unlock time is exceeded\" );\n\n    //     lockId = ++maxTokenId;\n    //     _safeMint(msg.sender, lockId);\n    //     _createLock(msg.sender, lockId, _amount, unlockTime);\n\n    //     emit LockCreated(msg.sender, lockId, _amount, unlockTime);\n    // }\n\n\n    function addLockPeriod(uint256 howManyWeeks) public onlyManager ifFree virtual {\n        require(!existedLockPeriod[howManyWeeks], \"existed LockPeriod\");\n        existedLockPeriod[howManyWeeks] = true;\n        lockPeriod.push(howManyWeeks);\n    }\n\n\n    function createLock(uint256 _amount, uint256 _unlockWeeks)\n        public nonZero(_amount) nonZero(_unlockWeeks) ifFree\n        returns (uint256 lockId)\n    {\n        uint256 unlockTime = (block.timestamp + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n        require(unlockTime - block.timestamp <= maxTime, \"Max unlock time is exceeded\" );\n        console.log('unlockTime %s', unlockTime);\n\n        lockId = ++maxTokenId;\n        _createLock(msg.sender, lockId, _amount, _unlockWeeks, unlockTime, true);\n        _safeMint(msg.sender, lockId);\n        emit LockCreated(msg.sender, lockId, _amount, unlockTime);\n    }\n\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) public nonZero(_value) {\n        require(_exists(_lockId), \"nonexistent token\");\n        require(_tokenOwner[_lockId] == _addr && _addr != address(0), \"not owner\");\n\n        LibLockIdTransferable.LockedInfo memory lock = lockIdInfos[_lockId];\n        require(lock.withdrawalTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        _addInLock(_addr, _lockId, _value, lock.unlockWeeks, lock.end, true);\n\n        emit LockDeposited(msg.sender, _lockId, _value);\n    }\n\n    function increaseLock(\n        address _addr,\n        uint256 _lockId,\n        uint256 _unlockWeeks\n    ) public {\n        require(_unlockWeeks != 0, \"zero value\");\n        require(_exists(_lockId), \"nonexistent token\");\n        require(_tokenOwner[_lockId] == _addr && _addr != address(0), \"not owner\");\n\n        LibLockIdTransferable.LockedInfo memory lock = lockIdInfos[_lockId];\n        require(lock.start > 0, \"not exist\");\n        require(lock.withdrawalTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n        uint256 unlockTime = 0;\n        if (_unlockWeeks > 0) {\n            if (lockIdInfos[_lockId].unlockWeeks != _unlockWeeks) lockIdInfos[_lockId].unlockWeeks = _unlockWeeks;\n            unlockTime = (block.timestamp + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n            require(unlockTime - block.timestamp < maxTime, \"Max unlock time is exceeded\");\n        }\n        _addInLock(_addr, _lockId, 0, lock.unlockWeeks, unlockTime, true);\n        emit IncreasedLock(msg.sender, _lockId, 0, unlockTime);\n    }\n\n    // function increaseUnlimitedLock(address account, uint256 amount)\n    //     public nonZero(amount)\n    // {\n    //     // caller 는 무조건 스테이커가 가능하게 하도록 수정되어야 함 .\n    //     _increaseUnlimitedAccount(account, amount, true);\n    //     _increaseUnlimitedHistory(amount, true);\n\n    //     emit IncreasedUnlimitedLock(msg.sender, amount);\n    // }\n\n    // function decreaseUnlimitedLock(address account, uint256 amount)\n    //     public nonZero(amount)\n    // {\n    //     // caller 는 무조건 스테이커가 가능하게 하도록 수정되어야 함 .\n    //     _increaseUnlimitedAccount(account, amount, false);\n    //     _increaseUnlimitedHistory(amount, false);\n\n    //     /////////////////////////////////////////////////\n    //     // 락아이디로 변경\n    //     uint256 unlockTime = (block.timestamp + ((maxTime / epochUnit) * epochUnit)) / epochUnit * epochUnit;\n    //     uint256 lockId = ++maxTokenId;\n    //     _safeMint(msg.sender, lockId);\n    //     // _deposit(msg.sender, lockId, amount, unlockTime, true, false);\n\n    //     emit DecreasedUnlimitedLock(msg.sender, amount);\n    //     emit LockCreated(msg.sender, lockId, amount, unlockTime);\n    // }\n\n    // function _increaseUnlimitedAccount(address account, uint256 amount, bool increasement)\n    //     internal {\n\n    //     uint256 accountlen = unlimitedAmountByAccount[account].length;\n    //     uint256 prevAmount = 0;\n    //     if (accountlen != 0) {\n    //         prevAmount = unlimitedAmountByAccount[account][accountlen-1].amount;\n    //     }\n    //     if(!increasement) {\n    //         require(accountlen != 0, 'no unlimited amount');\n    //         require(prevAmount >= amount, 'unlimitedAmount is insufficient');\n    //     }\n    //     LibLockIdTransferable.UnlimitedAmount memory afterInfo = LibLockIdTransferable.UnlimitedAmount({\n    //             timestamp: uint32(block.timestamp),\n    //             amount: (increasement? prevAmount+amount: prevAmount-amount)\n    //     });\n\n    //     unlimitedAmountByAccount[account].push(afterInfo);\n    // }\n\n    // function _increaseUnlimitedHistory(uint256 amount, bool increasement) internal {\n    //     uint256 nextTimeIndexOfTotalPoint = nextTimeIndex(block.timestamp);\n    //     uint256 len = unlimitedHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n    //     LibLockIdTransferable.UnlimitedAmount memory pointLast ; // 가장 최근의 point\n\n    //     if (len == 0 ) {\n    //         // 가장 최근 인덱스\n    //         pointLast = pointOfLastTimeIndexForUnlimited();\n    //     } else {\n    //         pointLast = unlimitedHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n    //     }\n    //     if(!increasement) require(pointLast.amount >= amount, 'insufficient unlimited amount');\n\n    //     LibLockIdTransferable.UnlimitedAmount memory pointNew = LibLockIdTransferable.UnlimitedAmount({\n    //         timestamp : uint32(block.timestamp),\n    //         amount: pointLast.amount\n    //     });\n\n    //     if(increasement) pointNew.amount += amount;\n    //     else pointNew.amount -= amount;\n\n    //     unlimitedHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n\n    //     if(!indexCheckOfTimesetForUnlimited[nextTimeIndexOfTotalPoint]) {\n    //         indexCheckOfTimesetForUnlimited[nextTimeIndexOfTotalPoint] = true;\n    //         indexOfTimesetForUnlimited.push(nextTimeIndexOfTotalPoint);\n    //     }\n    // }\n\n    /*** Public ***/\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner_ = ownerOf(tokenId);\n        require(to != owner_, \"approval to current owner\");\n\n        require(msg.sender == owner_ || isApprovedForAll(owner_, msg.sender),\n            \"approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /// 무제한 락업을 위한 전송기능\n    // function transferFromUnlimited(address from, address to, uint256 amount) public virtual {\n    //     address spender = msg.sender;\n    //     require (spender == from || isApprovedForAll(from, spender), \"not approved\");\n\n    //     _increaseUnlimitedAccount(from, amount, false);\n    //     _increaseUnlimitedAccount(to, amount, true);\n\n    //     emit TransferUnlimitedLock(from, to, amount);\n    // }\n\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != msg.sender, \"approve to caller\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /*** View ***/\n\n    /**\n     * @dev Overrides supportsInterface\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165P) returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    // for opensea manager\n    // function owner() public view virtual returns (address) {\n    //     return _manager;\n    // }\n\n    // function isOwner(address addr) public view virtual returns (bool) {\n    //     if(_manager == addr) return true;\n    //     else return false;\n    // }\n\n    function manager() public view virtual returns (address) {\n        return _manager;\n    }\n\n    function isManager(address addr) public view virtual returns (bool) {\n\n        if(_manager == addr) return true;\n        else return false;\n    }\n\n    function balanceOf(address owner_) public view override returns (uint256) {\n        require(owner_ != address(0), \"LockIdNFT: balance query for the zero address\");\n\n        return _ownedTokensCount[owner_];\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        address owner_ = _tokenOwner[tokenId];\n        require(owner_ != address(0), \"LockIdNFT: owner query for nonexistent token\");\n\n        return owner_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"LockIdNFT: nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    function tokenOfOwnerByIndex(address owner_, uint256 index) public view override returns (uint256) {\n        require(index < balanceOf(owner_), \"LockIdNFT: owner index out of bounds\");\n        return _ownedTokens[owner_][index];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        require(index < totalSupply(), \"LockIdNFT: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function allTokens() public view returns (uint256[] memory) {\n        return _allTokens;\n    }\n\n    function tokensOfOwner(address owner_) public view returns (uint256[] memory) {\n        return _ownedTokens[owner_];\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"LockIdNFT: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner_, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner_][operator];\n    }\n\n    /*** internal ***/\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner_ = _tokenOwner[tokenId];\n        return owner_ != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"LockIdNFT: operator query for nonexistent token\");\n        address owner_ = ownerOf(tokenId);\n        return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));\n    }\n\n    function _burn(address owner_, uint256 tokenId) internal virtual{\n        require(ownerOf(tokenId) == owner_, \"burn of token that is not own\");\n        // _beforeTokenTransfer(owner_, address(0), tokenId);\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner_]--;\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner_, address(0), tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        require(tokenId != 0, \"not allowed tokenId\");\n        _mint(to, tokenId);\n        _addTokenToOwnerEnumeration(to, tokenId);\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"LockIdNFT: mint to the zero address\");\n        require(!_exists(tokenId), \"LockIdNFT: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        _tokenOwner[tokenId] = to;\n        unchecked {\n            _ownedTokensCount[to] += 1;\n        }\n\n        emit Transfer(address(0), to, tokenId);\n         _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length-1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        //_ownedTokens[from].length--;\n        _ownedTokens[from].pop();\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length-1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        //_allTokens.length--;\n        _allTokens.pop();\n        _allTokensIndex[tokenId] = 0;\n    }\n\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n\n    /*\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ProjectToken: transfer of token that is not own\");\n        require(to != address(0), \"ProjectToken: transfer to the zero address\");\n\n        // _beforeTokenTransfer(from, to, tokenId);\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from]--;\n        _ownedTokensCount[to]++;\n\n        _tokenOwner[tokenId] = to;\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        emit Transfer(from, to, tokenId);\n    }\n    */\n\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ProjectToken: transfer of token that is not own\");\n        require(to != address(0), \"ProjectToken: transfer to the zero address\");\n\n        // 기본정보 수정\n        LibLockIdTransferable.LockedInfo memory lock = lockIdInfos[tokenId];\n\n        require(lock.withdrawalTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n        lockIdInfos[tokenId].withdrawalTime = uint32(block.timestamp);\n\n        // 새로 락업아이디 추가 .\n        uint256 newLockId = ++maxTokenId;\n        _safeMint(to, newLockId);\n\n        _createLock(to, newLockId, lock.amount, lock.unlockWeeks,  lock.end, false);\n\n        emit TransferLock(from, to, tokenId, newLockId, lock.amount, lock.end);\n        emit LockCreated(to, newLockId, lock.amount, lock.end);\n    }\n\n     /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {\n\n    }\n\n     /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {\n\n    }\n\n\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n    /*\n    /// @dev Deposit\n    function _deposit(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockTime,\n        bool _applyHistoryWeek,\n        bool boolCreated\n    ) internal ifFree returns (\n        LibLockIdTransferable.Point memory pointByIdOld,\n        LibLockIdTransferable.Point memory pointByIdNew,\n        int256  passBias) {\n\n        /////////////////////////////////////////////////\n        // update base LockedInfo 락 기본 정보\n        LibLockIdTransferable.LockedInfo memory preInfo = lockIdInfos[_lockId];\n        LibLockIdTransferable.LockedInfo memory afterInfo = LibLockIdTransferable.LockedInfo({\n                start: preInfo.start,\n                end: preInfo.end,\n                amount: preInfo.amount + _value,\n                withdrawalTime: 0\n            });\n\n        if (_unlockTime > 0)  afterInfo.end = _unlockTime;\n        if (afterInfo.start == 0)  afterInfo.start = block.timestamp;\n\n        /////////////////////////////////////////////////\n        // 기본정보 반영\n        lockIdInfos[_lockId] = afterInfo;\n\n        // Checkpoint\n        _checkpoint(preInfo, afterInfo);\n\n        // Save user point,\n        int256 userSlope = afterInfo.amount * MULTIPLIER / maxTime ;\n        int256 userBias = userSlope * (afterInfo.end -  block.timestamp) ;\n        LibLockTOS.Point memory userPoint =\n            LibLockTOS.Point({\n                timestamp: block.timestamp,\n                slope: userSlope,\n                bias: userBias\n            });\n        pointHistoryByLockId[_lockId].push(userPoint);\n\n    }\n    */\n    function _createLock(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockWeeks,\n        uint256 _unlockTime,\n        bool applyTotal\n    ) internal  {\n        require(existedLockPeriod[_unlockWeeks], \"unsupported unlock weeks\");\n\n        /////////////////////////////////////////////////\n        // update base LockedInfo 락 기본 정보\n        LibLockIdTransferable.LockedInfo memory afterInfo = LibLockIdTransferable.LockedInfo({\n                start: uint32(block.timestamp),\n                end: _unlockTime,\n                unlockWeeks: _unlockWeeks,\n                withdrawalTime: 0,\n                amount: _value\n            });\n\n        /////////////////////////////////////////////////\n        // 기본정보 반영\n        lockIdInfos[_lockId] = afterInfo;\n\n        /////////////////////////////////////////////////\n        LibLockIdTransferable.Point memory pointByIdNew = LibLockIdTransferable.Point({\n            slope: int256(afterInfo.amount * MULTIPLIER / maxTime),\n            bias: 0 ,\n            timestamp : block.timestamp\n        });\n        pointByIdNew.bias = pointByIdNew.slope * int256(afterInfo.end - block.timestamp);\n        console.log(\"create lock timestamp : %s \", block.timestamp);\n        /////////////////////////////////////////////////\n        // 락아이디 반영\n        pointHistoryByLockId[_lockId].push(pointByIdNew);\n\n        if (applyTotal) {\n            _insesrtCumulativeAddPoint(pointByIdNew);\n            _insesrtCumulativeEndPoint (\n                _unlockWeeks,\n                _unlockTime,\n                pointByIdNew.slope\n            );\n        }\n    }\n    function _increaseAmountInLock(\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockWeeks\n    ) internal ifFree {\n\n        /////////////////////////////////////////////////\n        // update base LockedInfo 락 기본 정보\n        LibLockIdTransferable.LockedInfo memory preInfo = lockIdInfos[_lockId];\n        LibLockIdTransferable.LockedInfo memory afterInfo = LibLockIdTransferable.LockedInfo({\n                start: preInfo.start,\n                end: preInfo.end,\n                unlockWeeks: preInfo.unlockWeeks,\n                withdrawalTime: 0,\n                amount: preInfo.amount + _value\n            });\n        /////////////////////////////////////////////////\n        // 기본정보 반영\n        lockIdInfos[_lockId] = afterInfo;\n        /////////////////////////////////////////////////\n        // add point of LockId , 가장 최근의 포인트 (모두 누적 반영)\n        uint256 lenOfId = pointHistoryByLockId[_lockId].length;\n        LibLockIdTransferable.Point memory pointByIdOld;\n\n        if(lenOfId > 0) pointByIdOld = pointHistoryByLockId[_lockId][lenOfId-1];\n        else {\n            pointByIdOld = LibLockIdTransferable.Point({\n                slope: 0,\n                bias: 0,\n                timestamp : block.timestamp\n            });\n        }\n\n        LibLockIdTransferable.Point memory pointByIdNew = LibLockIdTransferable.Point({\n            slope: int256(afterInfo.amount * MULTIPLIER / maxTime),\n            bias: 0 ,\n            timestamp : block.timestamp\n        });\n\n        int passBias = pointByIdOld.slope * int256(block.timestamp - pointByIdOld.timestamp);\n        console.log('passBias %s', uint256(passBias));\n        int256 curBias = pointByIdOld.bias - passBias ;\n        console.log('curBias %s', uint256(curBias));\n\n        pointByIdNew.bias = curBias + (pointByIdNew.slope * int256(afterInfo.end - block.timestamp));\n        console.log('pointByIdNew.bias  %s', uint256(pointByIdNew.bias));\n\n        /////////////////////////////////////////////////\n        // 락아이디 반영\n        pointHistoryByLockId[_lockId].push(pointByIdNew);\n\n        LibLockIdTransferable.Point memory changePoint = LibLockIdTransferable.Point({\n            slope: int256(_value * MULTIPLIER / maxTime),\n            bias: pointByIdNew.bias - pointByIdOld.bias + passBias,\n            timestamp : block.timestamp\n        });\n        _insesrtCumulativeAddPoint(changePoint);\n        // _insertDeleteSlopeCumuluative(delPoint);\n        _insesrtCumulativeEndPoint (\n            _unlockWeeks,\n            afterInfo.end,\n            changePoint.slope\n        );\n\n\n    }\n    function _insesrtCumulativeAddPoint (LibLockIdTransferable.Point memory addPoint) internal {\n        // console.log('epochUnit %s', epochUnit);\n\n        uint256 nextTimeIndexOfTotalPoint =  nextTimeIndex(block.timestamp);\n        console.log('_insesrtCumulativeAddPoint nextTimeIndexOfTotalPoint %s', nextTimeIndexOfTotalPoint);\n\n        uint256 len = pointHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n        LibLockIdTransferable.Point memory pointLast ; // 가장 최근의 point\n        if (len == 0 )  pointLast = pointOfLastTimeIndex();\n        else  pointLast = pointHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n        console.log('_insesrtCumulativeAddPoint pointLast slope %s', uint256(pointLast.slope));\n\n        int256 passBias = pointLast.slope * int256(block.timestamp - pointLast.timestamp);\n        console.log('_insesrtCumulativeAddPoint passBias %s', uint256(passBias));\n\n        LibLockIdTransferable.Point memory pointNew = LibLockIdTransferable.Point({\n            slope: pointLast.slope + addPoint.slope,\n            bias: pointLast.bias + addPoint.bias - passBias,\n            timestamp : block.timestamp\n        });\n\n        pointHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n        // console.log('_insesrtCumulativeAddPoint pointNew slope %s', uint256(pointNew.slope));\n        // console.log('_insesrtCumulativeAddPoint nextTimeIndexOfTotalPoint %s', nextTimeIndexOfTotalPoint);\n\n        if(!indexCheckOfTimeset[nextTimeIndexOfTotalPoint]) {\n            indexCheckOfTimeset[nextTimeIndexOfTotalPoint] = true;\n            indexOfTimeset.push(nextTimeIndexOfTotalPoint);\n        }\n    }\n\n    function _insesrtCumulativeEndPoint (\n            uint256 lockPeriodIndex,\n            uint256 endTime,\n            int256 endSlope\n        ) internal {\n\n        // require(existedLockPeriod[lockPeriodIndex], \"wrong lockPeriodIndex\");\n\n        bool existedIndex = indexCheckOfTimesetForLockEnd[lockPeriodIndex][endTime];\n        // console.log('_insesrtCumulativeEndPoint' );\n        // console.logBool(existedIndex);\n\n        int256 lastEndSlop = 0;\n        if (!existedIndex) {\n            uint256 lastTimeIndexLen = indexOfTimesetForLockEnd[lockPeriodIndex].length ;\n            if(lastTimeIndexLen != 0) {\n                uint256 lastTimeIndex = indexOfTimesetForLockEnd[lockPeriodIndex][lastTimeIndexLen-1];\n                if(lastTimeIndex < endTime) {\n                    lastEndSlop = slopeByLockEndTime[lockPeriodIndex][lastTimeIndex];\n                    slopeByLockEndTime[lockPeriodIndex][endTime] += lastEndSlop;\n                }\n            }\n            // console.log('_insesrtCumulativeEndPoint lastEndSlop %s', uint256(lastEndSlop) );\n            indexCheckOfTimesetForLockEnd[lockPeriodIndex][endTime] = true;\n            indexOfTimesetForLockEnd[lockPeriodIndex].push(endTime);\n            // console.log('_insesrtCumulativeEndPoint endTime %s', endTime);\n        }\n        slopeByLockEndTime[lockPeriodIndex][endTime] += endSlope;\n        // console.log('_insesrtCumulativeEndPoint slopeByLockEndTime[lockPeriodIndex][endTime] %s', uint256(slopeByLockEndTime[lockPeriodIndex][endTime]));\n    }\n\n    function _addInLock(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockWeeks,\n        uint256 _unlockTime,\n        bool applyTotal\n    ) internal ifFree {\n\n        /////////////////////////////////////////////////\n        // update base LockedInfo 락 기본 정보\n        LibLockIdTransferable.LockedInfo memory preInfo = lockIdInfos[_lockId];\n        LibLockIdTransferable.LockedInfo memory afterInfo = LibLockIdTransferable.LockedInfo({\n                start: preInfo.start,\n                end: preInfo.end,\n                unlockWeeks: preInfo.unlockWeeks,\n                withdrawalTime: 0,\n                amount: preInfo.amount + _value\n            });\n\n        if (_unlockTime > 0)  afterInfo.end = _unlockTime;\n        if (afterInfo.start == 0)  afterInfo.start = block.timestamp;\n\n        /////////////////////////////////////////////////\n        // 기본정보 반영\n        lockIdInfos[_lockId] = afterInfo;\n        console.log('_addInLock in %s',  _lockId);\n\n        /////////////////////////////////////////////////\n        // add point of LockId , 가장 최근의 포인트 (모두 누적 반영)\n        uint256 lenOfId = pointHistoryByLockId[_lockId].length;\n        LibLockIdTransferable.Point memory pointByIdOld;\n\n        if(lenOfId > 0) pointByIdOld = pointHistoryByLockId[_lockId][lenOfId-1];\n        else {\n            pointByIdOld = LibLockIdTransferable.Point({\n                slope: 0,\n                bias: 0,\n                timestamp : block.timestamp\n            });\n        }\n\n        LibLockIdTransferable.Point memory pointByIdNew = LibLockIdTransferable.Point({\n            slope: int256(afterInfo.amount * MULTIPLIER / maxTime),\n            bias: 0 ,\n            timestamp : block.timestamp\n        });\n\n        // uint256 remainTime = afterInfo.end - block.timestamp;\n        // console.log('remainTime  %s', remainTime);\n        console.log('pointByIdOld.slope  %s', uint256(pointByIdOld.slope));\n\n        int passBias = pointByIdOld.slope * int256(block.timestamp - pointByIdOld.timestamp);\n        console.log('passBias %s', uint256(passBias));\n        int256 curBias = pointByIdOld.bias - passBias ;\n        console.log('curBias %s', uint256(curBias));\n\n        pointByIdNew.bias = curBias + (pointByIdNew.slope * int256(afterInfo.end - block.timestamp));\n        console.log('pointByIdNew.bias  %s', uint256(pointByIdNew.bias));\n\n        /////////////////////////////////////////////////\n        // 락아이디 반영\n        pointHistoryByLockId[_lockId].push(pointByIdNew);\n\n        if (applyTotal) {\n\n            LibLockIdTransferable.Point memory changePoint = LibLockIdTransferable.Point({\n                slope: int256(_value * MULTIPLIER / maxTime),\n                bias: pointByIdNew.bias - pointByIdOld.bias + passBias,\n                timestamp : block.timestamp\n            });\n            _insesrtCumulativeAddPoint(changePoint);\n            // _insertDeleteSlopeCumuluative(delPoint);\n            _insesrtCumulativeEndPoint (\n                _unlockWeeks,\n                _unlockTime,\n                pointByIdNew.slope\n            );\n        }\n\n    }\n\n    function _insertDeleteSlopeCumuluative(LibLockIdTransferable.Point memory point) internal {\n\n        if(deleteSlopeCumuluative.length == 0) deleteSlopeCumuluative.push(point);\n        else {\n            LibLockIdTransferable.Point memory lastPoint = deleteSlopeCumuluative[deleteSlopeCumuluative.length-1];\n\n            lastPoint.slope += point.slope;\n            lastPoint.bias += point.bias;\n            lastPoint.timestamp = block.timestamp;\n            deleteSlopeCumuluative.push(lastPoint);\n        }\n    }\n\n    /*\n    function _modifyPointHistoryBYWeek(int256 slope, int256 bias, bool boolCreated)\n        internal  {\n\n        /////////////////////////////////////////////////\n        // point history based time\n        // deposit하면 다가오는 목요일 시간에 누적되어야 한다..총 금액이 다음 타임인덱스에 반영된다고 보아야 한다.\n        uint256 nextTimeIndexOfTotalPoint =  nextTimeIndex(block.timestamp);\n\n        uint256 len = pointHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n        LibLockIdTransferable.Point memory pointLast ; // 가장 최근의 point\n\n        if (len == 0 ) {\n            // 가장 최근 인덱스\n            pointLast = pointOfLastTimeIndex();\n        } else {\n            pointLast = pointHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n        }\n        // console.log('pointLast.bias ', uint256(pointLast.bias));\n\n        // int256 currentBias = pointLast.slope * int256(block.timestamp - pointLast.timestamp);\n        // currentBias = (pointLast.bias > currentBias ? (pointLast.bias - currentBias) : int256(0));\n\n        LibLockIdTransferable.Point memory pointNew = LibLockIdTransferable.Point({\n            slope: pointLast.slope + slope,\n            bias: pointLast.bias + bias,\n            timestamp : block.timestamp\n        });\n\n        if(boolCreated) {\n            int256 currentBias = pointLast.slope * int256(block.timestamp - pointLast.timestamp);\n            currentBias = (pointLast.bias > currentBias ? (pointLast.bias - currentBias) : int256(0));\n            pointNew.bias = int256(currentBias) + bias;\n        }\n        /////////////////////////////////////////////////\n        // 총계 집계를 위한 락아이디 반영\n        pointHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n\n        if(!indexCheckOfTimeset[nextTimeIndexOfTotalPoint]) {\n            indexCheckOfTimeset[nextTimeIndexOfTotalPoint] = true;\n            indexOfTimeset.push(nextTimeIndexOfTotalPoint);\n        }\n    }\n    */\n    function nextTimeIndex(uint256 _stime) public view returns(uint256) {\n        return (_stime +  epochUnit) / epochUnit * epochUnit;\n    }\n\n    function lastIndexOfTimeset() public view returns(uint256 index) {\n        index = (indexOfTimeset.length != 0 ? indexOfTimeset[indexOfTimeset.length - 1]:0);\n        // console.log('lastIndexOfTimeset %s' , index);\n\n    }\n\n    function lastIndexOfTimesetForUnlimited() public view returns(uint256 index) {\n        index = (indexOfTimesetForUnlimited.length != 0 ? indexOfTimesetForUnlimited[indexOfTimesetForUnlimited.length - 1]:0);\n    }\n\n    /// 가장 최근의 포인트\n    function pointOfLastTimeIndex() public view returns(LibLockIdTransferable.Point memory) {\n        // console.log('lastIndexOfTimeset() %s' , lastIndexOfTimeset());\n\n        return lastPointOfTimeIndex(lastIndexOfTimeset());\n    }\n\n    function pointOfLastTimeIndexForUnlimited() public view returns(LibLockIdTransferable.UnlimitedAmount memory) {\n        return lastPointOfTimeIndexForUnlimited(lastIndexOfTimesetForUnlimited());\n    }\n\n    /// 해당 타임의 가장 최신 포인트\n    function lastPointOfTimeIndex(uint256 _index) public view returns(LibLockIdTransferable.Point memory) {\n        //  console.log('lastPointOfTimeIndex _index %s' , _index);\n\n        if (_index != 0) {\n            LibLockIdTransferable.Point[] memory points = pointHistoryByWeek[_index];\n            // console.log('lastPointOfTimeIndex points.length %s' , points.length);\n            if (points.length != 0) {\n                return LibLockIdTransferable.Point({\n                    slope: points[points.length-1].slope,\n                    bias: points[points.length-1].bias,\n                    timestamp: points[points.length-1].timestamp\n                });\n            } else {\n                return LibLockIdTransferable.Point({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0\n                });\n            }\n        } else return LibLockIdTransferable.Point({\n                    slope: 0,\n                    bias: 0,\n                    timestamp: 0\n                });\n    }\n\n    function lastPointOfTimeIndexForUnlimited(uint256 _index) public view returns(LibLockIdTransferable.UnlimitedAmount memory) {\n        if (_index != 0) {\n            LibLockIdTransferable.UnlimitedAmount[] memory points = unlimitedHistoryByWeek[_index];\n\n            if (points.length != 0) {\n                return LibLockIdTransferable.UnlimitedAmount({\n                    timestamp: points[points.length-1].timestamp,\n                    amount: points[points.length-1].amount\n                });\n            } else {\n                return LibLockIdTransferable.UnlimitedAmount({\n                    timestamp: 0,\n                    amount: 0\n                });\n            }\n        } else return LibLockIdTransferable.UnlimitedAmount({\n                    timestamp: 0,\n                    amount: 0\n                });\n    }\n\n\n    // 특정 락아아디의 전체 포인트 리스트\n    function pointHistoryOfId(uint256 _lockId)\n        public\n        view\n        returns (LibLockIdTransferable.Point[] memory)\n    {\n        return pointHistoryByLockId[_lockId];\n    }\n\n\n    /// 특정 타임인덱스의 전체 포인트 리스트\n    function pointHistoryOfTimeIndex(uint256 _timeIndex)\n        public\n        view\n        returns (LibLockIdTransferable.Point[] memory)\n    {\n        return pointHistoryByWeek[_timeIndex];\n    }\n\n    function pointHistoryOfUnlimited(address _addr)\n        public\n        view\n        returns (LibLockIdTransferable.UnlimitedAmount[] memory)\n    {\n        return unlimitedAmountByAccount[_addr];\n    }\n\n    function pointHistoryOfTimeIndexForUnlimited(uint256 _timeIndex)\n        public\n        view\n        returns (LibLockIdTransferable.UnlimitedAmount[] memory)\n    {\n        return unlimitedHistoryByWeek[_timeIndex];\n    }\n\n    function balanceOfAccount(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = balanceOfUnlimitedLock(_addr) + balanceOfLock(_addr);\n    }\n\n    function balanceOfAccountAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = balanceOfUnlimitedLockAt(_addr, _timestamp) + balanceOfLockAt(_addr, _timestamp);\n    }\n\n    function balanceOfUnlimitedLock(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256 len = unlimitedAmountByAccount[_addr].length;\n        balance = (len == 0? 0: balanceOfUnlimited(unlimitedAmountByAccount[_addr][len - 1], block.timestamp));\n    }\n\n    function balanceOfUnlimitedLockAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        // _timestamp\n        (bool success, LibLockIdTransferable.UnlimitedAmount memory point) = _findClosestUnlimitedPoint(unlimitedAmountByAccount[_addr], _timestamp);\n        balance = (!success? 0: balanceOfUnlimited(point, _timestamp));\n    }\n\n    /// 특정 계정이 소유한 stos를 가져옴.\n    function balanceOfLock(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length != 0) {\n            for (uint256 i = 0; i < locks.length; ++i) {\n                balance += balanceOfLock(locks[i]);\n            }\n        }\n    }\n\n    function balanceOfLockAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = tokensOfOwner(_addr);\n        if (locks.length != 0) {\n            for (uint256 i = 0; i < locks.length; ++i) {\n                balance += balanceOfLockAt(locks[i], _timestamp);\n            }\n        }\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLock(uint256 _lockId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        LibLockIdTransferable.LockedInfo memory info = lockIdInfos[_lockId];\n        if (info.withdrawalTime !=0 && info.withdrawalTime <= block.timestamp) return 0;\n        if (info.end != 0 && info.end < block.timestamp) return 0;\n\n        uint256 len = pointHistoryByLockId[_lockId].length;\n        amount = (len == 0? 0: balanceOfPointId(pointHistoryByLockId[_lockId][len - 1], block.timestamp));\n    }\n\n    /// 특정 락아이디의 현재 시간의 stos\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        LibLockIdTransferable.LockedInfo memory info = lockIdInfos[_lockId];\n\n        if (info.withdrawalTime !=0 && info.withdrawalTime <= _timestamp) return 0;\n        if (info.end != 0 && info.end < _timestamp) return 0;\n\n        (bool success, LibLockIdTransferable.Point memory point) = _findClosestPoint(pointHistoryByLockId[_lockId], _timestamp);\n        // console.logBool(success);\n\n        // console.log('balanceOfLock _timestamp %s : point.slope %s', _timestamp, uint256(point.slope));\n        amount = (!success? 0: balanceOfPointId(point, _timestamp));\n    }\n\n    /// 현재 시간의 총 stos\n    function totalSupplyAll()\n        public\n        view\n        returns (uint256 amount)\n    {\n        amount = totalSupplyLocks() + totalSupplyUnlimited();\n    }\n\n    function totalSupplyAllAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        amount = totalSupplyLocksAt(_timestamp) + totalSupplyUnlimitedAt(_timestamp);\n    }\n\n    function totalSupplyLocks()\n        public\n        view\n        returns (uint256 amount)\n    {\n       amount = balanceOfPoint(pointOfLastTimeIndex(), block.timestamp);\n    }\n\n    function totalSupplyUnlimited()\n        public\n        view\n        returns (uint256 amount)\n    {\n    //    amount = balanceOfUnlimited(pointOfLastTimeIndexForUnlimited(), block.timestamp);\n    }\n\n    function totalSupplyLocksAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 해당 타임에 맞는 타임인덱스\n        (bool success, uint256 timeindex) = _findClosestTimeindex(_timestamp);\n        if(!success) return 0;\n        // console.log(\"totalSupplyLocksAt timeindex %s\", timeindex);\n        (bool success1, LibLockIdTransferable.Point memory point) = _findClosestPoint(pointHistoryByWeek[timeindex], _timestamp);\n        if(!success1) return 0;\n\n        // console.log(\"point.slope %s\", uint256(point.slope));\n        // console.log(\"point.bias %s\", uint256(point.bias));\n\n        amount = balanceOfPoint(point, _timestamp);\n    }\n\n    function totalSupplyUnlimitedAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 해당 타임에 맞는 타임인덱스\n        // (bool success, uint256 timeindex) = _findClosestUnlimitedTimeindex(_timestamp);\n        // if(!success) return 0;\n        // (bool success1, LibLockIdTransferable.UnlimitedAmount memory point) = _findClosestUnlimitedPoint(unlimitedHistoryByWeek[timeindex], _timestamp);\n        // if(!success1) return 0;\n        // amount = balanceOfUnlimited(point, _timestamp);\n    }\n\n    function balanceOfPointId(LibLockIdTransferable.Point memory point, uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        console.log('balanceOfPointId point.timestamp %s' , point.timestamp);\n        console.log('balanceOfPointId timestamp %s' , timestamp);\n        console.log('balanceOfPointId point.slope %s' , uint256(point.slope));\n        console.log('balanceOfPointId point.bias %s' , uint256(point.bias));\n        // if(timestamp < point.timestamp) return 0;\n\n        int256 currentBias = point.slope * int256(timestamp - point.timestamp);\n        console.log('balanceOfPointId pass %s' , uint256(currentBias));\n        console.log('balanceOfPointId stos %s' , uint256(point.bias - currentBias) / MULTIPLIER );\n\n        uint256 aa = uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n        console.log('balanceOfPointId aa %s' , aa);\n\n        if(timestamp < point.timestamp) return 0;\n        return\n            uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n\n    }\n\n    function balanceOfPoint(LibLockIdTransferable.Point memory point, uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        console.log('**balanceOfPoint point slope: %s, bias: %s, timestamp %s,', uint256(point.slope), uint256(point.bias), point.timestamp );\n        console.log(' timestamp %s',timestamp);\n\n        if(timestamp < point.timestamp) return 0;\n\n        int256 currentBias = point.slope * int256(timestamp - point.timestamp);\n        console.log(' currentBias1 %s', uint256(currentBias));\n\n        for(uint256 i = 0; i < lockPeriod.length; i++){\n            (bool success, uint256 timeindex) = _findFasterTimeindexForLockEnd(\n                indexOfTimesetForLockEnd[lockPeriod[i]], timestamp);\n            console.logBool(success);\n            console.log('balanceOfPoint timeindex %s', timeindex);\n\n            if(success) {\n                int256 endSlop = slopeByLockEndTime[lockPeriod[i]][timeindex];\n                console.log('balanceOfPoint endSlop %s', uint256(endSlop));\n\n                if(timestamp > timeindex) {\n                    int256 endBias = endSlop * int256(timestamp - timeindex);\n                    console.log('balanceOfPoint endBias %s', uint256(endBias));\n                    currentBias += endBias;\n                    if(point.slope <= endSlop ) return 0;\n                }\n            }\n        }\n\n        (bool success1, LibLockIdTransferable.Point memory lastDelPoint) = _findFasterDeleteSlopePoint(deleteSlopeCumuluative, timestamp);\n        if (success1 && timestamp >= lastDelPoint.timestamp) {\n            // console.log(' _findFasterDeleteSlopePoint ok %s , %s ', lastDelPoint.timestamp, uint256(lastDelPoint.slope));\n            // int256 delBias = lastDelPoint.slope * int256(timestamp - lastDelPoint.timestamp);\n            // console.log('delBias %s', uint256(delBias));\n            console.log('lastDelPoint.bias %s', uint256(lastDelPoint.bias));\n            currentBias += lastDelPoint.bias;\n        }\n\n        console.log(' currentBias2 %s', uint256(currentBias));\n\n        return\n            uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n        // return\n        //     uint256(point.bias > currentBias ? (point.bias - currentBias) : int256(0)) / MULTIPLIER;\n    }\n\n    function balanceOfUnlimited(LibLockIdTransferable.UnlimitedAmount memory point, uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        if(timestamp < point.timestamp || point.amount == 0) return 0;\n        return (point.amount * MULTIPLIER / maxTime * maxTime / MULTIPLIER);\n    }\n    /*\n    /// @dev Update slope changes\n    function _updateSlopeChanges(\n        LibLockIdTransferable.SlopeChange memory changeNew,\n        LibLockIdTransferable.SlopeChange memory changeOld\n    ) internal {\n        // console.log('_updateSlopeChanges');\n        // console.log('changeNew.changeTime %s', changeNew.changeTime);\n        // console.log('changeOld.changeTime %s', changeOld.changeTime);\n\n        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];\n        // console.log('slopeChanges[changeNew.changeTime] ');\n        // console.logInt(deltaSlopeNew);\n        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];\n        // console.log('slopeChanges[changeOld.changeTime] ');\n        // console.logInt(deltaSlopeOld);\n\n        if (changeOld.changeTime > block.timestamp) {\n            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);\n            if (changeOld.changeTime == changeNew.changeTime) {\n                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);\n            }\n            slopeChanges[changeOld.changeTime] = deltaSlopeOld;\n        }\n        // console.log('--slopeChanges[changeOld.changeTime]');\n        // console.logInt(slopeChanges[changeOld.changeTime]);\n        if (\n            changeNew.changeTime > block.timestamp &&\n            changeNew.changeTime > changeOld.changeTime\n        ) {\n            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);\n            slopeChanges[changeNew.changeTime] = deltaSlopeNew;\n        }\n        // console.log('--slopeChanges[changeNew.changeTime]');\n        // console.logInt(slopeChanges[changeNew.changeTime]);\n    }\n\n    function _checkpoint(\n        LibLockIdTransferable.LockedInfo memory lockedNew,\n        LibLockIdTransferable.LockedInfo memory lockedOld\n    ) internal {\n        uint256 timestamp = block.timestamp;\n        LibLockIdTransferable.SlopeChange memory changeNew =\n            LibLockIdTransferable.SlopeChange({slope: 0, bias: 0, changeTime: 0});\n        LibLockIdTransferable.SlopeChange memory changeOld =\n            LibLockIdTransferable.SlopeChange({slope: 0, bias: 0, changeTime: 0});\n\n        // Initialize slope changes\n        if (lockedNew.end > timestamp && lockedNew.amount > 0) {\n            changeNew.slope = int256(lockedNew.amount * MULTIPLIER / maxTime);\n            changeNew.bias = changeNew.slope * int256(lockedNew.end - timestamp);\n            changeNew.changeTime = lockedNew.end;\n        }\n        if (lockedOld.end > timestamp && lockedOld.amount > 0) {\n            changeOld.slope = int256(lockedOld.amount * MULTIPLIER / maxTime);\n            changeOld.bias = changeOld.slope * int256(lockedOld.end - timestamp);\n            changeOld.changeTime = lockedOld.end;\n        }\n\n        // Record history gaps\n        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();\n        currentWeekPoint.bias = currentWeekPoint.bias + changeNew.bias - changeOld.bias;\n        currentWeekPoint.slope = currentWeekPoint.slope + changeNew.slope - changeOld.slope;\n        currentWeekPoint.bias = currentWeekPoint.bias > int256(0)? currentWeekPoint.bias: int256(0);\n        currentWeekPoint.slope = currentWeekPoint.slope > int256(0)? currentWeekPoint.slope: int256(0);\n\n\n        // console.log(\"pointHistory  index %s\", pointHistory.length - 1);\n        // console.log(\"bias\");\n        // console.logInt(currentWeekPoint.bias);\n        // console.log(\"slope\");\n        // console.logInt(currentWeekPoint.slope);\n        // console.log(\"pointHistory.timestamp %s\", currentWeekPoint.timestamp);\n\n        // Update slope changes\n        _updateSlopeChanges(changeNew, changeOld);\n    }\n\n    /// @dev Fill the gaps\n    function _recordHistoryPoints()\n        internal\n        returns (LibLockTOS.Point memory lastWeek)\n    {\n        uint256 timestamp = block.timestamp;\n        // console.log('_recordHistoryPoints timestamp %s', timestamp );\n        if (pointHistory.length > 0) {\n            lastWeek = pointHistory[pointHistory.length - 1];\n        } else {\n            lastWeek = LibLockTOS.Point({\n                bias: 0,\n                slope: 0,\n                timestamp: timestamp\n            });\n        }\n        // console.log('_recordHistoryPoints pointHistory.length %s', pointHistory.length );\n\n        // Iterate through all past unrecoreded weeks and record\n        uint256 pointTimestampIterator =\n            lastWeek.timestamp.div(epochUnit).mul(epochUnit);\n\n        // console.log('pointTimestampIterator %s', pointTimestampIterator );\n\n        while (pointTimestampIterator != timestamp) {\n            pointTimestampIterator = Math.min(\n                pointTimestampIterator.add(epochUnit),\n                timestamp\n            );\n            // console.log('pointTimestampIterator Math.min(timestamp) %s', pointTimestampIterator );\n            int256 deltaSlope = slopeChanges[pointTimestampIterator];\n            int256 deltaTime =\n                Math.min(pointTimestampIterator.sub(lastWeek.timestamp), epochUnit).toInt256();\n            lastWeek.bias = lastWeek.bias.sub(lastWeek.slope.mul(deltaTime));\n            lastWeek.slope = lastWeek.slope.add(deltaSlope);\n            lastWeek.bias = lastWeek.bias > 0 ? lastWeek.bias : int256(0);\n            lastWeek.slope = lastWeek.slope > 0 ? lastWeek.slope : int256(0);\n            lastWeek.timestamp = pointTimestampIterator;\n\n            // console.log('pointHistory.push lastWeek.timestamp %s', lastWeek.timestamp );\n            pointHistory.push(lastWeek);\n        }\n        // console.log('pointHistory.length %s', pointHistory.length );\n        // console.log('lastWeek %s', lastWeek.timestamp );\n\n        return lastWeek;\n    }\n    */\n    function allIndexOfTimes() public view returns(uint256[] memory){\n        return indexOfTimeset;\n    }\n\n    function allIndexOfUnlimitedTimes() public view returns(uint256[] memory){\n        return indexOfTimesetForUnlimited;\n    }\n\n    function _findClosestPoint(\n        LibLockIdTransferable.Point[] storage _history,\n        uint256 _timestamp\n    ) internal view returns(bool success, LibLockIdTransferable.Point memory point) {\n        if (_history.length == 0) {\n            console.log('_findClosestPoint _history.length == 0 _timestamp %s', _timestamp);\n            return (false, point);\n        }\n        // console.log('_findClosestPoint _timestamp %s', _timestamp);\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n            // console.log('_findClosestPoint left %s, _history[left].timestamp %s', left, _history[left].timestamp);\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        // console.log('_findClosestPoint false point.timestamp %s , _timestamp  %s', point.timestamp, _timestamp);\n\n        return (false, point);\n    }\n\n    function _findClosestUnlimitedPoint(\n        LibLockIdTransferable.UnlimitedAmount[] storage _history,\n        uint256 _timestamp\n    ) internal view returns(bool success, LibLockIdTransferable.UnlimitedAmount memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    function _findFasterTimeindexForLockEnd(\n        uint256[] memory sets,\n        uint256 _timestamp\n    ) internal view returns(bool success, uint256 timeindex) {\n\n        uint256 totalLen = sets.length;\n        uint256 timeIndexKey = _timestamp / epochUnit * epochUnit ;\n        // console.log('_findClosestTimeindexForLockEnd timeIndexKey %s', timeIndexKey);\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (sets[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (sets[left] <= timeIndexKey) {\n            return (true, sets[left]);\n        }\n        return (false, 0);\n    }\n\n    function _findFasterDeleteSlopePoint(\n        LibLockIdTransferable.Point[] memory sets,\n        uint256 _timestamp\n    ) internal view returns(bool success, LibLockIdTransferable.Point memory point) {\n\n        uint256 totalLen = sets.length;\n\n        if (totalLen == 0) {\n            return (false, point);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (sets[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (sets[left].timestamp <= _timestamp) {\n            return (true, sets[left]);\n        }\n        return (false, point);\n    }\n\n    function _findClosestTimeindex(\n        uint256 _timestamp\n    ) public view returns(bool success, uint256 timeindex) {\n        uint256 totalLen = indexOfTimeset.length;\n        uint256 timeIndexKey =  (_timestamp + epochUnit) * epochUnit / epochUnit ;\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (indexOfTimeset[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (indexOfTimeset[left] <= timeIndexKey) {\n            return (true, indexOfTimeset[left]);\n        }\n        return (false, 0);\n    }\n    /*\n    function _findClosestUnlimitedTimeindex(\n        uint256 _timestamp\n    ) public view returns(bool success, uint256 timeindex) {\n        uint256 totalLen = indexOfTimesetForUnlimited.length;\n        uint256 timeIndexKey =  (_timestamp + epochUnit) * epochUnit / epochUnit ;\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (indexOfTimesetForUnlimited[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (indexOfTimesetForUnlimited[left] <= timeIndexKey) {\n            return (true, indexOfTimesetForUnlimited[left]);\n        }\n        return (false, 0);\n    }\n    */\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId); // internal owner\n    }\n}\n"
    },
    "contracts/stos/LockIdRegisterStorage1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./ERC165P.sol\";\n\ncontract LockIdRegisterStorage1 is ERC165P {\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 public constant _ERC721_RECEIVED = 0x150b7a02;\n\n    address public _manager;\n\n    // Token name\n    string public _name;\n\n    // Token symbol\n    string public _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) public _tokenURIs;\n\n    // attributes\n    mapping (uint256 => uint8) public _tokenAttributes;\n\n    // Base URI\n    string public _baseURI;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) public _tokenOwner; // _owners\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) public _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) public _ownedTokensCount; // _balances\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) public _operatorApprovals;\n\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) public _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) public _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] public _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) public _allTokensIndex;\n\n    bool internal _lock;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier ifFree {\n        require(_lock != true, \"in use\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n\n}\n"
    },
    "contracts/stos/LockIdRegisterStorage2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries//LibLockId.sol\";\n\ncontract LockIdRegisterStorage2 {\n\n    uint256 public constant MULTIPLIER = 1e18;\n\n    uint256 public epochUnit;\n    uint256 public maxTime;\n\n    // id - point , 특정아이디의 포인트를 모두 저장\n    mapping(uint256 => LibLockId.SyncInfo[]) public pointHistoryByLockId;\n\n    // 시간대순으로 모든 stos를 관리하는 정보\n    // 시간대의 타임 (매주목요일0시) -> 해당 시간대의 포인트 배열\n    mapping(uint256 => LibLockId.SyncInfo[]) public pointHistoryByWeek;\n\n    // 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimeset;\n    mapping(uint256 => bool) public indexCheckOfTimeset;\n}\n"
    },
    "contracts/stos/LockIdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/LibLockId.sol\";\n\ncontract LockIdStorage {\n\n    uint256 public constant MULTIPLIER = 1e18;\n\n    address public tos;\n    uint256 public epochUnit;\n    uint256 public maxTime;\n    //\n    uint256 public maxTokenId;\n\n    // 락 기본 정보\n    mapping(uint256 => LibLockId.LockedInfo) public lockIdInfos;\n\n    // id - point , 특정아이디의 포인트를 모두 저장\n    mapping(uint256 => LibLockId.Point[]) public pointHistoryByLockId;\n\n    // 시간대순으로 모든 stos를 관리하는 정보\n    // 시간대의 타임 (매주목요일0시) -> 해당 시간대의 포인트 배열\n    mapping(uint256 => LibLockId.Point[]) public pointHistoryByWeek;\n\n    // 무제한 락업 시간대의 타임 (매주목요일0시) - UnlimitedAmount\n    mapping(uint256 => LibLockId.UnlimitedAmount[]) public unlimitedHistoryByWeek;\n\n    // 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimeset;\n    mapping(uint256 => bool) public indexCheckOfTimeset;\n\n    // 무제한 락업 account - UnlimitedAmount\n    mapping(address => LibLockId.UnlimitedAmount[]) public unlimitedAmountByAccount;\n\n    // 무제한 락업에 대한 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimesetForUnlimited;\n    mapping(uint256 => bool) public indexCheckOfTimesetForUnlimited;\n\n    // 락 기간 정보\n    uint256[] public lockPeriod;\n    mapping(uint256 => bool) public existedLockPeriod;\n\n    // lockPeriod- 락 종료시간(end time) - 줄어드는 누적 slope\n    mapping(uint256 => mapping(uint256 => int256)) public slopeByLockEndTime;\n    mapping(uint256 => uint256[]) public indexOfTimesetForLockEnd;\n    mapping(uint256 => mapping(uint256 => bool)) public indexCheckOfTimesetForLockEnd;\n}\n"
    },
    "contracts/stos/LockIdStorage1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/LibLockIdTransferable.sol\";\n\ncontract LockIdStorage1 {\n\n    uint256 public constant MULTIPLIER = 1e18;\n\n    address public tos;\n    uint256 public epochUnit;\n    uint256 public maxTime;\n    //\n    uint256 public maxTokenId;\n\n    // 락 기본 정보\n    mapping(uint256 => LibLockIdTransferable.LockedInfo) public lockIdInfos;\n\n    // id - point , 특정아이디의 포인트를 모두 저장\n    mapping(uint256 => LibLockIdTransferable.Point[]) public pointHistoryByLockId;\n\n    // 시간대순으로 모든 stos를 관리하는 정보\n    // 시간대의 타임 (매주목요일0시) -> 해당 시간대의 포인트 배열\n    mapping(uint256 => LibLockIdTransferable.Point[]) public pointHistoryByWeek;\n\n    // 무제한 락업 시간대의 타임 (매주목요일0시) - UnlimitedAmount\n    mapping(uint256 => LibLockIdTransferable.UnlimitedAmount[]) public unlimitedHistoryByWeek;\n\n    // 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimeset;\n    mapping(uint256 => bool) public indexCheckOfTimeset;\n\n    // 무제한 락업 account - UnlimitedAmount\n    mapping(address => LibLockIdTransferable.UnlimitedAmount[]) public unlimitedAmountByAccount;\n\n    // 무제한 락업에 대한 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimesetForUnlimited;\n    mapping(uint256 => bool) public indexCheckOfTimesetForUnlimited;\n\n    // 락 기간 정보\n    uint256[] public lockPeriod;\n    mapping(uint256 => bool) public existedLockPeriod;\n\n    // 변화된 slope을 모두 기록한다.\n    mapping(uint256 => int256) public slopeChanges;\n\n    // lockPeriod- 락 종료시간(end time) - 줄어드는 누적 slope\n    mapping(uint256 => mapping(uint256 => int256)) public slopeByLockEndTime;\n    mapping(uint256 => uint256[]) public indexOfTimesetForLockEnd;\n    mapping(uint256 => mapping(uint256 => bool)) public indexCheckOfTimesetForLockEnd;\n\n    // 실시간 삭제\n    LibLockIdTransferable.Point[] public deleteSlopeCumuluative;\n}\n"
    },
    "contracts/stos/LockTOSv2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../common/AccessibleCommon.sol\";\nimport \"./LockTOSv2Storage.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n// import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nimport \"../libraries/LibLockTOSv2.sol\";\nimport \"../interfaces/ILockTOSv2.sol\";\nimport \"../interfaces/ILockTOSv2Event.sol\";\nimport \"../interfaces/ITOS.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LockTOSv2 is LockTOSv2Storage, AccessibleCommon, IERC721, ILockTOSv2Event {\n    // using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n\n    /// @dev Check if a function is used or not\n    modifier ifFree {\n        require(free == 1, \"LockId is already in use\");\n        free = 0;\n        _;\n        free = 1;\n    }\n\n    constructor(string memory _name, string memory _symbol) {\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        name = _name;\n        name = _symbol;\n    }\n\n\n    /** onlyOwner  */\n    function initialize(\n        address _tos,\n        uint256 _epochUnit,\n        uint256 _maxTime\n    ) external onlyOwner {\n        require(tos == address(0), \"Already initialized\");\n        tos = _tos;\n        epochUnit = _epochUnit;\n        maxTime = _maxTime;\n    }\n\n    function setMaxTime(uint256 _maxTime) external onlyOwner {\n        maxTime = _maxTime;\n    }\n\n    /** external  */\n\n    function transferFrom(address from, address to, uint256 tokenId) external virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n\n    function transferFromUnlimited(address from, address to, uint256 amount) external virtual {\n        address spender = msg.sender;\n        require (spender == from || isApprovedForAll(from, spender), \"not approved\");\n\n        _increaseUnlimitedAccount(from, amount, false, false);\n        _increaseUnlimitedAccount(to, amount, true, false);\n\n        emit TransferUnlimitedLock(from, to, amount);\n    }\n\n    function createLock(uint256 _value, uint256 _unlockWeeks)\n        public\n        returns (uint256 lockId)\n    {\n        require(_value > 0, \"Value locked should be non-zero\");\n        require(_unlockWeeks > 0, \"Unlock period less than a week\");\n\n        cumulativeEpochUnit = cumulativeEpochUnit + _unlockWeeks;\n        cumulativeTOSAmount = cumulativeTOSAmount + _value;\n        uint256 unlockTime = block.timestamp + (_unlockWeeks * epochUnit);\n        unlockTime = unlockTime / epochUnit * epochUnit;\n        require(\n            unlockTime - block.timestamp <= maxTime,\n            \"Max unlock time is 3 years\"\n        );\n\n        lockId = ++lockIdCounter;\n\n        _deposit(msg.sender, lockId, _value, unlockTime, true, true);\n\n        userLocksCheck[msg.sender][lockId] = true;\n        userLocks[msg.sender].push(lockId);\n\n        emit LockCreated(msg.sender, lockId, _value, unlockTime);\n    }\n\n    function increaseAmount(uint256 _lockId, uint256 _value) external {\n        depositFor(msg.sender, _lockId, _value);\n    }\n\n    function increaseUnlockTime(uint256 _lockId, uint256 _unlockWeeks)\n        external\n    {\n        require(_unlockWeeks > 0, \"Unlock period less than a week\");\n        cumulativeEpochUnit = cumulativeEpochUnit + _unlockWeeks;\n\n        LibLockTOSv2.LockedBalance memory lock = allLocks[_lockId];\n        require(lock.owner == msg.sender, \"lockId's owner is not caller\");\n\n        uint256 unlockTime = lock.end + (_unlockWeeks * epochUnit);\n        unlockTime = unlockTime / epochUnit * epochUnit;\n        require(\n            unlockTime - block.timestamp < maxTime,\n            \"Max unlock time is 3 years\"\n        );\n        require(lock.end > block.timestamp, \"Lock time already finished\");\n        require(lock.end < unlockTime, \"New lock time must be greater\");\n        require(lock.amount > 0, \"No existing locked TOS\");\n        _deposit(msg.sender, _lockId, 0, unlockTime, true, false);\n\n        emit LockUnlockTimeIncreased(msg.sender, _lockId, unlockTime);\n    }\n\n    function increaseLock(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockWeeks)\n        external\n    {\n        require(_value > 0 || _unlockWeeks > 0, \"Unlock period less than a week\");\n        require(_addr == msg.sender, \"sender is not addr\");\n\n        LibLockTOSv2.LockedBalance memory lock = allLocks[_lockId];\n        require(lock.owner == msg.sender, \"lockId's owner is not caller\");\n\n        uint256 unlockTime = (lock.end + (_unlockWeeks * epochUnit)) / epochUnit * epochUnit;\n\n        require(\n            unlockTime - block.timestamp < maxTime,\n            \"Max unlock time is 3 years\"\n        );\n        require(lock.end > block.timestamp, \"Lock time already finished\");\n        require(lock.end < unlockTime, \"New lock time must be greater\");\n        require(lock.amount > 0, \"No existing locked TOS\");\n\n        if(_unlockWeeks > 0)\n            cumulativeEpochUnit = cumulativeEpochUnit + _unlockWeeks;\n\n        _deposit(msg.sender, _lockId, _value, unlockTime, true, true);\n\n        emit LockIncreased(msg.sender, _lockId, _value, unlockTime);\n    }\n\n    function increaseUnlimitedLock(address account, uint256 amount)\n        public nonZero(amount)\n    {\n        // caller 는 무조건 스테이커가 가능하게 하도록 수정되어야 함 .\n        require(msg.sender == account, 'caller is not account');\n        cumulativeTOSAmount = cumulativeTOSAmount + amount;\n\n        _increaseUnlimitedAccount(account, amount, true, true);\n        _increaseUnlimitedHistory(amount, true);\n        // checkUniqueUser(account);\n\n        emit IncreasedUnlimitedLock(msg.sender, account, amount);\n    }\n\n    function decreaseUnlimitedLock(address account, uint256 amount)\n        public nonZero(amount)\n    {\n        // caller 는 무조건 스테이커가 가능하게 하도록 수정되어야 함 .\n        require(msg.sender == account, 'caller is not account');\n\n        _increaseUnlimitedAccount(account, amount, false, false);\n        _increaseUnlimitedHistory(amount, false);\n\n        /////////////////////////////////////////////////\n        // 락아이디로 변경\n        uint256 unlockTime = (block.timestamp + ((maxTime / epochUnit) * epochUnit)) / epochUnit * epochUnit;\n        uint256 lockId = ++lockIdCounter;\n\n        _deposit(account, lockId, amount, unlockTime, true, false);\n        userLocksCheck[account][lockId] = true;\n        userLocks[account].push(lockId);\n\n        emit DecreasedUnlimitedLock(msg.sender, account, amount);\n        emit LockCreated(account, lockId, amount, unlockTime);\n    }\n\n    function withdrawAll() external ifFree {\n        uint256[] storage locks = userLocks[msg.sender];\n        if (locks.length == 0) {\n            return;\n        }\n\n        for (uint256 i = 0; i < locks.length; i++) {\n            LibLockTOSv2.LockedBalance memory lock = allLocks[locks[i]];\n            if (\n                lock.withdrawalTime == 0 &&\n                locks[i] > 0 &&\n                lock.amount > 0 &&\n                lock.start > 0 &&\n                lock.end > 0 &&\n                lock.end < block.timestamp &&\n                lock.owner == msg.sender\n            ) {\n                _withdraw(locks[i]);\n            }\n        }\n    }\n\n    function totalLockedAmountOf(address _addr) external view returns (uint256) {\n        return totalLockedAmountOfLock(_addr) + balanceOfUnlimitedAmount(_addr);\n    }\n\n\n    /** public  */\n\n    function approve(address to, uint256 tokenId) public virtual {\n        address owner_ = ownerOf(tokenId);\n        require(to != owner_, \"approval to current owner\");\n\n        require(msg.sender == owner_ || isApprovedForAll(owner_, msg.sender),\n            \"approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != msg.sender, \"approve to caller\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) public {\n        require(_value > 0, \"Value locked should be non-zero\");\n        // require(userLocksCheck[_addr][_lockId], \"it is not your lockId\");\n        LibLockTOSv2.LockedBalance memory lock = allLocks[_lockId];\n        require(lock.owner == _addr, \"lockId's owner is not addr\");\n        require(lock.withdrawalTime == 0, \"Lock is withdrawn\");\n        require(lock.start > 0, \"Lock does not exist\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        cumulativeTOSAmount = cumulativeTOSAmount + _value;\n\n        _deposit(_addr, _lockId, _value, 0, true, true);\n        emit LockDeposited(msg.sender, _lockId, _value);\n    }\n\n    function withdraw(uint256 _lockId) public  ifFree {\n        require(_lockId > 0, \"_lockId is zero\");\n        _withdraw(_lockId);\n    }\n\n    /** view  */\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return allLocks[tokenId].owner;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        require(_exists(tokenId), \"nonexistent token\");\n\n        string memory _tokenURI = tokenURIs[tokenId];\n        string memory base = baseURI;\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n    }\n\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        require(_exists(tokenId), \"LockIdNFT: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function totalSupply() external view returns (uint256) {\n         return lockIdCounter;\n    }\n\n    function totalSupplyStos() external view returns (uint256) {\n         return totalSupplyBalance() + totalSupplyUnlimited();\n    }\n\n    function totalSupplyStosAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return totalSupplyBalanceAt(_timestamp) + totalSupplyUnlimitedAt(_timestamp);\n    }\n\n    function totalSupplyBalance()\n        public\n        view\n        returns (uint256)\n    {\n        if (pointHistory.length == 0) return 0;\n\n        LibLockTOSv2.Point memory point = _fillRecordGaps(\n            pointHistory[pointHistory.length - 1],\n            block.timestamp\n        );\n\n        int256 currentBias = point.slope * int256(block.timestamp - point.timestamp);\n        return\n            uint256(point.bias > currentBias ? point.bias-(currentBias) : int256(0)) / MULTIPLIER;\n    }\n\n    function totalSupplyBalanceAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        if (pointHistory.length == 0)  return 0;\n        (bool success, LibLockTOSv2.Point memory point) = _findClosestPoint(pointHistory, _timestamp);\n        if (!success)   return 0;\n\n        point = _fillRecordGaps(point, _timestamp);\n        int256 currentBias = point.slope * int256(_timestamp-point.timestamp);\n        return\n            uint256(point.bias > currentBias ? point.bias - currentBias : int256(0)) / MULTIPLIER;\n    }\n\n    function totalSupplyUnlimited()\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 마지막 포인트\n        LibLockTOSv2.UnlimitedAmount memory pointLast = lastPointOfTimeIndexForUnlimited(\n                        (indexOfTimesetForUnlimited.length != 0 ? indexOfTimesetForUnlimited[indexOfTimesetForUnlimited.length - 1]:0)\n                    );\n       amount = balanceOfUnlimitedAt(pointLast, block.timestamp);\n    }\n\n    function totalSupplyUnlimitedAt(uint256 _timestamp)\n        public\n        view\n        returns (uint256 amount)\n    {\n        // 해당 타임에 맞는 타임인덱스\n        (bool success, uint256 timeindex) = _findClosestUnlimitedTimeindex(_timestamp);\n        if(!success) return 0;\n        (bool success1, LibLockTOSv2.UnlimitedAmount memory point) = _findClosestUnlimitedPoint(unlimitedHistoryByWeek[timeindex], _timestamp);\n        if(!success1) return 0;\n        amount = balanceOfUnlimitedAt(point, _timestamp);\n    }\n\n    function balanceOfLock(uint256 _lockId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 len = lockPointHistory[_lockId].length;\n        if (len == 0) {\n            return 0;\n        }\n\n        LibLockTOSv2.Point memory point = lockPointHistory[_lockId][len - 1];\n\n        int256 currentBias = point.slope * int256(block.timestamp - point.timestamp);\n\n        return\n            uint256(point.bias > currentBias ? point.bias - currentBias : int256(0)) / MULTIPLIER;\n    }\n\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        (bool success, LibLockTOSv2.Point memory point) =\n            _findClosestPoint(lockPointHistory[_lockId], _timestamp);\n        if (!success) {\n            return 0;\n        }\n        int256 currentBias = point.slope * int256(_timestamp-point.timestamp);\n        return  uint256(point.bias > currentBias ? point.bias-currentBias : int256(0)) / MULTIPLIER;\n    }\n\n    function balanceOf(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        return userLocks[_addr].length;\n    }\n\n    function balanceOfStos(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        return balanceOfLock(_addr) + balanceOfUnlimited(_addr);\n    }\n\n    function balanceOfStosAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        return balanceOfLockAt(_addr, _timestamp) + balanceOfUnlimitedAt(_addr, _timestamp);\n    }\n\n    function balanceOfLock(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = userLocks[_addr];\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance = balance + balanceOfLock(locks[i]);\n        }\n    }\n\n    function balanceOfLockAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = userLocks[_addr];\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance = balance + balanceOfLockAt(locks[i], _timestamp);\n        }\n    }\n\n    function balanceOfUnlimited(address _addr)\n        public\n        view\n        returns (uint256 balance)\n    {\n        uint256 len = unlimitedAmountByAccount[_addr].length;\n        balance = (len == 0? 0: balanceOfUnlimitedAt(unlimitedAmountByAccount[_addr][len - 1], block.timestamp));\n        // if (len==0) return 0;\n        // LibLockTOSv2.UnlimitedAmount memory point = unlimitedAmountByAccount[_addr][len - 1];\n        // if(block.timestamp < point.timestamp || point.amount == 0) return 0;\n        // return (point.amount * MULTIPLIER / maxTime * maxTime / MULTIPLIER);\n    }\n\n    function balanceOfUnlimitedAt(address _addr, uint256 _timestamp)\n        public\n        view\n        returns (uint256 balance)\n    {\n        (bool success, LibLockTOSv2.UnlimitedAmount memory point) = _findClosestUnlimitedPoint(unlimitedAmountByAccount[_addr], _timestamp);\n        balance = (!success? 0: balanceOfUnlimitedAt(point, _timestamp));\n    }\n\n    function balanceOfUnlimitedAt(LibLockTOSv2.UnlimitedAmount memory point, uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        if(timestamp < point.timestamp || point.amount == 0) return 0;\n        return (point.amount * MULTIPLIER / maxTime * maxTime / MULTIPLIER);\n    }\n\n    function balanceOfUnlimitedAmount(address _addr)\n        public\n        view\n        returns (uint256 amount)\n    {\n        uint256 len = unlimitedAmountByAccount[_addr].length;\n        amount = (len == 0? 0: unlimitedAmountByAccount[_addr][len - 1].amount);\n    }\n\n    function needCheckpoint() external view returns (bool need) {\n        uint256 len = pointHistory.length;\n        if (len == 0) {\n            return true;\n        }\n        need = (block.timestamp - pointHistory[len - 1].timestamp) > epochUnit; // if the last record was within a week\n    }\n\n    function lastPointOfTimeIndexForUnlimited(uint256 _index) public view returns (LibLockTOSv2.UnlimitedAmount memory) {\n\n        LibLockTOSv2.UnlimitedAmount[] memory points = unlimitedHistoryByWeek[_index];\n\n        if (points.length != 0) {\n            return LibLockTOSv2.UnlimitedAmount({\n                timestamp: points[points.length-1].timestamp,\n                amount: points[points.length-1].amount\n            });\n        }\n\n        return LibLockTOSv2.UnlimitedAmount({\n            timestamp: 0,\n            amount: 0\n        });\n    }\n\n\n    function nextTimeIndex(uint256 _stime) public view returns(uint256) {\n        return (_stime +  epochUnit) / epochUnit * epochUnit;\n    }\n\n    function globalCheckpoint() external {\n        _recordHistoryPoints();\n    }\n\n    function totalLockedAmountOfLock(address _addr) public view returns (uint256) {\n        uint256 len = userLocks[_addr].length;\n        uint256 stakedAmount = 0;\n        for (uint256 i = 0; i < len; ++i) {\n            uint256 lockId = userLocks[_addr][i];\n            if (userLocksCheck[_addr][lockId]) {\n                LibLockTOSv2.LockedBalance memory lock = allLocks[lockId];\n                stakedAmount = stakedAmount + lock.amount;\n            }\n        }\n        return stakedAmount;\n    }\n\n    function withdrawableAmountOf(address _addr) external view returns (uint256) {\n        uint256 len = userLocks[_addr].length;\n        uint256 amount = 0;\n        for(uint i = 0; i < len; i++){\n            uint256 lockId = userLocks[_addr][i];\n            if (userLocksCheck[_addr][lockId]) {\n                LibLockTOSv2.LockedBalance memory lock = allLocks[lockId];\n                if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawalTime == 0) {\n                    amount = amount + lock.amount;\n                }\n            }\n\n        }\n        return amount;\n    }\n\n    function locksInfo(uint256 _lockId)\n        public\n        view\n        returns (LibLockTOSv2.LockedBalance memory   )\n    {\n        return allLocks[_lockId];\n    }\n\n    function locksOf(address _addr)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return userLocks[_addr];\n    }\n\n    function withdrawableLocksOf(address _addr)  external view returns (uint256[] memory) {\n        uint256 len = userLocks[_addr].length;\n        uint256 size = 0;\n        for(uint i = 0; i < len; i++){\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOSv2.LockedBalance memory lock = allLocks[lockId];\n            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawalTime == 0) {\n                size++;\n            }\n        }\n\n        uint256[] memory withdrawable = new uint256[](size);\n        size = 0;\n        for(uint i = 0; i < len; i++) {\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOSv2.LockedBalance memory lock = allLocks[lockId];\n            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawalTime == 0) {\n                withdrawable[size++] = lockId;\n            }\n        }\n        return withdrawable;\n    }\n\n    function pointHistoryOf(uint256 _lockId)\n        public\n        view\n        returns (LibLockTOSv2.Point[] memory)\n    {\n        return lockPointHistory[_lockId];\n    }\n\n\n    function getCurrentTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    // function currentStakedTotalTOS() external view returns (uint256) {\n    //     return IERC20(tos).balanceOf(address(this));\n    // }\n\n\n    /** internal  */\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"LockIdNFT: operator query for nonexistent token\");\n        address owner_ = ownerOf(tokenId);\n        return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));\n    }\n\n    function isApprovedForAll(address owner_, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner_][operator];\n    }\n\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        // require(ownerOf(tokenId) == from, \"ProjectToken: transfer of token that is not own\");\n        require(to != address(0), \"to is zero address\");\n\n        // 기본정보 수정\n        LibLockTOSv2.LockedBalance memory lock = allLocks[tokenId];\n        require(lock.owner == from, \"transfer of token that is not own\");\n        require(lock.withdrawalTime == 0, \"It is withdrawn already.\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        allLocks[tokenId].withdrawalTime = block.timestamp;\n        allLocks[tokenId].owner = address(0);\n        allLocks[tokenId].start = 0;\n        allLocks[tokenId].end = 0;\n        allLocks[tokenId].amount = 0;\n\n        LibLockTOSv2.Point memory userPoint =\n            LibLockTOSv2.Point({\n                timestamp: block.timestamp,\n                slope: 0,\n                bias: 0\n            });\n        lockPointHistory[tokenId].push(userPoint);\n\n        // 새로 락업아이디 추가 .\n        uint256 newLockId = ++lockIdCounter;\n\n        _deposit(to, newLockId, lock.amount, lock.end, false, false);\n\n        userLocksCheck[to][newLockId] = true;\n        userLocks[to].push(newLockId);\n        // checkUniqueUser(to);\n\n        emit Transfer(address(0), from, newLockId);\n        emit Transfer(from, to, newLockId);\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        // LibLockTOSv2.LockedBalance memory token_ = allLocks[tokenId];\n        address owner_ = allLocks[tokenId].owner;\n        return owner_ != address(0);\n    }\n\n    function _increaseUnlimitedAccount(address account, uint256 amount, bool increasement, bool boolTransfer)\n        internal {\n\n        uint256 accountlen = unlimitedAmountByAccount[account].length;\n        uint256 prevAmount = 0;\n        if (accountlen != 0) {\n            prevAmount = unlimitedAmountByAccount[account][accountlen-1].amount;\n        }\n        if(!increasement) {\n            require(accountlen != 0, 'no unlimited amount');\n            require(prevAmount >= amount, 'unlimitedAmount is insufficient');\n        }\n\n        LibLockTOSv2.UnlimitedAmount memory afterInfo = LibLockTOSv2.UnlimitedAmount({\n                timestamp: uint32(block.timestamp),\n                amount: (increasement? prevAmount+amount: prevAmount-amount)\n        });\n\n        unlimitedAmountByAccount[account].push(afterInfo);\n\n        if(boolTransfer && amount != 0) {\n            require(\n                IERC20(tos).transferFrom(msg.sender, address(this), amount),\n                \"_increaseUnlimitedAccount transferFrom fail\"\n            );\n        }\n    }\n\n    function _increaseUnlimitedHistory(uint256 amount, bool increasement) internal {\n        uint256 nextTimeIndexOfTotalPoint = nextTimeIndex(block.timestamp);\n        uint256 len = unlimitedHistoryByWeek[nextTimeIndexOfTotalPoint].length;\n        LibLockTOSv2.UnlimitedAmount memory pointLast ; // 가장 최근의 point\n\n\n        if (len == 0 ) {\n            // 가장 최근 인덱스\n            pointLast = lastPointOfTimeIndexForUnlimited(\n                        (indexOfTimesetForUnlimited.length != 0 ? indexOfTimesetForUnlimited[indexOfTimesetForUnlimited.length - 1]:0)\n                    );\n        } else {\n            pointLast = unlimitedHistoryByWeek[nextTimeIndexOfTotalPoint][len-1];\n        }\n\n        if(!increasement) require(pointLast.amount >= amount, 'insufficient unlimited amount');\n\n        LibLockTOSv2.UnlimitedAmount memory pointNew = LibLockTOSv2.UnlimitedAmount({\n            timestamp : uint32(block.timestamp),\n            amount: pointLast.amount\n        });\n\n        if(increasement) pointNew.amount += amount;\n        else pointNew.amount -= amount;\n        unlimitedHistoryByWeek[nextTimeIndexOfTotalPoint].push(pointNew);\n\n        if(!indexCheckOfTimesetForUnlimited[nextTimeIndexOfTotalPoint]) {\n            indexCheckOfTimesetForUnlimited[nextTimeIndexOfTotalPoint] = true;\n            indexOfTimesetForUnlimited.push(nextTimeIndexOfTotalPoint);\n        }\n    }\n\n\n    /// @dev Send staked amount back to user\n    function _withdraw(uint256 _lockId) internal {\n\n        // require(userLocksCheck[msg.sender][_lockId], \"it is not your lockId\");\n        LibLockTOSv2.LockedBalance memory lockedOld = allLocks[_lockId];\n        require(lockedOld.owner == msg.sender, \"lockId's owner is not caller\");\n        require(lockedOld.withdrawalTime == 0, \"Already withdrawn\");\n        require(lockedOld.start > 0, \"Lock does not exist\");\n        require(lockedOld.end < block.timestamp, \"Lock time not finished\");\n        require(lockedOld.amount > 0, \"No amount to withdraw\");\n\n        LibLockTOSv2.LockedBalance memory lockedNew =\n            LibLockTOSv2.LockedBalance({\n                amount: 0,\n                start: 0,\n                end: 0,\n                owner: address(0),\n                withdrawalTime: block.timestamp\n            });\n\n        // Checkpoint\n        _checkpoint(lockedNew, lockedOld);\n\n        // Transfer TOS back\n        uint256 amount = lockedOld.amount;\n        // userLocksCheck[lockedOld.owner][_lockId] = true;\n        allLocks[_lockId] = lockedNew;\n        userLocksCheck[lockedOld.owner][_lockId] = false;\n\n        IERC20(tos).transfer(msg.sender, amount);\n        emit LockWithdrawn(msg.sender, _lockId, amount);\n    }\n\n\n    /// @dev Finds closest point\n    function _findClosestPoint(\n        LibLockTOSv2.Point[] storage _history,\n        uint256 _timestamp\n    ) internal view returns (bool success, LibLockTOSv2.Point memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    /// @dev Deposit\n    function _deposit(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockTime,\n        bool _boolCheckPoint,\n        bool _tokenTransfer\n    ) internal ifFree {\n\n        LibLockTOSv2.LockedBalance memory lockedOld = allLocks[_lockId];\n        LibLockTOSv2.LockedBalance memory lockedNew =\n            LibLockTOSv2.LockedBalance({\n                amount: lockedOld.amount,\n                start: lockedOld.start,\n                end: lockedOld.end,\n                owner: _addr,\n                withdrawalTime: 0\n            });\n\n        // Make new lock\n        lockedNew.amount = lockedNew.amount  + _value;\n        if (_unlockTime > 0) {\n            lockedNew.end = _unlockTime;\n        }\n        if (lockedNew.start == 0) {\n            lockedNew.start = block.timestamp;\n        }\n\n        // Checkpoint\n        if (_boolCheckPoint) _checkpoint(lockedNew, lockedOld);\n\n        // Save new lock\n        allLocks[_lockId] = lockedNew;\n\n        // Save user point,\n        int256 userSlope =int256(lockedNew.amount * MULTIPLIER / maxTime);\n        int256 userBias =userSlope * int256(lockedNew.end-block.timestamp);\n        LibLockTOSv2.Point memory userPoint =\n            LibLockTOSv2.Point({\n                timestamp: block.timestamp,\n                slope: userSlope,\n                bias: userBias\n            });\n        lockPointHistory[_lockId].push(userPoint);\n\n        // Transfer TOS\n        if (_tokenTransfer && _value != 0)\n            require(\n                IERC20(tos).transferFrom(msg.sender, address(this), _value),\n                \"LockTOS: fail transferFrom\"\n            );\n    }\n\n    /// @dev Checkpoint\n    function _checkpoint(\n        LibLockTOSv2.LockedBalance memory lockedNew,\n        LibLockTOSv2.LockedBalance memory lockedOld\n    ) internal {\n        uint256 timestamp = block.timestamp;\n        LibLockTOSv2.SlopeChange memory changeNew =\n            LibLockTOSv2.SlopeChange({slope: 0, bias: 0, changeTime: 0});\n        LibLockTOSv2.SlopeChange memory changeOld =\n            LibLockTOSv2.SlopeChange({slope: 0, bias: 0, changeTime: 0});\n\n        // Initialize slope changes\n        if (lockedNew.end > timestamp && lockedNew.amount > 0) {\n            changeNew.slope = int256(lockedNew.amount * MULTIPLIER / maxTime);\n            changeNew.bias = changeNew.slope * int256(lockedNew.end - timestamp);\n            changeNew.changeTime = lockedNew.end;\n        }\n        if (lockedOld.end > timestamp && lockedOld.amount > 0) {\n            changeOld.slope = int256(lockedOld.amount * MULTIPLIER / maxTime);\n            changeOld.bias = changeOld.slope * int256(lockedOld.end - timestamp);\n            changeOld.changeTime = lockedOld.end;\n        }\n\n        // Record history gaps\n        LibLockTOSv2.Point memory currentWeekPoint = _recordHistoryPoints();\n        currentWeekPoint.bias = currentWeekPoint.bias + (changeNew.bias - changeOld.bias);\n        currentWeekPoint.slope = currentWeekPoint.slope + (changeNew.slope - changeOld.slope);\n        currentWeekPoint.bias = currentWeekPoint.bias > int256(0)\n            ? currentWeekPoint.bias\n            : int256(0);\n        currentWeekPoint.slope = currentWeekPoint.slope > int256(0)\n            ? currentWeekPoint.slope\n            : int256(0);\n        pointHistory[pointHistory.length - 1] = currentWeekPoint;\n\n        // Update slope changes\n        _updateSlopeChanges(changeNew, changeOld);\n    }\n\n    /// @dev Fill the gaps\n    function _recordHistoryPoints()\n        internal\n        returns (LibLockTOSv2.Point memory lastWeek)\n    {\n        uint256 timestamp = block.timestamp;\n        // console.log('_recordHistoryPoints timestamp %s', timestamp );\n        if (pointHistory.length > 0) {\n            lastWeek = pointHistory[pointHistory.length - 1];\n        } else {\n            lastWeek = LibLockTOSv2.Point({\n                bias: 0,\n                slope: 0,\n                timestamp: timestamp\n            });\n        }\n        // console.log('_recordHistoryPoints pointHistory.length %s', pointHistory.length );\n\n        // Iterate through all past unrecoreded weeks and record\n        uint256 pointTimestampIterator = lastWeek.timestamp / epochUnit * epochUnit;\n\n        // console.log('pointTimestampIterator %s', pointTimestampIterator );\n\n        while (pointTimestampIterator != timestamp) {\n            pointTimestampIterator = Math.min(pointTimestampIterator + epochUnit, timestamp);\n            // console.log('pointTimestampIterator Math.min(timestamp) %s', pointTimestampIterator );\n            int256 deltaSlope = slopeChanges[pointTimestampIterator];\n            int256 deltaTime = int256(Math.min(pointTimestampIterator - lastWeek.timestamp, epochUnit));\n            lastWeek.bias = lastWeek.bias - (lastWeek.slope * deltaTime);\n            lastWeek.slope = lastWeek.slope + deltaSlope;\n            lastWeek.bias = lastWeek.bias > 0 ? lastWeek.bias : int256(0);\n            lastWeek.slope = lastWeek.slope > 0 ? lastWeek.slope : int256(0);\n            lastWeek.timestamp = pointTimestampIterator;\n\n            // console.log('pointHistory.push lastWeek.timestamp %s', lastWeek.timestamp );\n            pointHistory.push(lastWeek);\n        }\n        // console.log('pointHistory.length %s', pointHistory.length );\n        // console.log('lastWeek %s', lastWeek.timestamp );\n\n        return lastWeek;\n    }\n\n    /// @dev Fills the record gaps\n    function _fillRecordGaps(LibLockTOSv2.Point memory week, uint256 timestamp)\n        internal\n        view\n        returns (LibLockTOSv2.Point memory)\n    {\n        // console.log('_fillRecordGaps timestamp %s', timestamp );\n\n        // Iterate through all past unrecoreded weeks\n        uint256 pointTimestampIterator = week.timestamp / epochUnit * epochUnit;\n\n        // console.log('_fillRecordGaps pointTimestampIterator %s', pointTimestampIterator );\n\n        // console.log('week.slope' );\n        // console.logInt(week.slope );\n        // console.log('week.bias' );\n        // console.logInt(week.bias );\n        // console.log('week.timestamp %s', week.timestamp );\n\n        while (pointTimestampIterator != timestamp) {\n            pointTimestampIterator = Math.min(pointTimestampIterator + epochUnit, timestamp);\n\n            // console.log('_fillRecordGaps min pointTimestampIterator %s', pointTimestampIterator );\n\n            int256 deltaSlope = slopeChanges[pointTimestampIterator];\n            int256 deltaTime = int256(Math.min(pointTimestampIterator - week.timestamp, epochUnit));\n\n            // console.log('deltaSlope' );\n            // console.logInt(deltaSlope );\n            // console.log('deltaTime' );\n            // console.logInt(deltaTime );\n\n            week.bias = week.bias - (week.slope * deltaTime);\n            // console.log('week.bias' );\n            // console.logInt(week.bias );\n\n            week.slope = week.slope + deltaSlope;\n            // console.log('week.slope' );\n            // console.logInt(week.slope );\n\n            week.bias = week.bias > 0 ? week.bias : int256(0);\n            week.slope = week.slope > 0 ? week.slope : int256(0);\n            week.timestamp = pointTimestampIterator;\n\n            // console.log('week.timestamp %s', week.timestamp );\n        }\n        return week;\n    }\n\n    /// @dev Update slope changes\n    function _updateSlopeChanges(\n        LibLockTOSv2.SlopeChange memory changeNew,\n        LibLockTOSv2.SlopeChange memory changeOld\n    ) internal {\n        // console.log('_updateSlopeChanges');\n        // console.log('changeNew.changeTime %s', changeNew.changeTime);\n        // console.log('changeOld.changeTime %s', changeOld.changeTime);\n\n        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];\n        // console.log('slopeChanges[changeNew.changeTime] ');\n        // console.logInt(deltaSlopeNew);\n        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];\n        // console.log('slopeChanges[changeOld.changeTime] ');\n        // console.logInt(deltaSlopeOld);\n\n        if (changeOld.changeTime > block.timestamp) {\n            deltaSlopeOld = deltaSlopeOld + (changeOld.slope);\n            if (changeOld.changeTime == changeNew.changeTime) {\n                deltaSlopeOld = deltaSlopeOld - (changeNew.slope);\n            }\n            slopeChanges[changeOld.changeTime] = deltaSlopeOld;\n        }\n        // console.log('--slopeChanges[changeOld.changeTime]');\n        // console.logInt(slopeChanges[changeOld.changeTime]);\n        if (\n            changeNew.changeTime > block.timestamp &&\n            changeNew.changeTime > changeOld.changeTime\n        ) {\n            deltaSlopeNew = deltaSlopeNew - (changeNew.slope);\n            slopeChanges[changeNew.changeTime] = deltaSlopeNew;\n        }\n        // console.log('--slopeChanges[changeNew.changeTime]');\n        // console.logInt(slopeChanges[changeNew.changeTime]);\n    }\n\n\n    function _findClosestUnlimitedPoint(\n        LibLockTOSv2.UnlimitedAmount[] storage _history,\n        uint256 _timestamp\n    ) internal view returns(bool success, LibLockTOSv2.UnlimitedAmount memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    function _findClosestUnlimitedTimeindex(\n        uint256 _timestamp\n    ) public view returns(bool success, uint256 timeindex) {\n        uint256 totalLen = indexOfTimesetForUnlimited.length;\n        uint256 timeIndexKey =  (_timestamp + epochUnit) * epochUnit / epochUnit ;\n\n        if (totalLen == 0) {\n            return (false, 0);\n        }\n        uint256 left = 0;\n        uint256 right = totalLen;\n\n        while (left + 1 < right) {\n            uint256 mid = (left + right) / 2;\n            if (indexOfTimesetForUnlimited[mid] <= timeIndexKey) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (indexOfTimesetForUnlimited[left] <= timeIndexKey) {\n            return (true, indexOfTimesetForUnlimited[left]);\n        }\n        return (false, 0);\n    }\n\n}\n"
    },
    "contracts/stos/LockTOSv2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/LibLockTOSv2.sol\";\n\ncontract LockTOSv2Storage {\n    uint256 public constant MULTIPLIER = 1e18;\n\n    /// @dev flag for pause proxy\n    bool public pauseProxy;\n\n\n    uint256 public epochUnit;\n    uint256 public maxTime;\n\n    address public tos;\n    uint256 public lockIdCounter;\n    uint256 public cumulativeEpochUnit;\n    uint256 public cumulativeTOSAmount;\n    string public name;\n    string public symbol;\n    mapping (uint256 => string) public tokenURIs;\n    string public baseURI;\n\n    LibLockTOSv2.Point[] public pointHistory;\n    mapping(uint256 => LibLockTOSv2.Point[]) public lockPointHistory;\n    // mapping(address => mapping(uint256 => LibLockTOSv2.LockedBalance))\n    //     public lockedBalances;\n    // mapping(address => mapping(uint256 => bool)) public lockedBalances;\n    mapping(address => mapping(uint256 => bool)) public userLocksCheck;\n\n    mapping(uint256 => LibLockTOSv2.LockedBalance) public allLocks;\n    mapping(address => uint256[]) public userLocks;\n    mapping(uint256 => int256) public slopeChanges;\n    mapping(uint256 => bool) public inUse;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) public _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) public _operatorApprovals;\n\n    // 무제한 락업 account - UnlimitedAmount\n    mapping(address => LibLockTOSv2.UnlimitedAmount[]) public unlimitedAmountByAccount;\n\n    // 무제한 락업 시간대의 타임 (매주목요일0시) - UnlimitedAmount\n    mapping(uint256 => LibLockTOSv2.UnlimitedAmount[]) public unlimitedHistoryByWeek;\n\n    // 무제한 락업에 대한 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimesetForUnlimited;\n    mapping(uint256 => bool) public indexCheckOfTimesetForUnlimited;\n\n     uint256 internal free = 1;\n    // address[] public uniqueUsers;\n    // mapping(address => bool) public boolUniqueUsers;\n\n\n    modifier nonZero(uint256 amount) {\n        require(amount != 0, \"zero amount\");\n        _;\n    }\n}\n"
    },
    "contracts/stos/UniversalStos.sol": {
      "content": ""
    },
    "contracts/stos/UniversalStosStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { LibUniversalStos } from \"../libraries/LibUniversalStos.sol\";\n\n\ncontract UniversalStosStorage {\n\n    // 현재 노드의 체인아이디\n    uint256 public curChainId;\n\n    // chaindId list\n    uint256[] public chainIds;\n\n    // chainId - layerInfo  체인아이디 - 레이어정보(메신저주소, 이름)\n    mapping(uint256 => LibUniversalStos.LayerInfo) public layerInfos;\n\n    // chainId - user - syncBlockNumber   사용자의 최근 동기화때의 블록번호\n    mapping(uint256 => mapping(address => uint256))  public userSyncBlockNumber;\n\n\n}"
    },
    "contracts/test/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"./ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n */\ncontract CrossDomainEnabled {\n    /*************\n     * Variables *\n     *************/\n\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        messenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is\n     *  authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\n        require(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        require(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        );\n\n        _;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(messenger);\n    }\n\n    /**q\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes memory _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "contracts/test/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "contracts/test/L2StandardTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* Contract Imports */\nimport { L2StandardERC20 } from \"../standards/L2StandardERC20.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/**\n * @title L2StandardTokenFactory\n * @dev Factory contract for creating standard L2 token representations of L1 ERC20s\n * compatible with and working on the standard bridge.\n */\ncontract L2StandardTokenFactory {\n    event StandardL2TokenCreated(address indexed _l1Token, address indexed _l2Token);\n\n    /**\n     * @dev Creates an instance of the standard ERC20 token on L2.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    function createStandardL2Token(\n        address _l1Token,\n        string memory _name,\n        string memory _symbol\n    ) external {\n        require(_l1Token != address(0), \"Must provide L1 token address\");\n\n        L2StandardERC20 l2Token = new L2StandardERC20(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            _l1Token,\n            _name,\n            _symbol\n        );\n\n        emit StandardL2TokenCreated(_l1Token, address(l2Token));\n    }\n}\n"
    },
    "contracts/test/Lib_AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/* External Imports */\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Lib_AddressManager\n */\ncontract Lib_AddressManager is Ownable {\n    /**********\n     * Events *\n     **********/\n\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping(bytes32 => address) private addresses;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Changes the address associated with a particular name.\n     * @param _name String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }\n\n    /**\n     * Retrieves the address associated with a given name.\n     * @param _name Name to retrieve an address for.\n     * @return Address associated with the given name.\n     */\n    function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Computes the hash of a name.\n     * @param _name Name to compute a hash for.\n     * @return Hash of the given name.\n     */\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "contracts/test/LockTOS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../common/AccessibleCommon.sol\";\nimport \"./LockTOSStorage.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nimport \"../libraries/LibLockTOS.sol\";\nimport \"../interfaces/ILockTOS.sol\";\nimport \"../interfaces/ITOS.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LockTOS is LockTOSStorage, AccessibleCommon, ILockTOS {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n\n    event LockCreated(\n        address account,\n        uint256 lockId,\n        uint256 value,\n        uint256 unlockTime\n    );\n    event LockAmountIncreased(address account, uint256 lockId, uint256 value);\n    event LockUnlockTimeIncreased(\n        address account,\n        uint256 lockId,\n        uint256 unlockTime\n    );\n    event LockDeposited(address account, uint256 lockId, uint256 value);\n    event LockWithdrawn(address account, uint256 lockId, uint256 value);\n\n    /// @dev Check if a function is used or not\n    modifier ifFree {\n        require(free == 1, \"LockId is already in use\");\n        free = 0;\n        _;\n        free = 1;\n    }\n\n    constructor() {\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        lockIdCounter = 0;\n        cumulativeEpochUnit = 0;\n        cumulativeTOSAmount = 0;\n    }\n\n    function initialize(\n        address _tos,\n        uint256 _epochUnit,\n        uint256 _maxTime\n    ) external onlyOwner {\n        require(tos == address(0), \"Already initialized\");\n        tos = _tos;\n        epochUnit = _epochUnit;\n        maxTime = _maxTime;\n    }\n\n    /// @inheritdoc ILockTOS\n    function setMaxTime(uint256 _maxTime) external override onlyOwner {\n        maxTime = _maxTime;\n    }\n\n    /// @inheritdoc ILockTOS\n    function needCheckpoint() external override view returns (bool need) {\n        uint256 len = pointHistory.length;\n        if (len == 0) {\n            return true;\n        }\n        need = (block.timestamp - pointHistory[len - 1].timestamp) > epochUnit; // if the last record was within a week\n    }\n\n    /// @inheritdoc ILockTOS\n    function increaseAmount(uint256 _lockId, uint256 _value) external override {\n        depositFor(msg.sender, _lockId, _value);\n    }\n\n    /// @inheritdoc ILockTOS\n    function allHolders() external override view returns (address[] memory) {\n        return uniqueUsers;\n    }\n\n    /// @inheritdoc ILockTOS\n    function activeHolders() external override view returns (address[] memory) {\n        bool[] memory activeCheck = new bool[](uniqueUsers.length);\n        uint256 activeSize = 0;\n        for (uint256 i = 0; i < uniqueUsers.length; ++i) {\n            uint256[] memory activeLocks = activeLocksOf(uniqueUsers[i]);\n            if (activeLocks.length > 0) {\n                activeSize++;\n                activeCheck[i] = true;\n            }\n        }\n\n        address[] memory activeUsers = new address[](activeSize);\n        uint256 j = 0;\n        for (uint256 i = 0; i < uniqueUsers.length; ++i) {\n            if (activeCheck[i]) {\n                activeUsers[j++] = uniqueUsers[i];\n            }\n        }\n        return activeUsers;\n    }\n\n    /// @inheritdoc ILockTOS\n    function createLockWithPermit(\n        uint256 _value,\n        uint256 _unlockWeeks,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override returns (uint256 lockId) {\n        ITOS(tos).permit(\n            msg.sender,\n            address(this),\n            _value,\n            _deadline,\n            _v,\n            _r,\n            _s\n        );\n        lockId = createLock(_value, _unlockWeeks);\n    }\n\n    /// @inheritdoc ILockTOS\n    function increaseUnlockTime(uint256 _lockId, uint256 _unlockWeeks)\n        external\n        override\n    {\n        require(_unlockWeeks > 0, \"Unlock period less than a week\");\n        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);\n\n        LibLockTOS.LockedBalance memory lock =\n            lockedBalances[msg.sender][_lockId];\n        uint256 unlockTime = lock.end.add(_unlockWeeks.mul(epochUnit));\n        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);\n        require(\n            unlockTime - block.timestamp < maxTime,\n            \"Max unlock time is 3 years\"\n        );\n        require(lock.end > block.timestamp, \"Lock time already finished\");\n        require(lock.end < unlockTime, \"New lock time must be greater\");\n        require(lock.amount > 0, \"No existing locked TOS\");\n        _deposit(msg.sender, _lockId, 0, unlockTime);\n\n        emit LockUnlockTimeIncreased(msg.sender, _lockId, unlockTime);\n    }\n\n    /// @inheritdoc ILockTOS\n    function withdrawAll() external override ifFree {\n        uint256[] storage locks = userLocks[msg.sender];\n        if (locks.length == 0) {\n            return;\n        }\n\n        for (uint256 i = 0; i < locks.length; i++) {\n            LibLockTOS.LockedBalance memory lock = allLocks[locks[i]];\n            if (\n                lock.withdrawn == false &&\n                locks[i] > 0 &&\n                lock.amount > 0 &&\n                lock.start > 0 &&\n                lock.end > 0 &&\n                lock.end < block.timestamp\n            ) {\n                _withdraw(locks[i]);\n            }\n        }\n    }\n\n    /// @inheritdoc ILockTOS\n    function globalCheckpoint() external override {\n        _recordHistoryPoints();\n    }\n\n    /// @inheritdoc ILockTOS\n    function withdraw(uint256 _lockId) public override ifFree {\n        require(_lockId > 0, \"_lockId is zero\");\n        _withdraw(_lockId);\n    }\n\n    /// @dev Send staked amount back to user\n    function _withdraw(uint256 _lockId) internal {\n        LibLockTOS.LockedBalance memory lockedOld =\n            lockedBalances[msg.sender][_lockId];\n        require(lockedOld.withdrawn == false, \"Already withdrawn\");\n        require(lockedOld.start > 0, \"Lock does not exist\");\n        require(lockedOld.end < block.timestamp, \"Lock time not finished\");\n        require(lockedOld.amount > 0, \"No amount to withdraw\");\n\n        LibLockTOS.LockedBalance memory lockedNew =\n            LibLockTOS.LockedBalance({\n                amount: 0,\n                start: 0,\n                end: 0,\n                withdrawn: true\n            });\n\n        // Checkpoint\n        _checkpoint(lockedNew, lockedOld);\n\n        // Transfer TOS back\n        uint256 amount = lockedOld.amount;\n        lockedBalances[msg.sender][_lockId] = lockedNew;\n        allLocks[_lockId] = lockedNew;\n\n        IERC20(tos).transfer(msg.sender, amount);\n        emit LockWithdrawn(msg.sender, _lockId, amount);\n    }\n\n    /// @inheritdoc ILockTOS\n    function createLock(uint256 _value, uint256 _unlockWeeks)\n        public\n        override\n        returns (uint256 lockId)\n    {\n        require(_value > 0, \"Value locked should be non-zero\");\n        require(_unlockWeeks > 0, \"Unlock period less than a week\");\n\n        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);\n        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);\n        uint256 unlockTime = block.timestamp.add(_unlockWeeks.mul(epochUnit));\n        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);\n        require(\n            unlockTime - block.timestamp <= maxTime,\n            \"Max unlock time is 3 years\"\n        );\n\n        if (userLocks[msg.sender].length == 0) { // check if user for the first time\n            uniqueUsers.push(msg.sender);\n        }\n\n        lockIdCounter = lockIdCounter.add(1);\n        lockId = lockIdCounter;\n        // console.log(\"lockId %s\", lockId);\n\n        _deposit(msg.sender, lockId, _value, unlockTime);\n        userLocks[msg.sender].push(lockId);\n\n        emit LockCreated(msg.sender, lockId, _value, unlockTime);\n    }\n\n    /// @inheritdoc ILockTOS\n    function depositFor(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value\n    ) public override {\n        require(_value > 0, \"Value locked should be non-zero\");\n        LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][_lockId];\n        require(lock.withdrawn == false, \"Lock is withdrawn\");\n        require(lock.start > 0, \"Lock does not exist\");\n        require(lock.end > block.timestamp, \"Lock time is finished\");\n\n        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);\n        _deposit(_addr, _lockId, _value, 0);\n        emit LockDeposited(msg.sender, _lockId, _value);\n    }\n\n    /// @inheritdoc ILockTOS\n    function totalSupplyAt(uint256 _timestamp)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (pointHistory.length == 0) {\n            return 0;\n        }\n        // console.log('-------------------totalSupplyAt _timestamp %s', _timestamp);\n        (bool success, LibLockTOS.Point memory point) =\n            _findClosestPoint(pointHistory, _timestamp);\n        if (!success) {\n            return 0;\n        }\n\n        point = _fillRecordGaps(point, _timestamp);\n        int256 currentBias =\n            point.slope * (_timestamp.sub(point.timestamp).toInt256());\n        return\n            uint256(point.bias > currentBias ? point.bias - currentBias : int256(0))\n                .div(MULTIPLIER);\n    }\n\n    /// @inheritdoc ILockTOS\n    function totalLockedAmountOf(address _addr) external view override returns (uint256) {\n        uint256 len = userLocks[_addr].length;\n        uint256 stakedAmount = 0;\n        for (uint256 i = 0; i < len; ++i) {\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];\n            stakedAmount = stakedAmount.add(lock.amount);\n        }\n        return stakedAmount;\n    }\n\n    /// @inheritdoc ILockTOS\n    function withdrawableAmountOf(address _addr) external view override returns (uint256) {\n        uint256 len = userLocks[_addr].length;\n        uint256 amount = 0;\n        for(uint i = 0; i < len; i++){\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];\n            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {\n                amount = amount.add(lock.amount);\n            }\n        }\n        return amount;\n    }\n\n    /// @inheritdoc ILockTOS\n    function totalSupply() external view override returns (uint256) {\n        if (pointHistory.length == 0) {\n            return 0;\n        }\n\n        // console.log('-------------------totalSupply timestamp %s', block.timestamp);\n        LibLockTOS.Point memory point = _fillRecordGaps(\n            pointHistory[pointHistory.length - 1],\n            block.timestamp\n        );\n        // console.log('totalSupply _fillRecordGaps point.timestamp %s' ,  point.timestamp);\n\n        int256 currentBias =\n            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());\n        return\n            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : int256(0))\n                .div(MULTIPLIER);\n    }\n\n    /// @inheritdoc ILockTOS\n    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        (bool success, LibLockTOS.Point memory point) =\n            _findClosestPoint(lockPointHistory[_lockId], _timestamp);\n        if (!success) {\n            return 0;\n        }\n        int256 currentBias =\n            point.slope.mul(_timestamp.sub(point.timestamp).toInt256());\n        return\n            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : int256(0))\n                .div(MULTIPLIER);\n    }\n\n    /// @inheritdoc ILockTOS\n    function balanceOfLock(uint256 _lockId)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 len = lockPointHistory[_lockId].length;\n        if (len == 0) {\n            return 0;\n        }\n\n        LibLockTOS.Point memory point = lockPointHistory[_lockId][len - 1];\n        // console.log('balanceOfLock %s',  _lockId);\n        // console.log('balanceOfLock point.slope');\n        // console.logInt(point.slope);\n        // console.log('balanceOfLock point.bias');\n        // console.logInt(point.bias);\n        // console.log('balanceOfLock point.timestamp');\n        // console.log(point.timestamp);\n        // console.log('block.timestamp %s', block.timestamp);\n\n\n        int256 currentBias =\n            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());\n\n        // console.log('balanceOfLock currentBias');\n        // console.logInt(currentBias);\n        uint256 bal = uint256(point.bias > currentBias ? point.bias.sub(currentBias) : int256(0));\n        // console.log('balanceOfLock currentBias %s', bal);\n        return\n            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : int256(0))\n                .div(MULTIPLIER);\n    }\n\n    /// @inheritdoc ILockTOS\n    function balanceOfAt(address _addr, uint256 _timestamp)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = userLocks[_addr];\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance = balance.add(balanceOfLockAt(locks[i], _timestamp));\n        }\n    }\n\n    /// @inheritdoc ILockTOS\n    function balanceOf(address _addr)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        uint256[] memory locks = userLocks[_addr];\n        if (locks.length == 0) return 0;\n        for (uint256 i = 0; i < locks.length; ++i) {\n            balance = balance.add(balanceOfLock(locks[i]));\n        }\n    }\n\n    /// @inheritdoc ILockTOS\n    function locksInfo(uint256 _lockId)\n        public\n        view\n        override\n        returns (\n            uint256 start,\n            uint256 end,\n            uint256 amount\n        )\n    {\n        return (\n            allLocks[_lockId].start,\n            allLocks[_lockId].end,\n            allLocks[_lockId].amount\n        );\n    }\n\n    /// @inheritdoc ILockTOS\n    function locksOf(address _addr)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return userLocks[_addr];\n    }\n\n    /// @inheritdoc ILockTOS\n    function withdrawableLocksOf(address _addr)  external view override returns (uint256[] memory) {\n        uint256 len = userLocks[_addr].length;\n        uint256 size = 0;\n        for(uint i = 0; i < len; i++){\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];\n            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {\n                size++;\n            }\n        }\n\n        uint256[] memory withdrawable = new uint256[](size);\n        size = 0;\n        for(uint i = 0; i < len; i++) {\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];\n            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {\n                withdrawable[size++] = lockId;\n            }\n        }\n        return withdrawable;\n    }\n\n    /// @inheritdoc ILockTOS\n    function activeLocksOf(address _addr)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 len = userLocks[_addr].length;\n        uint256 _size = 0;\n        for(uint i = 0; i < len; i++){\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];\n            if(lock.end > block.timestamp) {\n                _size++;\n            }\n        }\n\n        uint256[] memory activeLocks = new uint256[](_size);\n        _size = 0;\n        for(uint i = 0; i < len; i++) {\n            uint256 lockId = userLocks[_addr][i];\n            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];\n            if(lock.end > block.timestamp) {\n                activeLocks[_size++] = lockId;\n            }\n        }\n        return activeLocks;\n    }\n\n    /// @inheritdoc ILockTOS\n    function pointHistoryOf(uint256 _lockId)\n        public\n        view\n        override\n        returns (LibLockTOS.Point[] memory)\n    {\n        return lockPointHistory[_lockId];\n    }\n\n    /// @dev Finds closest point\n    function _findClosestPoint(\n        LibLockTOS.Point[] storage _history,\n        uint256 _timestamp\n    ) internal view returns (bool success, LibLockTOS.Point memory point) {\n        if (_history.length == 0) {\n            return (false, point);\n        }\n\n        uint256 left = 0;\n        uint256 right = _history.length;\n        while (left + 1 < right) {\n            uint256 mid = left.add(right).div(2);\n            if (_history[mid].timestamp <= _timestamp) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n\n        if (_history[left].timestamp <= _timestamp) {\n            return (true, _history[left]);\n        }\n        return (false, point);\n    }\n\n    /// @dev Deposit\n    function _deposit(\n        address _addr,\n        uint256 _lockId,\n        uint256 _value,\n        uint256 _unlockTime\n    ) internal ifFree {\n        LibLockTOS.LockedBalance memory lockedOld =\n            lockedBalances[_addr][_lockId];\n        LibLockTOS.LockedBalance memory lockedNew =\n            LibLockTOS.LockedBalance({\n                amount: lockedOld.amount,\n                start: lockedOld.start,\n                end: lockedOld.end,\n                withdrawn: false\n            });\n\n        // Make new lock\n        lockedNew.amount = lockedNew.amount.add(_value);\n        if (_unlockTime > 0) {\n            lockedNew.end = _unlockTime;\n        }\n        if (lockedNew.start == 0) {\n            lockedNew.start = block.timestamp;\n        }\n\n        // Checkpoint\n        _checkpoint(lockedNew, lockedOld);\n\n        // Save new lock\n        lockedBalances[_addr][_lockId] = lockedNew;\n        allLocks[_lockId] = lockedNew;\n\n        // Save user point,\n        int256 userSlope =\n            lockedNew.amount.mul(MULTIPLIER).div(maxTime).toInt256();\n        int256 userBias =\n            userSlope.mul(lockedNew.end.sub(block.timestamp).toInt256());\n        LibLockTOS.Point memory userPoint =\n            LibLockTOS.Point({\n                timestamp: block.timestamp,\n                slope: userSlope,\n                bias: userBias\n            });\n        lockPointHistory[_lockId].push(userPoint);\n\n        // Transfer TOS\n        require(\n            IERC20(tos).transferFrom(msg.sender, address(this), _value),\n            \"LockTOS: fail transferFrom\"\n        );\n    }\n\n    /// @dev Checkpoint\n    function _checkpoint(\n        LibLockTOS.LockedBalance memory lockedNew,\n        LibLockTOS.LockedBalance memory lockedOld\n    ) internal {\n        uint256 timestamp = block.timestamp;\n        LibLockTOS.SlopeChange memory changeNew =\n            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});\n        LibLockTOS.SlopeChange memory changeOld =\n            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});\n\n        // Initialize slope changes\n        if (lockedNew.end > timestamp && lockedNew.amount > 0) {\n            changeNew.slope = lockedNew\n                .amount\n                .mul(MULTIPLIER)\n                .div(maxTime)\n                .toInt256();\n            changeNew.bias = changeNew.slope\n                .mul(lockedNew.end.sub(timestamp).toInt256());\n            changeNew.changeTime = lockedNew.end;\n        }\n        if (lockedOld.end > timestamp && lockedOld.amount > 0) {\n            changeOld.slope = lockedOld\n                .amount\n                .mul(MULTIPLIER)\n                .div(maxTime)\n                .toInt256();\n            changeOld.bias = changeOld.slope\n                .mul(lockedOld.end.sub(timestamp).toInt256());\n            changeOld.changeTime = lockedOld.end;\n        }\n\n        // Record history gaps\n        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();\n        currentWeekPoint.bias = currentWeekPoint.bias.add(\n            changeNew.bias.sub(changeOld.bias)\n        );\n        currentWeekPoint.slope = currentWeekPoint.slope.add(\n            changeNew.slope.sub(changeOld.slope)\n        );\n        currentWeekPoint.bias = currentWeekPoint.bias > int256(0)\n            ? currentWeekPoint.bias\n            : int256(0);\n        currentWeekPoint.slope = currentWeekPoint.slope > int256(0)\n            ? currentWeekPoint.slope\n            : int256(0);\n        pointHistory[pointHistory.length - 1] = currentWeekPoint;\n        // console.log(\"pointHistory  index %s\", pointHistory.length - 1);\n        // console.log(\"bias\");\n        // console.logInt(currentWeekPoint.bias);\n        // console.log(\"slope\");\n        // console.logInt(currentWeekPoint.slope);\n        // console.log(\"pointHistory.timestamp %s\", currentWeekPoint.timestamp);\n\n        // Update slope changes\n        _updateSlopeChanges(changeNew, changeOld);\n    }\n\n    /// @dev Fill the gaps\n    function _recordHistoryPoints()\n        internal\n        returns (LibLockTOS.Point memory lastWeek)\n    {\n        uint256 timestamp = block.timestamp;\n        // console.log('_recordHistoryPoints timestamp %s', timestamp );\n        if (pointHistory.length > 0) {\n            lastWeek = pointHistory[pointHistory.length - 1];\n        } else {\n            lastWeek = LibLockTOS.Point({\n                bias: 0,\n                slope: 0,\n                timestamp: timestamp\n            });\n        }\n        // console.log('_recordHistoryPoints pointHistory.length %s', pointHistory.length );\n\n        // Iterate through all past unrecoreded weeks and record\n        uint256 pointTimestampIterator =\n            lastWeek.timestamp.div(epochUnit).mul(epochUnit);\n\n        // console.log('pointTimestampIterator %s', pointTimestampIterator );\n\n        while (pointTimestampIterator != timestamp) {\n            pointTimestampIterator = Math.min(\n                pointTimestampIterator.add(epochUnit),\n                timestamp\n            );\n            // console.log('pointTimestampIterator Math.min(timestamp) %s', pointTimestampIterator );\n            int256 deltaSlope = slopeChanges[pointTimestampIterator];\n            int256 deltaTime =\n                Math.min(pointTimestampIterator.sub(lastWeek.timestamp), epochUnit).toInt256();\n            lastWeek.bias = lastWeek.bias.sub(lastWeek.slope.mul(deltaTime));\n            lastWeek.slope = lastWeek.slope.add(deltaSlope);\n            lastWeek.bias = lastWeek.bias > 0 ? lastWeek.bias : int256(0);\n            lastWeek.slope = lastWeek.slope > 0 ? lastWeek.slope : int256(0);\n            lastWeek.timestamp = pointTimestampIterator;\n\n            // console.log('pointHistory.push lastWeek.timestamp %s', lastWeek.timestamp );\n            pointHistory.push(lastWeek);\n        }\n        // console.log('pointHistory.length %s', pointHistory.length );\n        // console.log('lastWeek %s', lastWeek.timestamp );\n\n        return lastWeek;\n    }\n\n    /// @dev Fills the record gaps\n    function _fillRecordGaps(LibLockTOS.Point memory week, uint256 timestamp)\n        internal\n        view\n        returns (LibLockTOS.Point memory)\n    {\n        // console.log('_fillRecordGaps timestamp %s', timestamp );\n\n        // Iterate through all past unrecoreded weeks\n        uint256 pointTimestampIterator =\n            week.timestamp.div(epochUnit).mul(epochUnit);\n\n        // console.log('_fillRecordGaps pointTimestampIterator %s', pointTimestampIterator );\n\n        // console.log('week.slope' );\n        // console.logInt(week.slope );\n        // console.log('week.bias' );\n        // console.logInt(week.bias );\n        // console.log('week.timestamp %s', week.timestamp );\n\n        while (pointTimestampIterator != timestamp) {\n            pointTimestampIterator = Math.min(\n                pointTimestampIterator.add(epochUnit),\n                timestamp\n            );\n\n            // console.log('_fillRecordGaps min pointTimestampIterator %s', pointTimestampIterator );\n\n            int256 deltaSlope = slopeChanges[pointTimestampIterator];\n            int256 deltaTime =\n                Math.min(pointTimestampIterator.sub(week.timestamp), epochUnit).toInt256();\n\n            // console.log('deltaSlope' );\n            // console.logInt(deltaSlope );\n            // console.log('deltaTime' );\n            // console.logInt(deltaTime );\n\n            week.bias = week.bias.sub(week.slope.mul(deltaTime));\n            // console.log('week.bias' );\n            // console.logInt(week.bias );\n\n            week.slope = week.slope.add(deltaSlope);\n            // console.log('week.slope' );\n            // console.logInt(week.slope );\n\n            week.bias = week.bias > 0 ? week.bias : int256(0);\n            week.slope = week.slope > 0 ? week.slope : int256(0);\n            week.timestamp = pointTimestampIterator;\n\n            // console.log('week.timestamp %s', week.timestamp );\n        }\n        return week;\n    }\n\n    /// @dev Update slope changes\n    function _updateSlopeChanges(\n        LibLockTOS.SlopeChange memory changeNew,\n        LibLockTOS.SlopeChange memory changeOld\n    ) internal {\n        // console.log('_updateSlopeChanges');\n        // console.log('changeNew.changeTime %s', changeNew.changeTime);\n        // console.log('changeOld.changeTime %s', changeOld.changeTime);\n\n        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];\n        // console.log('slopeChanges[changeNew.changeTime] ');\n        // console.logInt(deltaSlopeNew);\n        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];\n        // console.log('slopeChanges[changeOld.changeTime] ');\n        // console.logInt(deltaSlopeOld);\n\n        if (changeOld.changeTime > block.timestamp) {\n            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);\n            if (changeOld.changeTime == changeNew.changeTime) {\n                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);\n            }\n            slopeChanges[changeOld.changeTime] = deltaSlopeOld;\n        }\n        // console.log('--slopeChanges[changeOld.changeTime]');\n        // console.logInt(slopeChanges[changeOld.changeTime]);\n        if (\n            changeNew.changeTime > block.timestamp &&\n            changeNew.changeTime > changeOld.changeTime\n        ) {\n            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);\n            slopeChanges[changeNew.changeTime] = deltaSlopeNew;\n        }\n        // console.log('--slopeChanges[changeNew.changeTime]');\n        // console.logInt(slopeChanges[changeNew.changeTime]);\n    }\n\n    function getCurrentTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function currentStakedTotalTOS() external view returns (uint256) {\n        return IERC20(tos).balanceOf(address(this));\n    }\n\n}\n"
    },
    "contracts/test/LockTOSStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../libraries/LibLockTOS.sol\";\n\ncontract LockTOSStorage {\n    /// @dev flag for pause proxy\n    bool public pauseProxy;\n\n    /// @dev registry\n    address public stakeRegistry;\n    bool public migratedL2;\n\n    uint256 public epochUnit;\n    uint256 public maxTime;\n\n    uint256 public constant MULTIPLIER = 1e18;\n\n    address public tos;\n    uint256 public lockIdCounter;\n    uint256 public cumulativeEpochUnit;\n    uint256 public cumulativeTOSAmount;\n\n    uint256 internal free = 1;\n\n    address[] public uniqueUsers;\n    LibLockTOS.Point[] public pointHistory;\n    mapping(uint256 => LibLockTOS.Point[]) public lockPointHistory;\n    mapping(address => mapping(uint256 => LibLockTOS.LockedBalance))\n        public lockedBalances;\n\n    mapping(uint256 => LibLockTOS.LockedBalance) public allLocks;\n    mapping(address => uint256[]) public userLocks;\n    mapping(uint256 => int256) public slopeChanges;\n    mapping(uint256 => bool) public inUse;\n}\n"
    },
    "contracts/test/MockL1Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface FwReceiptI {\n    function finalizeFastWithdraw(bytes memory _l2Messages)\n        external returns (uint8);\n}\n\n\ninterface L1MessengerI {\n    function setSuccessfulMessages(bytes32 _hashMessages, bool _bool) external;\n    function successfulMessages(bytes32 _hashMessages) external view returns (bool);\n}\n\ninterface MockL1BridgeI {\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n}\n\ninterface IL1CrossDomainMessenger {\n    function relayMessage(\n            address _target,\n            address _sender,\n            bytes memory _message,\n            uint256 _messageNonce\n        )  external;\n}\n\n\ncontract MockL1Bridge is Ownable {\n    using SafeERC20 for IERC20;\n\n    /********************************\n     * External Contract References *\n     ********************************/\n    address public l1Messenger;\n    address public l2TokenBridge;\n\n    // Maps L1 token to L2 token to balance of the L1 token deposited\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     *  contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\n        require(!Address.isContract(msg.sender), \"Account not EOA\");\n        _;\n    }\n\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\n        require(\n            msg.sender == l1Messenger,\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        // require(\n        //     getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n        //     \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        // );\n\n        _;\n    }\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    constructor() {\n    }\n\n    function setAddress(address _l1Messenger, address _l2TokenBridge) external onlyOwner {\n         l1Messenger = _l1Messenger;\n        l2TokenBridge = _l2TokenBridge;\n    }\n\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);\n    }\n\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual {\n\n        _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);\n    }\n\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {\n\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n\n        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;\n\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _nonce\n    // ) external onlyFromCrossDomainAccount(l2TokenBridge) {\n    ) external {\n\n        bytes memory _message = abi.encodeWithSelector(MockL1BridgeI.finalizeERC20Withdrawal.selector,\n            _l1Token, _l2Token, _from, _to, _amount, _data);\n\n        bytes memory _message2 = abi.encodeWithSelector(IL1CrossDomainMessenger.relayMessage.selector,\n            address(this), l2TokenBridge, _message, _nonce);\n\n        bytes32 _key = keccak256(_message2);\n\n        require(!L1MessengerI(l1Messenger).successfulMessages(_key), \"already done\");\n\n        uint256 bal = IERC20(_l1Token).balanceOf(address(this));\n\n        require(bal >= _amount, \"balance is insufficient\");\n\n        // deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\n        // for test\n        if(deposits[_l1Token][_l2Token] > _amount)\n            deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\n\n        L1MessengerI(l1Messenger).setSuccessfulMessages(_key, true);\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer\n        // slither-disable-next-line reentrancy-events\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        // 질문. core evm 에서는 data 실행하는 코드가 왜 없는지..\n        // if(_data.length != 0){\n        //     (bool success, bytes memory result) = _to.call{value:0}(_message2);\n        // }\n\n        // console.logBool(success);\n        // console.logBytes(result);\n\n        // (uint8 status) = abi.decode(result,(uint8));\n        // console.log(status);\n\n        // // slither-disable-next-line reentrancy-events\n        // emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n}\n"
    },
    "contracts/test/MockL1LockTos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract MockL1LockTos {\n    constructor() {\n    }\n}"
    },
    "contracts/test/MockL1Messenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"hardhat/console.sol\";\ninterface L2CrossDomainMessengerI {\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) external;\n}\n\ncontract MockL1Messenger  {\n\n    mapping(bytes32 => bool) public successfulMessages;\n\n    uint256 public messageNonce;\n    address public l2messenger;\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    constructor() {\n    }\n\n\n    function setL2messenger(address _l2messagenger) external {\n        require(l2messenger == address(0), 'already set');\n        l2messenger = _l2messagenger;\n    }\n\n    function setSuccessfulMessages(bytes32 _hashMessages, bool _bool) external {\n        successfulMessages[_hashMessages] = _bool;\n    }\n\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) public {\n\n        console.log(\"MockL1Messenger sendMessage _target %s\", _target);\n\n        emit SentMessage(_target, msg.sender, _message, ++messageNonce, _gasLimit);\n\n        L2CrossDomainMessengerI(l2messenger).relayMessage(\n            _target,\n            msg.sender,\n            _message,\n            messageNonce\n        );\n\n        console.log(\"MockL1Messenger sendMessage end  \");\n    }\n\n}\n"
    },
    "contracts/test/MockL2Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract MockL2Bridge  {\n\n    constructor() {\n    }\n\n}\n"
    },
    "contracts/test/MockL2LockTos.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract MockL2LockTos {\n    constructor() {\n    }\n}"
    },
    "contracts/test/MockL2Messenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"hardhat/console.sol\";\ncontract MockL2Messenger  {\n\n    uint256 public messageNonce;\n    address internal xDomainMsgSender;\n    address public l1CrossDomainMessenger;\n\n    event RelayedMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce\n    );\n\n    event FailedRelayedMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce\n    );\n\n    constructor() {\n    }\n\n    function xDomainMessageSender() public view returns (address) {\n        require(\n            xDomainMsgSender != address(0),\n            \"xDomainMessageSender is not set\"\n        );\n        return xDomainMsgSender;\n    }\n\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) public {\n        console.log(\"MockL2Messenger relayMessage _target %s\", _target);\n\n        xDomainMsgSender = _sender;\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\n        (bool success, ) = _target.call(_message);\n        // slither-disable-next-line reentrancy-benign\n        console.logBool(success);\n\n        xDomainMsgSender = address(0);\n        if(success) {\n            emit RelayedMessage(_target, _sender, _message, _messageNonce);\n        } else {\n            emit FailedRelayedMessage(_target, _sender, _message, _messageNonce);\n        }\n        console.log(\"MockL2Messenger relayMessage end \");\n\n    }\n\n}\n"
    },
    "contracts/test/MockL2TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract MockL2TokenFactory {\n    constructor() {\n    }\n}"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20 {\n    constructor() ERC20(\"TON\", \"TON\") {}\n\n    function mint(address to, uint256 value) public {\n        _mint(to, value);\n    }\n}\n"
    },
    "contracts/test/TOS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ITOS.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../common/AccessiblePlusCommon.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title the platform token. TOS token\n\ncontract TOS is ERC20, AccessiblePlusCommon, ITOS {\n    bytes32 public override DOMAIN_SEPARATOR;\n    mapping(address => uint256) public override nonces;\n\n    /// @dev Value is equal to keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @dev constructor of TOS, ERC20 Token\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory version_\n    ) ERC20(name_, symbol_) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name_)),\n                keccak256(bytes(version_)),\n                chainId,\n                address(this)\n            )\n        );\n\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(BURNER_ROLE, msg.sender);\n        _setupRole(MINTER_ROLE, msg.sender);\n    }\n\n    /// @dev Issue a token.\n    /// @param to  who takes the issue\n    /// @param amount the amount to issue\n    function mint(address to, uint256 amount)\n        external\n        override\n        onlyMinter\n        returns (bool)\n    {\n        _mint(to, amount);\n        return true;\n    }\n\n    /// @dev burn a token.\n    /// @param from Whose tokens are burned\n    /// @param amount the amount to burn\n    function burn(address from, uint256 amount)\n        external\n        override\n        onlyBurner\n        returns (bool)\n    {\n        _burn(from, amount);\n        return true;\n    }\n\n    /// @dev Authorizes the owner's token to be used by the spender as much as the value.\n    /// @dev The signature must have the owner's signature.\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param v the owner's signature - v\n    /// @param r the owner's signature - r\n    /// @param s the owner's signature - s\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"TOS: permit EXPIRED\");\n\n        bytes32 digest =\n            hashPermit(owner, spender, value, deadline, nonces[owner]++);\n\n        require(owner != spender, \"TOS: approval to current owner\");\n\n        // if (Address.isContract(owner)) {\n        //     require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, 'Unauthorized');\n        // } else {\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0), \"TOS: Invalid signature\");\n        console.log(\"address: %s\", recoveredAddress);\n        require(recoveredAddress == owner, \"TOS: Unauthorized\");\n        // }\n        _approve(owner, spender, value);\n    }\n\n    /// @dev verify the signature\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param _nounce the _nounce\n    /// @param sigR the owner's signature - r\n    /// @param sigS the owner's signature - s\n    /// @param sigV the owner's signature - v\n    function verify(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint256 _nounce,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) external view override returns (bool) {\n        return\n            owner ==\n            ecrecover(\n                hashPermit(owner, spender, value, deadline, _nounce),\n                sigV,\n                sigR,\n                sigS\n            );\n    }\n\n    /// @dev the hash of Permit\n    /// @param owner the token's owner\n    /// @param spender the account that spend owner's token\n    /// @param value the amount to be approve to spend\n    /// @param deadline the deadline that valid the owner's signature\n    /// @param _nounce the _nounce\n    function hashPermit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint256 _nounce\n    ) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            _nounce,\n                            deadline\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 625
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}