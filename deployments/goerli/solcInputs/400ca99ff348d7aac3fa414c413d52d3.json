{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1StosToL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { LibProject } from \"../libraries/LibProject.sol\";\nimport \"../libraries/LibLockTOS.sol\";\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./L1StosToL2Storage.sol\";\n// import \"hardhat/console.sol\";\n\ninterface ILockTos {\n    function locksInfo(uint256 _lockId)\n            external\n            view\n            returns (\n                uint256 start,\n                uint256 end,\n                uint256 amount\n            );\n\n    function locksOf(address _addr)\n        external\n        view\n        returns (uint256[] memory);\n\n    function pointHistoryOf(uint256 _lockId)\n        external\n        view\n        returns (LibLockTOS.Point[] memory);\n\n}\n\ninterface IL1StosInL2 {\n    function register(bytes memory data) external ;\n}\n\ninterface L1CrossDomainMessengerI {\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) external;\n}\n\n\ncontract L1StosToL2 is ProxyStorage2, L1StosToL2Storage {\n\n    /* ========== DEPENDENCIES ========== */\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"not owner\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor () {\n\n    }\n\n    function initialize (\n        address managerAddress,\n        address lockTosAddress,\n        address addressManagerAddress,\n        uint256 maxLockCountPerRegister_,\n        uint32 minGasLimitRegister_\n    ) external onlyOwner {\n        _manager = managerAddress;\n        lockTos = lockTosAddress;\n        addressManager = addressManagerAddress;\n        maxLockCountPerRegister = maxLockCountPerRegister_;\n        minGasLimitRegister = minGasLimitRegister_;\n    }\n\n    function setL2Register(address l2Register_) external onlyManager {\n        require(l2Register != l2Register_, \"same\");\n        l2Register = l2Register_;\n    }\n\n    /* ========== Anybody can ========== */\n\n    function register(address account) public {\n        uint256[] memory lockIds = ILockTos(lockTos).locksOf(account);\n        // console.log(\"register %s\", account);\n        // console.log(\"lockIds.length %s\", lockIds.length);\n        require(lockIds.length != 0, \"no register data\");\n        require(lockIds.length <= maxLockCountPerRegister, \"exceeded the maximum number of register.\");\n        _register(account, lockIds);\n    }\n\n    function register(address account, uint256[] memory lockIds) public {\n        require(lockIds.length <= maxLockCountPerRegister, \"exceeded the maximum number of register.\");\n        require(lockIds.length != 0, \"no register data\");\n        uint256[] memory userLockIds = ILockTos(lockTos).locksOf(account);\n\n        for(uint256 i = 0; i < lockIds.length; i++){\n            bool unMatched = true;\n            for(uint256 j = 0; j < userLockIds.length; j++){\n                if(lockIds[i] == userLockIds[j]) {\n                    unMatched = false;\n                    if(j < userLockIds.length-1)\n                        userLockIds[j] = userLockIds[userLockIds.length-1];\n                    delete userLockIds[userLockIds.length-1];\n                    break;\n                }\n            }\n            require(!unMatched, \"owner is not account\");\n        }\n\n        _register(account, lockIds);\n    }\n\n    /* ========== VIEW ========== */\n\n    function needSyncList(address account) public view returns (uint256[] memory lockIds, uint256 count) {\n        uint256[] memory ids = ILockTos(lockTos).locksOf(account);\n\n        if(ids.length != 0) lockIds = new uint256[](ids.length);\n        for(uint256 i = 0; i < ids.length; i++){\n            LibLockId.SyncInfo memory curSync = syncInfoOfLockId[ids[i]];\n            (, uint256 end, uint256 amount) = ILockTos(lockTos).locksInfo(ids[i]);\n\n            if(amount != 0 && block.timestamp < end) {\n                LibLockTOS.Point[] memory history = ILockTos(lockTos).pointHistoryOf(ids[i]);\n\n                if(history.length != 0){\n                    LibLockTOS.Point memory point = history[history.length-1];\n\n                    if(uint256(curSync.timestamp) < point.timestamp) {\n                        lockIds[count] = ids[i];\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    function viewRegisterInfoOfLockId(uint256 lockId) external view returns(LibLockId.SyncInfo memory) {\n        return syncInfoOfLockId[lockId];\n    }\n\n    /* === ======= internal ========== */\n\n    function _register(address account, uint256[] memory lockIds) internal {\n\n        bytes memory syncPackets ;\n        uint256 syncIdsCount ;\n\n        // packet {address: count to sync: 1st sync packet: 2nd sync packet: .....}\n        // address : 20 bytes\n        // count to sync : 1 byte (max 256 sync packets) but it is less than maxLockCountPerSync\n        // sync packets : count to sync * 104 bytes ( count * 104 )\n        // one sync packets : 104 bytes:  (32 byte) uint256 lockId, (32+32+4+4) syncInfo -> total 104\n\n        for(uint256 i = 0; i < lockIds.length; i++){\n\n            LibLockId.SyncInfo memory curSync = syncInfoOfLockId[lockIds[i]];\n\n            (, uint256 end, uint256 amount) = ILockTos(lockTos).locksInfo(lockIds[i]);\n\n            if (amount != 0 && block.timestamp < end){\n                LibLockTOS.Point[] memory history = ILockTos(lockTos).pointHistoryOf(lockIds[i]);\n\n                if(history.length != 0){\n                    LibLockTOS.Point memory point = history[history.length-1];\n\n                    if(curSync.timestamp < point.timestamp) {\n                        LibLockId.SyncInfo memory newSync = LibLockId.SyncInfo(\n                            {\n                                slope: point.slope,\n                                bias: point.bias,\n                                timestamp: uint32(point.timestamp),\n                                syncTime: uint32(block.timestamp)\n                            }\n                        );\n\n                        syncInfoOfLockId[lockIds[i]] = newSync;\n                        syncIdsCount++;\n\n                        syncPackets = bytes.concat(syncPackets,\n                            abi.encodePacked(lockIds[i], newSync.slope, newSync.bias, newSync.timestamp, newSync.syncTime));\n\n                    }\n                }\n            }\n        }\n\n        require(syncPackets.length > 0, \"no register data\");\n        // console.log('_register syncPackets.length  %s', syncPackets.length);\n\n        _sendMessage(\n            l2Register,\n            abi.encodePacked(account, syncPackets),\n            // bytes.concat(abi.encodePacked(account), syncPackets),\n            minGasLimitRegister\n            );\n    }\n\n\n    function _sendMessage(address target, bytes memory data, uint32 minGasLimit) internal {\n        address l1Messenger = LibProject.getL1CommunicationMessenger(addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n\n        bytes memory callData = abi.encodeWithSelector(IL1StosInL2.register.selector, data);\n\n        // console.log('_sendMessage target %s', target, ' data.length %s', data.length);\n        // console.logBytes(data);\n        // console.log('_sendMessage l1Messenger %s', l1Messenger);\n\n        L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                target,\n                callData,\n                minGasLimit\n            );\n    }\n\n}"
    },
    "contracts/L1/L1StosToL2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/LibLockId.sol\";\n\ncontract L1StosToL2Storage  {\n    uint256 public maxLockCountPerRegister;\n    address public _manager;\n    address public addressManager;\n    address public lockTos;\n    address public l2Register;\n    uint32 minGasLimitRegister;\n\n    // account-lockId-sync된 정보 (히스토리의 인덱스 번호, time)\n    mapping(uint256 => LibLockId.SyncInfo) public syncInfoOfLockId;\n    bool internal _lock;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier ifFree {\n        require(_lock != true, \"in use\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n}\n"
    },
    "contracts/libraries/LibLockId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibLockId\n */\nlibrary LibLockId {\n\n    // LockId의 포인트 정보\n    struct Point {\n        int256 slope;\n        int256 bias;\n        uint256 timestamp; // 등록(시작)시점\n    }\n\n    // LockId의 잔고\n    struct LockedInfo {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 withdrawlTime;\n    }\n\n    // SyncInfo\n    struct SyncInfo {\n        int256 slope;\n        int256 bias;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n\n    struct SyncPacket {\n        uint256 lockId;\n        SyncInfo packet;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/libraries/LibLockTOS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibLockTOS {\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 timestamp;\n    }\n\n    struct LockedBalance {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        bool withdrawn;\n    }\n\n    struct SlopeChange {\n        int256 bias;\n        int256 slope;\n        uint256 changeTime;\n    }\n\n    struct LockedBalanceInfo {\n        uint256 id;\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 balance;\n    }\n}\n"
    },
    "contracts/libraries/LibProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface AddressManagerI {\n    function getAddress(string memory _name) external view returns (address);\n}\n\n/**\n * @title LibProject\n */\nlibrary LibProject {\n\n    enum TOKEN_TYPE {\n        ERC20_A,\n        ERC20_B,\n        ERC20_C,\n        ERC20_D,\n        NONE\n    }\n\n    enum L2_TYPE {\n        TOKAMAL_OPTIMISM,\n        TOKAMAL_ZKEVM,\n        NONE\n    }\n\n    struct ProjectInfo {\n        address projectOwner;\n        address tokenOwner;\n        address l1Token;\n        address l2Token;\n        address addressManager;\n        uint256 initialTotalSupply;\n        uint8 tokenType;\n        uint8 l2Type;\n        string projectName;\n    }\n\n    struct L2Info {\n        address l2TokenFactory;\n        address l2ProjectManager;\n        uint32 depositMinGasLimit;\n        uint32 sendMsgMinGasLimit;\n    }\n\n    struct L2ProjectInfo {\n        uint256 projectId;\n        address projectOwner;\n        address l1Token;\n        address l2Token;\n        string projectName;\n    }\n\n    struct TokamakVaults {\n        InitalParameterPublicSale publicSaleParams;\n        InitalParameterInitialLiquidityVault initialVaultParams;\n        InitalParameterLiquidityRewardVault rewardParams;\n        InitalParameterScheduleVault tosAirdropParams;\n        InitalParameterScheduleVault tonAirdropParams;\n    }\n\n    struct InitalParameterPublicSale {\n        InitalParameterPublicSaleVault vaultParams;\n        InitalParameterPublicSaleClaim claimParams;\n    }\n\n    struct InitalParameterPublicSaleVault {\n        uint256 stosTier1;\n        uint256 stosTier2;\n        uint256 stosTier3;\n        uint256 stosTier4;\n        uint256 tier1Percents;\n        uint256 tier2Percents;\n        uint256 tier3Percents;\n        uint256 tier4Percents;\n        uint256 total1roundSaleAmount;\n        uint256 total2roundSaleAmount;\n        uint256 saleTokenPrice;\n        uint256 payTokenPrice;\n        uint256 hardcapAmount;\n        uint256 changeTOSPercent;\n        uint256 startWhiteTime;\n        uint256 endWhiteTime;\n        uint256 start1roundTime;\n        uint256 end1roundTime;\n        uint256 snapshotTime;\n        uint256 start2roundTime;\n        uint256 end2roundTime;\n        uint256 claimCounts;\n    }\n\n    struct InitalParameterPublicSaleClaim {\n        uint256[] claimTimes;\n        uint256[] claimPercents;\n    }\n\n    struct InitalParameterInitialLiquidityVault {\n        uint256 totalAllocatedAmount;\n        uint256 tosPrice;\n        uint256 tokenPrice;\n        uint256 initSqrtPrice;\n        uint32 startTime;\n        uint16 fee;\n    }\n\n    struct InitalParameterLiquidityRewardVault {\n        address poolAddress;\n        InitalParameterScheduleVault params;\n    }\n\n    struct InitalParameterSchedule {\n        string vaultName;\n        InitalParameterScheduleVault params;\n    }\n\n    struct InitalParameterScheduleVault {\n        address claimer;\n        uint256 totalAllocatedAmount;\n        uint256 totalClaimCount;\n        uint256 firstClaimAmount;\n        uint32 firstClaimTime;\n        uint32 secondClaimTime;\n        uint32 roundIntervalTime;\n    }\n\n    struct InitalParameterNonScheduleVault {\n        string vaultName;\n        address claimer;\n        uint256 totalAllocatedAmount;\n    }\n\n    function getL1CommunicationMessenger(address addressManager) external view returns(address _address) {\n        if (addressManager == address(0)) return address(0);\n        try\n            AddressManagerI(addressManager).getAddress('Proxy__OVM_L1CrossDomainMessenger') returns (address a) {\n                _address = a;\n        } catch (bytes memory ) {\n            _address = address(0);\n        }\n    }\n\n    function getL1Bridge(address addressManager) external view returns(address _address) {\n        if (addressManager == address(0)) return address(0);\n        try\n            AddressManagerI(addressManager).getAddress('Proxy__OVM_L1StandardBridge') returns (address a) {\n                _address = a;\n        } catch (bytes memory ) {\n            _address = address(0);\n        }\n    }\n\n    function validateTokamakVaults(TokamakVaults memory tokamakVaults)\n    public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        // if ((tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount\n        //     +tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount) == 0 ||\n        //     tokamakVaults.initialVaultParams.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.rewardParams.params.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.tosAirdropParams.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.tonAirdropParams.totalAllocatedAmount == 0\n        // ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.initialVaultParams.tosPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.tokenPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.initSqrtPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.startTime == 0 ||\n        //     tokamakVaults.initialVaultParams.fee == 0) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.rewardParams.poolAddress == address(0) ||\n        //     tokamakVaults.rewardParams.params.totalClaimCount == 0 ||\n        //     tokamakVaults.rewardParams.params.firstClaimAmount == 0 ||\n        //     tokamakVaults.rewardParams.params.firstClaimTime == 0 ||\n        //     tokamakVaults.rewardParams.params.secondClaimTime == 0 ||\n        //     tokamakVaults.rewardParams.params.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.tosAirdropParams.totalClaimCount == 0 ||\n        //     tokamakVaults.tosAirdropParams.firstClaimAmount == 0 ||\n        //     tokamakVaults.tosAirdropParams.firstClaimTime == 0 ||\n        //     tokamakVaults.tosAirdropParams.secondClaimTime == 0 ||\n        //     tokamakVaults.tosAirdropParams.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.tonAirdropParams.totalClaimCount == 0 ||\n        //     tokamakVaults.tonAirdropParams.firstClaimAmount == 0 ||\n        //     tokamakVaults.tonAirdropParams.firstClaimTime == 0 ||\n        //     tokamakVaults.tonAirdropParams.secondClaimTime == 0 ||\n        //     tokamakVaults.tonAirdropParams.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n\n        totalAmount = tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount +\n                    tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount +\n                    tokamakVaults.initialVaultParams.totalAllocatedAmount +\n                    tokamakVaults.rewardParams.params.totalAllocatedAmount +\n                    tokamakVaults.tosAirdropParams.totalAllocatedAmount +\n                    tokamakVaults.tonAirdropParams.totalAllocatedAmount ;\n\n        if (totalAmount == 0) return (boolValidate, totalAmount);\n\n        boolValidate = true;\n    }\n\n    function validateScheduleVault(\n        InitalParameterSchedule[] memory customs\n    ) public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        if (customs.length != 0) {\n            for(uint256 i = 0; i < customs.length; i++){\n                if (customs[i].params.totalAllocatedAmount == 0 ||\n                    customs[i].params.totalClaimCount == 0 ||\n                    customs[i].params.firstClaimAmount == 0 ||\n                    customs[i].params.firstClaimTime == 0 ||\n                    customs[i].params.secondClaimTime == 0 ||\n                    customs[i].params.roundIntervalTime == 0\n                    ) return (boolValidate, totalAmount);\n\n                totalAmount += customs[i].params.totalAllocatedAmount;\n            }\n            boolValidate = true;\n        }\n    }\n\n    function validateNonScheduleVault(\n        InitalParameterNonScheduleVault[] memory customs\n    ) public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        if (customs.length != 0) {\n            for(uint256 i =0 ; i < customs.length; i++){\n                if (customs[i].totalAllocatedAmount == 0) return (boolValidate, totalAmount);\n                totalAmount += customs[i].totalAllocatedAmount;\n            }\n            boolValidate = true;\n        }\n    }\n\n}\n"
    },
    "contracts/proxy/ProxyStorage2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ncontract ProxyStorage2  {\n\n    address public _owner;\n    bool public pauseProxy;\n\n    mapping(uint256 => address) public proxyImplementation;\n    mapping(address => bool) public aliveImplementation;\n    mapping(bytes4 => address) public selectorImplementation;\n\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 625
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}