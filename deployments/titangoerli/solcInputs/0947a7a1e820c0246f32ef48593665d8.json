{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IIERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IIERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IProxyAction.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\n\n/// @title IProxyAction\ninterface IProxyAction {\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index\n    /// @param _alive _alive\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external;\n\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        external;\n\n\n    /// @dev set selectors of Implementation\n    /// @param _selectors being added selectors\n    /// @param _imp implementation address\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) external  ;\n\n\n\n    /// onlyOwner\n\n    /// @notice Set pause state\n    /// @param _pause true:pause or false:resume\n    function setProxyPause(bool _pause) external ;\n\n\n    /// anybody\n\n    /// @dev view implementation address of selector of function\n    /// @param _selector selector of function\n    /// @return impl address of the implementation\n    function getSelectorImplementation2(bytes4 _selector)\n        external\n        view\n        returns (address impl);\n\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return address of the implementation\n    function implementation2(uint256 _index) external view returns (address) ;\n}\n\n"
    },
    "contracts/interfaces/IProxyEvent.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\n\n/// @title IProxyEvent\ninterface IProxyEvent {\n\n    event Upgraded(address indexed implementation);\n\n    event SetAliveImplementation(address indexed impl, bool alive);\n    event SetSelectorImplementation(bytes4 indexed selector, address indexed impl);\n\n\n}\n"
    },
    "contracts/libraries/LibLockId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibLockId\n */\nlibrary LibLockId {\n\n    // LockId의 포인트 정보\n    struct Point {\n        int256 slope;\n        int256 bias;\n        uint256 timestamp; // 등록(시작)시점\n    }\n\n    // LockId의 잔고\n    struct LockedInfo {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 withdrawlTime;\n    }\n\n    // SyncInfo\n    struct SyncInfo {\n        int256 slope;\n        int256 bias;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n\n    struct SyncPacket {\n        uint256 lockId;\n        SyncInfo packet;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/proxy/Proxy2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"./ProxyStorage2.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IProxyEvent.sol\";\nimport \"../interfaces/IProxyAction.sol\";\n// import \"hardhat/console.sol\";\n\ncontract Proxy2 is ProxyStorage2, IProxyEvent, IProxyAction\n{\n\n    /* ========== DEPENDENCIES ========== */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"not owner\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /* ========== onlyOwner ========== */\n\n    function renounceOwnership() external onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /// @inheritdoc IProxyAction\n    function setProxyPause(bool _pause) external onlyOwner {\n        pauseProxy = _pause;\n    }\n\n    /// @notice Set implementation contract\n    /// @param impl New implementation contract address\n    function upgradeTo(address impl) external onlyOwner {\n        require(impl != address(0), \"input is zero\");\n        require(\n            _implementation2(0) != impl,\n            \"same addr\"\n        );\n        _setImplementation2(impl, 0, true);\n        emit Upgraded(impl);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        public\n        payable\n        virtual\n        onlyOwner\n        returns (bytes memory)\n    {\n        // _setImplementation(_implementation);\n        _setImplementation2(_implementation, 0, true);\n\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /// @inheritdoc IProxyAction\n    function setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) external override onlyOwner {\n        _setImplementation2(newImplementation, _index, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setAliveImplementation2(address newImplementation, bool _alive)\n        public override onlyOwner\n    {\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @inheritdoc IProxyAction\n    function setSelectorImplementations2(\n        bytes4[] calldata _selectors,\n        address _imp\n    ) public override onlyOwner {\n        require(\n            _selectors.length > 0,\n            \"Proxy: _selectors's size is zero\"\n        );\n        require(aliveImplementation[_imp], \"Proxy: _imp is not alive\");\n\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            require(\n                selectorImplementation[_selectors[i]] != _imp,\n                \"LiquidityVaultProxy: same imp\"\n            );\n            selectorImplementation[_selectors[i]] = _imp;\n            emit SetSelectorImplementation(_selectors[i], _imp);\n        }\n    }\n\n    /* ========== Anyone can   ========== */\n\n\n\n    /* ========== VIEW ========== */\n\n    /// @dev returns the implementation\n    function implementation() external view returns (address) {\n        return _implementation2(0);\n    }\n\n    /// @inheritdoc IProxyAction\n    function implementation2(uint256 _index) external override view returns (address) {\n        return _implementation2(_index);\n    }\n\n\n    /// @inheritdoc IProxyAction\n    function getSelectorImplementation2(bytes4 _selector)\n        public override\n        view\n        returns (address impl)\n    {\n        if (selectorImplementation[_selector] == address(0))\n            return proxyImplementation[0];\n        else if (aliveImplementation[selectorImplementation[_selector]]){\n            return selectorImplementation[_selector];\n        }\n        else return proxyImplementation[0];\n    }\n\n\n    /// @dev receive ether\n    receive() external payable {\n        revert(\"cannot receive Ether\");\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    fallback() external payable {\n        _fallback();\n    }\n\n    /* === ======= internal ========== */\n\n    /// @dev view implementation address of the proxy[index]\n    /// @param _index index of proxy\n    /// @return impl address of the implementation\n    function _implementation2(uint256 _index)\n        internal\n        view\n        returns (address impl)\n    {\n        return proxyImplementation[_index];\n    }\n\n    /// @dev fallback function , execute on undefined function call\n    function _fallback() internal {\n        address _impl = getSelectorImplementation2(msg.sig);\n\n        require(\n            _impl != address(0) && !pauseProxy,\n            \"Proxy: impl OR proxy is false\"\n        );\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /// @dev set the implementation address and status of the proxy[index]\n    /// @param newImplementation Address of the new implementation.\n    /// @param _index index of proxy\n    /// @param _alive alive status\n    function _setImplementation2(\n        address newImplementation,\n        uint256 _index,\n        bool _alive\n    ) internal {\n        require(\n            Address.isContract(newImplementation),\n            \"Proxy: not contract address\"\n        );\n        if (_alive) proxyImplementation[_index] = newImplementation;\n        _setAliveImplementation2(newImplementation, _alive);\n    }\n\n    /// @dev set alive status of implementation\n    /// @param newImplementation Address of the new implementation.\n    /// @param _alive alive status\n    function _setAliveImplementation2(address newImplementation, bool _alive)\n        internal\n    {\n        aliveImplementation[newImplementation] = _alive;\n        emit SetAliveImplementation(newImplementation, _alive);\n    }\n\n}"
    },
    "contracts/proxy/ProxyStorage2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ncontract ProxyStorage2  {\n\n    address public _owner;\n    bool public pauseProxy;\n\n    mapping(uint256 => address) public proxyImplementation;\n    mapping(address => bool) public aliveImplementation;\n    mapping(bytes4 => address) public selectorImplementation;\n\n\n}"
    },
    "contracts/stos/ERC165P.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IIERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165P is IIERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) internal _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}"
    },
    "contracts/stos/LockIdNftForRegisterProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../proxy/Proxy2.sol\";\nimport \"./LockIdRegisterStorage1.sol\";\nimport \"./LockIdRegisterStorage2.sol\";\n\ncontract LockIdNftForRegisterProxy is Proxy2, LockIdRegisterStorage1, LockIdRegisterStorage2\n{\n    event ManagershipTransferred(address indexed previousManager, address indexed newManager);\n\n    constructor() {\n        _manager = msg.sender;\n    }\n\n    function renounceManagership() external onlyManager {\n        emit ManagershipTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    function transferManagership(address newManager) external onlyManager {\n        require(newManager != address(0), \"new manager is the zero address\");\n        emit ManagershipTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n\n}\n"
    },
    "contracts/stos/LockIdRegisterStorage1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./ERC165P.sol\";\n\ncontract LockIdRegisterStorage1 is ERC165P {\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 public constant _ERC721_RECEIVED = 0x150b7a02;\n\n    address public _manager;\n\n    // Token name\n    string public _name;\n\n    // Token symbol\n    string public _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) public _tokenURIs;\n\n    // attributes\n    mapping (uint256 => uint8) public _tokenAttributes;\n\n    // Base URI\n    string public _baseURI;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) public _tokenOwner; // _owners\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) public _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) public _ownedTokensCount; // _balances\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) public _operatorApprovals;\n\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) public _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) public _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] public _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) public _allTokensIndex;\n\n    bool internal _lock;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 public constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier ifFree {\n        require(_lock != true, \"in use\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n\n}\n"
    },
    "contracts/stos/LockIdRegisterStorage2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries//LibLockId.sol\";\n\ncontract LockIdRegisterStorage2 {\n\n    uint256 public constant MULTIPLIER = 1e18;\n\n    uint256 public epochUnit;\n    uint256 public maxTime;\n\n    // id - point , 특정아이디의 포인트를 모두 저장\n    mapping(uint256 => LibLockId.SyncInfo[]) public pointHistoryByLockId;\n\n    // 시간대순으로 모든 stos를 관리하는 정보\n    // 시간대의 타임 (매주목요일0시) -> 해당 시간대의 포인트 배열\n    mapping(uint256 => LibLockId.SyncInfo[]) public pointHistoryByWeek;\n\n    // 업데이트가 있는 주(타임)에 대한 인덱싱\n    uint256[] public indexOfTimeset;\n    mapping(uint256 => bool) public indexCheckOfTimeset;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 625
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}