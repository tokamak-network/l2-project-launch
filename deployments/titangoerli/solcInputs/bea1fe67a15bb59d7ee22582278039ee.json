{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1StosToL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { LibProject } from \"../libraries/LibProject.sol\";\nimport \"../libraries/LibLockTOS.sol\";\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./L1StosToL2Storage.sol\";\n// import \"hardhat/console.sol\";\n\ninterface ILockTos {\n    function locksInfo(uint256 _lockId)\n            external\n            view\n            returns (\n                uint256 start,\n                uint256 end,\n                uint256 amount\n            );\n\n    function locksOf(address _addr)\n        external\n        view\n        returns (uint256[] memory);\n\n    function pointHistoryOf(uint256 _lockId)\n        external\n        view\n        returns (LibLockTOS.Point[] memory);\n\n}\n\ninterface IL1StosInL2 {\n    function register(bytes memory data) external ;\n}\n\ninterface L1CrossDomainMessengerI {\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) external;\n}\n\n\ncontract L1StosToL2 is ProxyStorage2, L1StosToL2Storage {\n\n    /* ========== DEPENDENCIES ========== */\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"not owner\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor () {\n\n    }\n\n    function initialize (\n        address managerAddress,\n        address lockTosAddress,\n        address addressManagerAddress,\n        uint256 maxLockCountPerRegister_,\n        uint32 minGasLimitRegister_\n    ) external onlyOwner {\n        _manager = managerAddress;\n        lockTos = lockTosAddress;\n        addressManager = addressManagerAddress;\n        maxLockCountPerRegister = maxLockCountPerRegister_;\n        minGasLimitRegister = minGasLimitRegister_;\n    }\n\n    function setL2Register(address l2Register_) external onlyManager {\n        require(l2Register != l2Register_, \"same\");\n        l2Register = l2Register_;\n    }\n\n    /* ========== Anybody can ========== */\n\n    function register(address account) public {\n        uint256[] memory lockIds = ILockTos(lockTos).locksOf(account);\n        // console.log(\"register %s\", account);\n        // console.log(\"lockIds.length %s\", lockIds.length);\n        require(lockIds.length != 0, \"no register data\");\n        require(lockIds.length <= maxLockCountPerRegister, \"exceeded the maximum number of register.\");\n        _register(account, lockIds);\n    }\n\n    function register(address account, uint256[] memory lockIds) public {\n        require(lockIds.length <= maxLockCountPerRegister, \"exceeded the maximum number of register.\");\n        require(lockIds.length != 0, \"no register data\");\n        uint256[] memory userLockIds = ILockTos(lockTos).locksOf(account);\n\n        for(uint256 i = 0; i < lockIds.length; i++){\n            bool unMatched = true;\n            for(uint256 j = 0; j < userLockIds.length; j++){\n                if(lockIds[i] == userLockIds[j]) {\n                    unMatched = false;\n                    if(j < userLockIds.length-1)\n                        userLockIds[j] = userLockIds[userLockIds.length-1];\n                    delete userLockIds[userLockIds.length-1];\n                    break;\n                }\n            }\n            require(!unMatched, \"owner is not account\");\n        }\n\n        _register(account, lockIds);\n    }\n\n    /* ========== VIEW ========== */\n\n    function needSyncList(address account) public view returns (uint256[] memory lockIds) {\n        uint256[] memory ids = ILockTos(lockTos).locksOf(account);\n\n        for(uint256 i = 0; i < ids.length; i++){\n            LibLockId.SyncInfo memory curSync = syncInfoOfLockId[ids[i]];\n            (, uint256 end, uint256 amount) = ILockTos(lockTos).locksInfo(ids[i]);\n            if(amount != 0 && block.timestamp < end) {\n                LibLockTOS.Point[] memory history = ILockTos(lockTos).pointHistoryOf(ids[i]);\n                if(history.length != 0){\n                    LibLockTOS.Point memory point = history[history.length-1];\n                    if(curSync.timestamp < point.timestamp) lockIds[lockIds.length-1] = ids[i];\n                }\n            }\n        }\n    }\n\n    function viewRegisterInfoOfLockId(uint256 lockId) external view returns(LibLockId.SyncInfo memory) {\n        return syncInfoOfLockId[lockId];\n    }\n\n    /* === ======= internal ========== */\n\n    function _register(address account, uint256[] memory lockIds) internal {\n\n        bytes memory syncPackets ;\n        uint256 syncIdsCount ;\n\n        // packet {address: count to sync: 1st sync packet: 2nd sync packet: .....}\n        // address : 20 bytes\n        // count to sync : 1 byte (max 256 sync packets) but it is less than maxLockCountPerSync\n        // sync packets : count to sync * 104 bytes ( count * 104 )\n        // one sync packets : 104 bytes:  (32 byte) uint256 lockId, (32+32+4+4) syncInfo -> total 104\n\n        for(uint256 i = 0; i < lockIds.length; i++){\n\n            LibLockId.SyncInfo memory curSync = syncInfoOfLockId[lockIds[i]];\n\n            (, uint256 end, uint256 amount) = ILockTos(lockTos).locksInfo(lockIds[i]);\n\n            if (amount != 0 && block.timestamp < end){\n                LibLockTOS.Point[] memory history = ILockTos(lockTos).pointHistoryOf(lockIds[i]);\n\n                if(history.length != 0){\n                    LibLockTOS.Point memory point = history[history.length-1];\n\n                    if(curSync.timestamp < point.timestamp) {\n                        LibLockId.SyncInfo memory newSync = LibLockId.SyncInfo(\n                            {\n                                slope: point.slope,\n                                bias: point.bias,\n                                timestamp: uint32(point.timestamp),\n                                syncTime: uint32(block.timestamp)\n                            }\n                        );\n\n                        syncInfoOfLockId[lockIds[i]] = newSync;\n                        syncIdsCount++;\n\n                        syncPackets = bytes.concat(syncPackets,\n                            abi.encodePacked(lockIds[i], newSync.slope, newSync.bias, newSync.timestamp, newSync.syncTime));\n\n                    }\n                }\n            }\n        }\n\n        require(syncPackets.length > 0, \"no register data\");\n        // console.log('_register syncPackets.length  %s', syncPackets.length);\n\n        _sendMessage(\n            l2Register,\n            abi.encodePacked(account, syncPackets),\n            // bytes.concat(abi.encodePacked(account), syncPackets),\n            minGasLimitRegister\n            );\n    }\n\n\n    function _sendMessage(address target, bytes memory data, uint32 minGasLimit) internal {\n        address l1Messenger = LibProject.getL1CommunicationMessenger(addressManager);\n        require(l1Messenger != address(0), \"l1Messenger is ZeroAddress\");\n\n        bytes memory callData = abi.encodeWithSelector(IL1StosInL2.register.selector, data);\n\n        // console.log('_sendMessage target %s', target, ' data.length %s', data.length);\n        // console.logBytes(data);\n        // console.log('_sendMessage l1Messenger %s', l1Messenger);\n\n        L1CrossDomainMessengerI(l1Messenger).sendMessage(\n                target,\n                callData,\n                minGasLimit\n            );\n    }\n\n}"
    },
    "contracts/L1/L1StosToL2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/LibLockId.sol\";\n\ncontract L1StosToL2Storage  {\n    uint256 public maxLockCountPerRegister;\n    address public _manager;\n    address public addressManager;\n    address public lockTos;\n    address public l2Register;\n    uint32 minGasLimitRegister;\n\n    // account-lockId-sync된 정보 (히스토리의 인덱스 번호, time)\n    mapping(uint256 => LibLockId.SyncInfo) public syncInfoOfLockId;\n    bool internal _lock;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n    modifier ifFree {\n        require(_lock != true, \"in use\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n}\n"
    },
    "contracts/L2/L1StosInL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/LibLockId.sol\";\n\nimport \"../proxy/ProxyStorage2.sol\";\nimport \"./L1StosInL2Storage.sol\";\n\n// import \"hardhat/console.sol\";\n\ninterface ILockIdNftForRegister {\n    function register(\n        address account,\n        LibLockId.SyncPacket[] memory packets\n    ) external;\n}\n\ninterface IL2CrossDomainMessenger {\n    function xDomainMessageSender() external view returns (address);\n}\n\ncontract L1StosInL2 is ProxyStorage2, L1StosInL2Storage {\n    using BytesLib for bytes;\n\n    modifier onlyMessengerAndL1Register() {\n\n        require(\n            l2CrossDomainMessenger == msg.sender &&\n            IL2CrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender() == l1Register,\n            \"not onlyMessengerAndL1Register\");\n        _;\n    }\n\n    modifier nonZero(uint256 _val) {\n        require(_val != 0, \"zero value\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"not owner\");\n        _;\n    }\n\n    function initialize (\n        address managerAddress,\n        address l2messanger_\n    ) external onlyOwner  {\n        _manager = managerAddress;\n        l2CrossDomainMessenger =l2messanger_;\n    }\n\n    function setL1Register(address l1Register_) external onlyManager {\n        require(l1Register != l1Register_, \"same\");\n        l1Register = l1Register_;\n    }\n\n    function setLockIdNft(address lockIdNft_) external onlyManager {\n        require(lockIdNftForRegister != lockIdNft_, \"same\");\n        lockIdNftForRegister = lockIdNft_;\n    }\n\n    /*** Public ***/\n    // function register(bytes memory data) public {\n    //     console.log('IL1StosInL2 register in' );\n    //     console.logBytes(data);\n    //     console.log('IL1StosInL2 l2CrossDomainMessenger %s', l2CrossDomainMessenger);\n    //     console.log('IL1StosInL2 msg.sender %s', msg.sender );\n    //     address xDomainMessageSender = IL2CrossDomainMessenger(l2CrossDomainMessenger).xDomainMessageSender();\n\n    //     console.log('IL1StosInL2 xDomainMessageSender %s', xDomainMessageSender );\n    //     console.log('IL1StosInL2 l1Register %s', l1Register );\n\n\n    // }\n\n    function register(bytes memory data) public onlyMessengerAndL1Register {\n\n        // packet {address | 1st sync packet  2nd sync packet  .....}\n        // address : 20 bytes\n        // one sync packets : 104 bytes:  (32 byte) uint256 lockId, (32+32+4+4) syncInfo -> total 104\n        require(data.length > 123, \"wrong bytes length\");\n        address user = data.toAddress(0);\n\n        LibLockId.SyncPacket[] memory packets = decodeSyncPackets(data.slice(20,(data.length-20)));\n\n        require(packets.length != 0, \"no sync data\");\n        ILockIdNftForRegister(lockIdNftForRegister).register(user, packets);\n    }\n\n    function multiRegister(bytes[] memory datas) external onlyMessengerAndL1Register {\n        require(datas.length != 0, \"no data\");\n        for(uint256 i = 0; i < datas.length; i++) {\n            register(datas[i]);\n        }\n    }\n\n\n    function decodeSyncPackets(bytes memory data) public pure returns (LibLockId.SyncPacket[] memory packets) {\n        uint256 packSize = 104;\n        uint256 len = data.length / packSize;\n        packets = new LibLockId.SyncPacket[](len);\n        for(uint256 i = 0; i < len ; i++){\n            bytes memory packet = data.slice(i, packSize);\n            packets[i] = LibLockId.SyncPacket({\n                lockId: packet.toUint256(0),\n                packet: LibLockId.SyncInfo({\n                    slope: packet.toInt256(32),\n                    bias: packet.toInt256(64),\n                    timestamp: packet.toUint32(96),\n                    syncTime: packet.toUint32(100)\n                })\n            });\n        }\n    }\n\n}\n"
    },
    "contracts/L2/L1StosInL2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract L1StosInL2Storage  {\n    address public _manager;\n    address public lockIdNftForRegister;\n    address public l2CrossDomainMessenger;\n    address public l1Register;\n\n    modifier onlyManager() {\n        require(_manager == msg.sender, \"not manager\");\n        _;\n    }\n\n}"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.8.0;\n// pragma solidity >=0.5.0 <0.8.0;\n\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, 'toUint8_overflow');\n        require(_bytes.length >= _start + 1, 'toUint8_outOfBounds');\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBool(bytes memory _bytes, uint256 _start) internal pure returns (bool) {\n        require(_start + 1 >= _start, 'toBool_overflow');\n        require(_bytes.length >= _start + 1, 'toBool_overflow');\n        bool tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_start + 2 >= _start, 'toUint16_overflow');\n        require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_start + 4 >= _start, 'toUint32_overflow');\n        require(_bytes.length >= _start + 4, 'toUint32_outOfBounds');\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_start + 32 >= _start, 'toUint256_overflow');\n        require(_bytes.length >= _start + 32, 'toUint256_outOfBounds');\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toInt256(bytes memory _bytes, uint256 _start) internal pure returns (int256) {\n        require(_start + 32 >= _start, 'toUint256_overflow');\n        require(_bytes.length >= _start + 32, 'toUint256_outOfBounds');\n        int256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/libraries/LibLockId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title LibLockId\n */\nlibrary LibLockId {\n\n    // LockId의 포인트 정보\n    struct Point {\n        int256 slope;\n        int256 bias;\n        uint256 timestamp; // 등록(시작)시점\n    }\n\n    // LockId의 잔고\n    struct LockedInfo {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 withdrawlTime;\n    }\n\n    // SyncInfo\n    struct SyncInfo {\n        int256 slope;\n        int256 bias;\n        uint32 timestamp; // point 정보에 있는 인덱스에 해당하는 timestamp\n        uint32 syncTime; // 동기화 시점\n    }\n\n    struct SyncPacket {\n        uint256 lockId;\n        SyncInfo packet;\n    }\n\n    struct UnlimitedAmount {\n        uint32 timestamp;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/libraries/LibLockTOS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibLockTOS {\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 timestamp;\n    }\n\n    struct LockedBalance {\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        bool withdrawn;\n    }\n\n    struct SlopeChange {\n        int256 bias;\n        int256 slope;\n        uint256 changeTime;\n    }\n\n    struct LockedBalanceInfo {\n        uint256 id;\n        uint256 start;\n        uint256 end;\n        uint256 amount;\n        uint256 balance;\n    }\n}\n"
    },
    "contracts/libraries/LibProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface AddressManagerI {\n    function getAddress(string memory _name) external view returns (address);\n}\n\n/**\n * @title LibProject\n */\nlibrary LibProject {\n\n    enum TOKEN_TYPE {\n        ERC20_A,\n        ERC20_B,\n        ERC20_C,\n        ERC20_D,\n        NONE\n    }\n\n    enum L2_TYPE {\n        TOKAMAL_OPTIMISM,\n        TOKAMAL_ZKEVM,\n        NONE\n    }\n\n    struct ProjectInfo {\n        address projectOwner;\n        address tokenOwner;\n        address l1Token;\n        address l2Token;\n        address addressManager;\n        uint256 initialTotalSupply;\n        uint8 tokenType;\n        uint8 l2Type;\n        string projectName;\n    }\n\n    struct L2Info {\n        address l2TokenFactory;\n        address l2ProjectManager;\n        uint32 depositMinGasLimit;\n        uint32 sendMsgMinGasLimit;\n    }\n\n    struct L2ProjectInfo {\n        uint256 projectId;\n        address projectOwner;\n        address l1Token;\n        address l2Token;\n        string projectName;\n    }\n\n    struct TokamakVaults {\n        InitalParameterPublicSale publicSaleParams;\n        InitalParameterInitialLiquidityVault initialVaultParams;\n        InitalParameterLiquidityRewardVault rewardParams;\n        InitalParameterScheduleVault tosAirdropParams;\n        InitalParameterScheduleVault tonAirdropParams;\n    }\n\n    struct InitalParameterPublicSale {\n        InitalParameterPublicSaleVault vaultParams;\n        InitalParameterPublicSaleClaim claimParams;\n    }\n\n    struct InitalParameterPublicSaleVault {\n        uint256 stosTier1;\n        uint256 stosTier2;\n        uint256 stosTier3;\n        uint256 stosTier4;\n        uint256 tier1Percents;\n        uint256 tier2Percents;\n        uint256 tier3Percents;\n        uint256 tier4Percents;\n        uint256 total1roundSaleAmount;\n        uint256 total2roundSaleAmount;\n        uint256 saleTokenPrice;\n        uint256 payTokenPrice;\n        uint256 hardcapAmount;\n        uint256 changeTOSPercent;\n        uint256 startWhiteTime;\n        uint256 endWhiteTime;\n        uint256 start1roundTime;\n        uint256 end1roundTime;\n        uint256 snapshotTime;\n        uint256 start2roundTime;\n        uint256 end2roundTime;\n        uint256 claimCounts;\n    }\n\n    struct InitalParameterPublicSaleClaim {\n        uint256[] claimTimes;\n        uint256[] claimPercents;\n    }\n\n    struct InitalParameterInitialLiquidityVault {\n        uint256 totalAllocatedAmount;\n        uint256 tosPrice;\n        uint256 tokenPrice;\n        uint256 initSqrtPrice;\n        uint32 startTime;\n        uint16 fee;\n    }\n\n    struct InitalParameterLiquidityRewardVault {\n        address poolAddress;\n        InitalParameterScheduleVault params;\n    }\n\n    struct InitalParameterSchedule {\n        string vaultName;\n        InitalParameterScheduleVault params;\n    }\n\n    struct InitalParameterScheduleVault {\n        address claimer;\n        uint256 totalAllocatedAmount;\n        uint256 totalClaimCount;\n        uint256 firstClaimAmount;\n        uint32 firstClaimTime;\n        uint32 secondClaimTime;\n        uint32 roundIntervalTime;\n    }\n\n    struct InitalParameterNonScheduleVault {\n        string vaultName;\n        address claimer;\n        uint256 totalAllocatedAmount;\n    }\n\n    function getL1CommunicationMessenger(address addressManager) external view returns(address _address) {\n        if (addressManager == address(0)) return address(0);\n        try\n            AddressManagerI(addressManager).getAddress('Proxy__OVM_L1CrossDomainMessenger') returns (address a) {\n                _address = a;\n        } catch (bytes memory ) {\n            _address = address(0);\n        }\n    }\n\n    function getL1Bridge(address addressManager) external view returns(address _address) {\n        if (addressManager == address(0)) return address(0);\n        try\n            AddressManagerI(addressManager).getAddress('Proxy__OVM_L1StandardBridge') returns (address a) {\n                _address = a;\n        } catch (bytes memory ) {\n            _address = address(0);\n        }\n    }\n\n    function validateTokamakVaults(TokamakVaults memory tokamakVaults)\n    public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        // if ((tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount\n        //     +tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount) == 0 ||\n        //     tokamakVaults.initialVaultParams.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.rewardParams.params.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.tosAirdropParams.totalAllocatedAmount == 0 ||\n        //     tokamakVaults.tonAirdropParams.totalAllocatedAmount == 0\n        // ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.initialVaultParams.tosPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.tokenPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.initSqrtPrice == 0 ||\n        //     tokamakVaults.initialVaultParams.startTime == 0 ||\n        //     tokamakVaults.initialVaultParams.fee == 0) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.rewardParams.poolAddress == address(0) ||\n        //     tokamakVaults.rewardParams.params.totalClaimCount == 0 ||\n        //     tokamakVaults.rewardParams.params.firstClaimAmount == 0 ||\n        //     tokamakVaults.rewardParams.params.firstClaimTime == 0 ||\n        //     tokamakVaults.rewardParams.params.secondClaimTime == 0 ||\n        //     tokamakVaults.rewardParams.params.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.tosAirdropParams.totalClaimCount == 0 ||\n        //     tokamakVaults.tosAirdropParams.firstClaimAmount == 0 ||\n        //     tokamakVaults.tosAirdropParams.firstClaimTime == 0 ||\n        //     tokamakVaults.tosAirdropParams.secondClaimTime == 0 ||\n        //     tokamakVaults.tosAirdropParams.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n        // if (tokamakVaults.tonAirdropParams.totalClaimCount == 0 ||\n        //     tokamakVaults.tonAirdropParams.firstClaimAmount == 0 ||\n        //     tokamakVaults.tonAirdropParams.firstClaimTime == 0 ||\n        //     tokamakVaults.tonAirdropParams.secondClaimTime == 0 ||\n        //     tokamakVaults.tonAirdropParams.roundIntervalTime == 0\n        //     ) return (boolValidate, totalAmount);\n\n\n        totalAmount = tokamakVaults.publicSaleParams.vaultParams.total1roundSaleAmount +\n                    tokamakVaults.publicSaleParams.vaultParams.total2roundSaleAmount +\n                    tokamakVaults.initialVaultParams.totalAllocatedAmount +\n                    tokamakVaults.rewardParams.params.totalAllocatedAmount +\n                    tokamakVaults.tosAirdropParams.totalAllocatedAmount +\n                    tokamakVaults.tonAirdropParams.totalAllocatedAmount ;\n\n        if (totalAmount == 0) return (boolValidate, totalAmount);\n\n        boolValidate = true;\n    }\n\n    function validateScheduleVault(\n        InitalParameterSchedule[] memory customs\n    ) public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        if (customs.length != 0) {\n            for(uint256 i = 0; i < customs.length; i++){\n                if (customs[i].params.totalAllocatedAmount == 0 ||\n                    customs[i].params.totalClaimCount == 0 ||\n                    customs[i].params.firstClaimAmount == 0 ||\n                    customs[i].params.firstClaimTime == 0 ||\n                    customs[i].params.secondClaimTime == 0 ||\n                    customs[i].params.roundIntervalTime == 0\n                    ) return (boolValidate, totalAmount);\n\n                totalAmount += customs[i].params.totalAllocatedAmount;\n            }\n            boolValidate = true;\n        }\n    }\n\n    function validateNonScheduleVault(\n        InitalParameterNonScheduleVault[] memory customs\n    ) public pure returns (bool boolValidate, uint256 totalAmount) {\n\n        if (customs.length != 0) {\n            for(uint256 i =0 ; i < customs.length; i++){\n                if (customs[i].totalAllocatedAmount == 0) return (boolValidate, totalAmount);\n                totalAmount += customs[i].totalAllocatedAmount;\n            }\n            boolValidate = true;\n        }\n    }\n\n}\n"
    },
    "contracts/proxy/ProxyStorage2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\ncontract ProxyStorage2  {\n\n    address public _owner;\n    bool public pauseProxy;\n\n    mapping(uint256 => address) public proxyImplementation;\n    mapping(address => bool) public aliveImplementation;\n    mapping(bytes4 => address) public selectorImplementation;\n\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 625
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}